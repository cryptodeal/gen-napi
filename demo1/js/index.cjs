// Code generated by gen-napi. DO NOT EDIT.
const { TensorBackendType, MatrixProperty, SortMode, dtype, PadType } = require('./gen_enums.cjs');
const { Tensor } = require('./tensor.cjs');
const addon = require('../../build/Release/shumai_bindings.node');

exports.isnan = (tensor) => {
  return new Tensor(addon._isnan(tensor._native_ref));
};

exports.std = (input, axes = [], keepDims = false) => {
  return new Tensor(
    addon._std(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

exports.norm = (input, axes = [], p = 2, keepDims = false) => {
  return new Tensor(
    addon._norm(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      p,
      keepDims
    )
  );
};

exports.any = (input, axes = [], keepDims = false) => {
  return new Tensor(
    addon._any(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

exports.negative = (tensor) => {
  return new Tensor(addon._negative(tensor._native_ref));
};

exports.sin = (tensor) => {
  return new Tensor(addon._sin(tensor._native_ref));
};

exports.floor = (tensor) => {
  return new Tensor(addon._floor(tensor._native_ref));
};

exports.mean = (input, axes = [], keepDims = false) => {
  return new Tensor(
    addon._mean(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

exports.transpose = (tensor, axes = []) => {
  return new Tensor(
    addon._transpose(
      tensor._native_ref,
      axes instanceof BigInt64Array
        ? axes
        : new BigInt64Array(axes.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
    )
  );
};

exports.log = (tensor) => {
  return new Tensor(addon._log(tensor._native_ref));
};

exports.ceil = (tensor) => {
  return new Tensor(addon._ceil(tensor._native_ref));
};

exports.clip = (tensor, low, high) => {
  return new Tensor(addon._clip(tensor._native_ref, low._native_ref, high._native_ref));
};

exports.minimum = (lhs, rhs) => {
  return new Tensor(addon._minimum(lhs._native_ref, rhs._native_ref));
};

exports.matmul = (lhs, rhs, lhsProp = MatrixProperty.None, rhsProp = MatrixProperty.None) => {
  return new Tensor(addon._matmul(lhs._native_ref, rhs._native_ref, lhsProp, rhsProp));
};

exports.amin = (input, axes = [], keepDims = false) => {
  return new Tensor(
    addon._amin(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

exports.nonzero = (tensor) => {
  return new Tensor(addon._nonzero(tensor._native_ref));
};

exports.argsort = (input, axis, sortMode = SortMode.Ascending) => {
  return new Tensor(addon._argsort(input._native_ref, axis, sortMode));
};

exports.argmax = (input, axis, keepDims = false) => {
  return new Tensor(addon._argmax(input._native_ref, axis, keepDims));
};

exports.all = (input, axes = [], keepDims = false) => {
  return new Tensor(
    addon._all(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

exports.full = (dims, val, type) => {
  return new Tensor(
    addon._full(
      dims instanceof BigInt64Array
        ? dims
        : new BigInt64Array(dims.map((v) => (typeof v === 'number' ? BigInt(v) : v))),
      val,
      type
    )
  );
};

exports.pad = (input, padWidths, type = PadType.Constant) => {
  return new Tensor(addon._pad(input._native_ref, padWidths, type));
};

exports.cumsum = (input, axis) => {
  return new Tensor(addon._cumsum(input._native_ref, axis));
};

exports.countNonzero = (input, axes = [], keepDims = false) => {
  return new Tensor(
    addon._countNonzero(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

exports.concatenate = (tensors, axis = 0) => {
  return new Tensor(addon._concatenate(tensors, axis));
};

exports.absolute = (tensor) => {
  return new Tensor(addon._absolute(tensor._native_ref));
};

exports.sigmoid = (tensor) => {
  return new Tensor(addon._sigmoid(tensor._native_ref));
};

exports.power = (lhs, rhs) => {
  return new Tensor(addon._power(lhs._native_ref, rhs._native_ref));
};

exports._var = (input, axes = [], bias = false, keepDims = false) => {
  return new Tensor(
    addon._var(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      bias,
      keepDims
    )
  );
};

exports.tensorBackendTypeToString = (type) => {
  return addon._tensorBackendTypeToString(type);
};

exports.identity = (dim, type = dtype.f32) => {
  return new Tensor(addon._identity(dim, type));
};

exports.arange = (start, end, step = 1, type) => {
  return new Tensor(addon._arange(start, end, step, type));
};

exports.iota = (dims, tileDims = [1], type = dtype.f32) => {
  return new Tensor(
    addon._iota(
      dims instanceof BigInt64Array
        ? dims
        : new BigInt64Array(dims.map((v) => (typeof v === 'number' ? BigInt(v) : v))),
      tileDims instanceof BigInt64Array
        ? tileDims
        : new BigInt64Array(tileDims.map((v) => (typeof v === 'number' ? BigInt(v) : v))),
      type
    )
  );
};

exports.log1p = (tensor) => {
  return new Tensor(addon._log1p(tensor._native_ref));
};

exports.cos = (tensor) => {
  return new Tensor(addon._cos(tensor._native_ref));
};

exports.sqrt = (tensor) => {
  return new Tensor(addon._sqrt(tensor._native_ref));
};

exports.flip = (tensor, dim) => {
  return new Tensor(addon._flip(tensor._native_ref, dim));
};

exports.reshape = (tensor, shape) => {
  return new Tensor(
    addon._reshape(
      tensor._native_ref,
      shape instanceof BigInt64Array
        ? shape
        : new BigInt64Array(shape.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
    )
  );
};

exports.tile = (tensor, shape) => {
  return new Tensor(
    addon._tile(
      tensor._native_ref,
      shape instanceof BigInt64Array
        ? shape
        : new BigInt64Array(shape.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
    )
  );
};

exports.rint = (tensor) => {
  return new Tensor(addon._rint(tensor._native_ref));
};

exports.roll = (tensor, shift, axis) => {
  return new Tensor(addon._roll(tensor._native_ref, shift, axis));
};

exports.isinf = (tensor) => {
  return new Tensor(addon._isinf(tensor._native_ref));
};

exports.sign = (tensor) => {
  return new Tensor(addon._sign(tensor._native_ref));
};

exports.tril = (tensor) => {
  return new Tensor(addon._tril(tensor._native_ref));
};

exports.where = (condition, x, y) => {
  return new Tensor(addon._where(condition._native_ref, x._native_ref, y._native_ref));
};

exports.exp = (tensor) => {
  return new Tensor(addon._exp(tensor._native_ref));
};

exports.triu = (tensor) => {
  return new Tensor(addon._triu(tensor._native_ref));
};

exports.sort = (input, axis, sortMode = SortMode.Ascending) => {
  return new Tensor(addon._sort(input._native_ref, axis, sortMode));
};

exports.min = (values, indices, input, axis, keepDims = false) => {
  return addon._min(values._native_ref, indices._native_ref, input._native_ref, axis, keepDims);
};

exports.erf = (tensor) => {
  return new Tensor(addon._erf(tensor._native_ref));
};

exports.sum = (input, axes = [], keepDims = false) => {
  return new Tensor(
    addon._sum(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

exports.logicalNot = (tensor) => {
  return new Tensor(addon._logicalNot(tensor._native_ref));
};

exports.maximum = (lhs, rhs) => {
  return new Tensor(addon._maximum(lhs._native_ref, rhs._native_ref));
};

exports.median = (input, axes = [], keepDims = false) => {
  return new Tensor(
    addon._median(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

exports.allClose = (a, b, absTolerance = 1e-5) => {
  return addon._allClose(a._native_ref, b._native_ref, absTolerance);
};

exports.isInvalidArray = (tensor) => {
  return addon._isInvalidArray(tensor._native_ref);
};

exports.areTensorTypesEqual = (a, b) => {
  return addon._areTensorTypesEqual(a._native_ref, b._native_ref);
};

exports.tanh = (tensor) => {
  return new Tensor(addon._tanh(tensor._native_ref));
};

exports.amax = (input, axes = [], keepDims = false) => {
  return new Tensor(
    addon._amax(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

exports.max = (values, indices, input, axis, keepDims = false) => {
  return addon._max(values._native_ref, indices._native_ref, input._native_ref, axis, keepDims);
};

exports.argmin = (input, axis, keepDims = false) => {
  return new Tensor(addon._argmin(input._native_ref, axis, keepDims));
};

exports.logicalOr = (lhs, rhs) => {
  return new Tensor(addon._logicalOr(lhs._native_ref, rhs._native_ref));
};

exports.logicalAnd = (lhs, rhs) => {
  return new Tensor(addon._logicalAnd(lhs._native_ref, rhs._native_ref));
};

exports.bitwiseXor = (lhs, rhs) => {
  return new Tensor(addon._bitwiseXor(lhs._native_ref, rhs._native_ref));
};

exports.div = (lhs, rhs) => {
  return new Tensor(addon._div(lhs._native_ref, rhs._native_ref));
};

exports.lessThan = (lhs, rhs) => {
  return new Tensor(addon._lessThan(lhs._native_ref, rhs._native_ref));
};

exports.bitwiseAnd = (lhs, rhs) => {
  return new Tensor(addon._bitwiseAnd(lhs._native_ref, rhs._native_ref));
};

exports.greaterThan = (lhs, rhs) => {
  return new Tensor(addon._greaterThan(lhs._native_ref, rhs._native_ref));
};

exports.add = (lhs, rhs) => {
  return new Tensor(addon._add(lhs._native_ref, rhs._native_ref));
};

exports.eq = (lhs, rhs) => {
  return new Tensor(addon._eq(lhs._native_ref, rhs._native_ref));
};

exports.mul = (lhs, rhs) => {
  return new Tensor(addon._mul(lhs._native_ref, rhs._native_ref));
};

exports.mod = (lhs, rhs) => {
  return new Tensor(addon._mod(lhs._native_ref, rhs._native_ref));
};

exports.greaterThanEqual = (lhs, rhs) => {
  return new Tensor(addon._greaterThanEqual(lhs._native_ref, rhs._native_ref));
};

exports.lShift = (lhs, rhs) => {
  return new Tensor(addon._lShift(lhs._native_ref, rhs._native_ref));
};

exports.neq = (lhs, rhs) => {
  return new Tensor(addon._neq(lhs._native_ref, rhs._native_ref));
};

exports.rShift = (lhs, rhs) => {
  return new Tensor(addon._rShift(lhs._native_ref, rhs._native_ref));
};

exports.lessThanEqual = (lhs, rhs) => {
  return new Tensor(addon._lessThanEqual(lhs._native_ref, rhs._native_ref));
};

exports.sub = (lhs, rhs) => {
  return new Tensor(addon._sub(lhs._native_ref, rhs._native_ref));
};

exports.bitwiseOr = (lhs, rhs) => {
  return new Tensor(addon._bitwiseOr(lhs._native_ref, rhs._native_ref));
};

exports.copy = (_gen_tmp_external_self) => {
  return new Tensor(addon._copy(_gen_tmp_external_self._native_ref));
};

exports.shape = (_gen_tmp_external_self) => {
  return addon._shape(_gen_tmp_external_self._native_ref);
};

exports.elements = (_gen_tmp_external_self) => {
  return addon._elements(_gen_tmp_external_self._native_ref);
};

exports.dim = (_gen_tmp_external_self, dim) => {
  return addon._dim(_gen_tmp_external_self._native_ref, dim);
};

exports.ndim = (_gen_tmp_external_self) => {
  return addon._ndim(_gen_tmp_external_self._native_ref);
};

exports.isEmpty = (_gen_tmp_external_self) => {
  return addon._isEmpty(_gen_tmp_external_self._native_ref);
};

exports.hasAdapter = (_gen_tmp_external_self) => {
  return addon._hasAdapter(_gen_tmp_external_self._native_ref);
};

exports.bytes = (_gen_tmp_external_self) => {
  return addon._bytes(_gen_tmp_external_self._native_ref);
};

exports.type = (_gen_tmp_external_self) => {
  return addon._type(_gen_tmp_external_self._native_ref);
};

exports.isSparse = (_gen_tmp_external_self) => {
  return addon._isSparse(_gen_tmp_external_self._native_ref);
};

exports.strides = (_gen_tmp_external_self) => {
  return addon._strides(_gen_tmp_external_self._native_ref);
};

exports.astype = (_gen_tmp_external_self, type) => {
  return new Tensor(addon._astype(_gen_tmp_external_self._native_ref, type));
};

exports.flatten = (_gen_tmp_external_self) => {
  return new Tensor(addon._flatten(_gen_tmp_external_self._native_ref));
};

exports.asContiguousTensor = (_gen_tmp_external_self) => {
  return new Tensor(addon._asContiguousTensor(_gen_tmp_external_self._native_ref));
};

exports.backendType = (_gen_tmp_external_self) => {
  return addon._backendType(_gen_tmp_external_self._native_ref);
};

exports.unlock = (_gen_tmp_external_self) => {
  return addon._unlock(_gen_tmp_external_self._native_ref);
};

exports.isLocked = (_gen_tmp_external_self) => {
  return addon._isLocked(_gen_tmp_external_self._native_ref);
};

exports.isContiguous = (_gen_tmp_external_self) => {
  return addon._isContiguous(_gen_tmp_external_self._native_ref);
};

exports.toString = (_gen_tmp_external_self) => {
  return addon._toString(_gen_tmp_external_self._native_ref);
};

exports.toFloat32Array = (tensor) => {
  return addon._toFloat32Array(tensor._native_ref);
};

exports.toFloat64Array = (tensor) => {
  return addon._toFloat64Array(tensor._native_ref);
};

exports.toBoolInt8Array = (tensor) => {
  return addon._toBoolInt8Array(tensor._native_ref);
};

exports.toInt16Array = (tensor) => {
  return addon._toInt16Array(tensor._native_ref);
};

exports.toInt32Array = (tensor) => {
  return addon._toInt32Array(tensor._native_ref);
};

exports.toInt64Array = (tensor) => {
  return addon._toInt64Array(tensor._native_ref);
};

exports.toUint8Array = (tensor) => {
  return addon._toUint8Array(tensor._native_ref);
};

exports.toUint16Array = (tensor) => {
  return addon._toUint16Array(tensor._native_ref);
};

exports.toUint32Array = (tensor) => {
  return addon._toUint32Array(tensor._native_ref);
};

exports.toUint64Array = (tensor) => {
  return addon._toUint64Array(tensor._native_ref);
};

exports.toFloat32Scalar = (tensor) => {
  return addon._toFloat32Scalar(tensor._native_ref);
};

exports.toFloat64Scalar = (tensor) => {
  return addon._toFloat64Scalar(tensor._native_ref);
};

exports.toBoolInt8Scalar = (tensor) => {
  return addon._toBoolInt8Scalar(tensor._native_ref);
};

exports.toInt16Scalar = (tensor) => {
  return addon._toInt16Scalar(tensor._native_ref);
};

exports.toInt32Scalar = (tensor) => {
  return addon._toInt32Scalar(tensor._native_ref);
};

exports.toInt64Scalar = (tensor) => {
  return addon._toInt64Scalar(tensor._native_ref);
};

exports.toUint8Scalar = (tensor) => {
  return addon._toUint8Scalar(tensor._native_ref);
};

exports.toUint16Scalar = (tensor) => {
  return addon._toUint16Scalar(tensor._native_ref);
};

exports.toUint32Scalar = (tensor) => {
  return addon._toUint32Scalar(tensor._native_ref);
};

exports.toUint64Scalar = (tensor) => {
  return addon._toUint64Scalar(tensor._native_ref);
};

exports._eval = (tensor) => {
  return addon._eval(tensor._native_ref);
};

exports.dispose = (tensor) => {
  return addon._dispose(tensor._native_ref);
};

exports.tensorFromFloat32Array = (v) => {
  return addon._tensorFromFloat32Array(v);
};

exports.tensorFromFloat64Array = (v) => {
  return addon._tensorFromFloat64Array(v);
};

exports.tensorFromInt8Array = (v) => {
  return addon._tensorFromInt8Array(v);
};

exports.tensorFromInt16Array = (v) => {
  return addon._tensorFromInt16Array(v);
};

exports.tensorFromInt32Array = (v) => {
  return addon._tensorFromInt32Array(v);
};

exports.tensorFromBigInt64Array = (v) => {
  return addon._tensorFromBigInt64Array(v);
};

exports.tensorFromUint8Array = (v) => {
  return addon._tensorFromUint8Array(v);
};

exports.tensorFromUint16Array = (v) => {
  return addon._tensorFromUint16Array(v);
};

exports.tensorFromUint32Array = (v) => {
  return addon._tensorFromUint32Array(v);
};

exports.tensorFromBigUint64Array = (v) => {
  return addon._tensorFromBigUint64Array(v);
};

exports.save = (tensor, path) => {
  return addon._save(tensor._native_ref, path);
};

exports.init = () => {
  return addon._init();
};

exports.bytesUsed = () => {
  return addon._bytesUsed();
};

exports.setRowMajor = () => {
  return addon._setRowMajor();
};

exports.setColMajor = () => {
  return addon._setColMajor();
};

exports.isRowMajor = () => {
  return addon._isRowMajor();
};

exports.isColMajor = () => {
  return addon._isColMajor();
};

exports.rand = (shape) => {
  return new Tensor(addon._rand(shape));
};

exports.randn = (shape) => {
  return new Tensor(addon._randn(shape));
};
