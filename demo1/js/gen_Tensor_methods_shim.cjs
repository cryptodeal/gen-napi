// Code generated by gen-napi. DO NOT EDIT.
const { dtype, TensorBackendType, SortMode, MatrixProperty, PadType } = require('./gen_enums.cjs');
const addon = require('../../build/Release/shumai_bindings.node');

//////////
// source: TensorBase.h

exports._Base_Tensor = class _Base_Tensor {
  _native_Tensor;

  get _native_ref() {
    return this._native_Tensor;
  }
};

/**
 * USAGE INSTRUCTIONS:
 * 1. Import `gen_Tensor_ops_shim` to file where corresponding js impl lives
 * 2. copy the following logic following class declaration into `demo1/js/tensor.cjs`:
 */
/*
  for (const [method, closure] of Object.entries(gen_Tensor_ops_shim(Tensor))) {
    Tensor.prototype[method] = closure;
  }
*/
exports.gen_Tensor_ops_shim = (_Tensor) => {
  return {
    copy() {
      return new _Tensor(addon._copy(this._native_ref));
    },

    shape() {
      return addon._shape(this._native_ref);
    },

    elements() {
      return addon._elements(this._native_ref);
    },

    dim(dim) {
      return addon._dim(this._native_ref, dim);
    },

    ndim() {
      return addon._ndim(this._native_ref);
    },

    isEmpty() {
      return addon._isEmpty(this._native_ref);
    },

    hasAdapter() {
      return addon._hasAdapter(this._native_ref);
    },

    bytes() {
      return addon._bytes(this._native_ref);
    },

    type() {
      return addon._type(this._native_ref);
    },

    isSparse() {
      return addon._isSparse(this._native_ref);
    },

    strides() {
      return addon._strides(this._native_ref);
    },

    astype(type) {
      return new _Tensor(addon._astype(this._native_ref, type));
    },

    flatten() {
      return new _Tensor(addon._flatten(this._native_ref));
    },

    asContiguousTensor() {
      return new _Tensor(addon._asContiguousTensor(this._native_ref));
    },

    backendType() {
      return addon._backendType(this._native_ref);
    },

    unlock() {
      return addon._unlock(this._native_ref);
    },

    isLocked() {
      return addon._isLocked(this._native_ref);
    },

    isContiguous() {
      return addon._isContiguous(this._native_ref);
    },

    toString() {
      return addon._toString(this._native_ref);
    },

    sub(rhs) {
      return new _Tensor(addon._sub(this._native_ref, rhs._native_ref));
    },

    bitwiseOr(rhs) {
      return new _Tensor(addon._bitwiseOr(this._native_ref, rhs._native_ref));
    },

    neq(rhs) {
      return new _Tensor(addon._neq(this._native_ref, rhs._native_ref));
    },

    rShift(rhs) {
      return new _Tensor(addon._rShift(this._native_ref, rhs._native_ref));
    },

    lessThanEqual(rhs) {
      return new _Tensor(addon._lessThanEqual(this._native_ref, rhs._native_ref));
    },

    div(rhs) {
      return new _Tensor(addon._div(this._native_ref, rhs._native_ref));
    },

    lessThan(rhs) {
      return new _Tensor(addon._lessThan(this._native_ref, rhs._native_ref));
    },

    logicalOr(rhs) {
      return new _Tensor(addon._logicalOr(this._native_ref, rhs._native_ref));
    },

    logicalAnd(rhs) {
      return new _Tensor(addon._logicalAnd(this._native_ref, rhs._native_ref));
    },

    bitwiseXor(rhs) {
      return new _Tensor(addon._bitwiseXor(this._native_ref, rhs._native_ref));
    },

    mul(rhs) {
      return new _Tensor(addon._mul(this._native_ref, rhs._native_ref));
    },

    mod(rhs) {
      return new _Tensor(addon._mod(this._native_ref, rhs._native_ref));
    },

    bitwiseAnd(rhs) {
      return new _Tensor(addon._bitwiseAnd(this._native_ref, rhs._native_ref));
    },

    greaterThan(rhs) {
      return new _Tensor(addon._greaterThan(this._native_ref, rhs._native_ref));
    },

    add(rhs) {
      return new _Tensor(addon._add(this._native_ref, rhs._native_ref));
    },

    eq(rhs) {
      return new _Tensor(addon._eq(this._native_ref, rhs._native_ref));
    },

    greaterThanEqual(rhs) {
      return new _Tensor(addon._greaterThanEqual(this._native_ref, rhs._native_ref));
    },

    lShift(rhs) {
      return new _Tensor(addon._lShift(this._native_ref, rhs._native_ref));
    },

    exp() {
      return new _Tensor(addon._exp(this._native_ref));
    },

    triu() {
      return new _Tensor(addon._triu(this._native_ref));
    },

    sort(axis, sortMode = SortMode.Ascending) {
      return new _Tensor(addon._sort(this._native_ref, axis, sortMode));
    },

    erf() {
      return new _Tensor(addon._erf(this._native_ref));
    },

    sum(axes = [], keepDims = false) {
      return new _Tensor(
        addon._sum(
          this._native_ref,
          axes instanceof Int32Array ? axes : new Int32Array(axes),
          keepDims
        )
      );
    },

    logicalNot() {
      return new _Tensor(addon._logicalNot(this._native_ref));
    },

    maximum(rhs) {
      return new _Tensor(addon._maximum(this._native_ref, rhs._native_ref));
    },

    median(axes = [], keepDims = false) {
      return new _Tensor(
        addon._median(
          this._native_ref,
          axes instanceof Int32Array ? axes : new Int32Array(axes),
          keepDims
        )
      );
    },

    tanh() {
      return new _Tensor(addon._tanh(this._native_ref));
    },

    amax(axes = [], keepDims = false) {
      return new _Tensor(
        addon._amax(
          this._native_ref,
          axes instanceof Int32Array ? axes : new Int32Array(axes),
          keepDims
        )
      );
    },

    argmin(axis, keepDims = false) {
      return new _Tensor(addon._argmin(this._native_ref, axis, keepDims));
    },

    isnan() {
      return new _Tensor(addon._isnan(this._native_ref));
    },

    std(axes = [], keepDims = false) {
      return new _Tensor(
        addon._std(
          this._native_ref,
          axes instanceof Int32Array ? axes : new Int32Array(axes),
          keepDims
        )
      );
    },

    norm(axes = [], p = 2, keepDims = false) {
      return new _Tensor(
        addon._norm(
          this._native_ref,
          axes instanceof Int32Array ? axes : new Int32Array(axes),
          p,
          keepDims
        )
      );
    },

    any(axes = [], keepDims = false) {
      return new _Tensor(
        addon._any(
          this._native_ref,
          axes instanceof Int32Array ? axes : new Int32Array(axes),
          keepDims
        )
      );
    },

    negative() {
      return new _Tensor(addon._negative(this._native_ref));
    },

    sin() {
      return new _Tensor(addon._sin(this._native_ref));
    },

    floor() {
      return new _Tensor(addon._floor(this._native_ref));
    },

    mean(axes = [], keepDims = false) {
      return new _Tensor(
        addon._mean(
          this._native_ref,
          axes instanceof Int32Array ? axes : new Int32Array(axes),
          keepDims
        )
      );
    },

    amin(axes = [], keepDims = false) {
      return new _Tensor(
        addon._amin(
          this._native_ref,
          axes instanceof Int32Array ? axes : new Int32Array(axes),
          keepDims
        )
      );
    },

    transpose(axes = []) {
      return new _Tensor(
        addon._transpose(
          this._native_ref,
          axes instanceof BigInt64Array
            ? axes
            : new BigInt64Array(axes.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
        )
      );
    },

    log() {
      return new _Tensor(addon._log(this._native_ref));
    },

    ceil() {
      return new _Tensor(addon._ceil(this._native_ref));
    },

    clip(low, high) {
      return new _Tensor(addon._clip(this._native_ref, low._native_ref, high._native_ref));
    },

    minimum(rhs) {
      return new _Tensor(addon._minimum(this._native_ref, rhs._native_ref));
    },

    matmul(rhs, lhsProp = MatrixProperty.None, rhsProp = MatrixProperty.None) {
      return new _Tensor(addon._matmul(this._native_ref, rhs._native_ref, lhsProp, rhsProp));
    },

    nonzero() {
      return new _Tensor(addon._nonzero(this._native_ref));
    },

    argsort(axis, sortMode = SortMode.Ascending) {
      return new _Tensor(addon._argsort(this._native_ref, axis, sortMode));
    },

    argmax(axis, keepDims = false) {
      return new _Tensor(addon._argmax(this._native_ref, axis, keepDims));
    },

    all(axes = [], keepDims = false) {
      return new _Tensor(
        addon._all(
          this._native_ref,
          axes instanceof Int32Array ? axes : new Int32Array(axes),
          keepDims
        )
      );
    },

    pad(padWidths, type = PadType.Constant) {
      return new _Tensor(addon._pad(this._native_ref, padWidths, type));
    },

    cumsum(axis) {
      return new _Tensor(addon._cumsum(this._native_ref, axis));
    },

    countNonzero(axes = [], keepDims = false) {
      return new _Tensor(
        addon._countNonzero(
          this._native_ref,
          axes instanceof Int32Array ? axes : new Int32Array(axes),
          keepDims
        )
      );
    },

    absolute() {
      return new _Tensor(addon._absolute(this._native_ref));
    },

    sigmoid() {
      return new _Tensor(addon._sigmoid(this._native_ref));
    },

    power(rhs) {
      return new _Tensor(addon._power(this._native_ref, rhs._native_ref));
    },

    var(axes = [], bias = false, keepDims = false) {
      return new _Tensor(
        addon._var(
          this._native_ref,
          axes instanceof Int32Array ? axes : new Int32Array(axes),
          bias,
          keepDims
        )
      );
    },

    flip(dim) {
      return new _Tensor(addon._flip(this._native_ref, dim));
    },

    log1p() {
      return new _Tensor(addon._log1p(this._native_ref));
    },

    cos() {
      return new _Tensor(addon._cos(this._native_ref));
    },

    sqrt() {
      return new _Tensor(addon._sqrt(this._native_ref));
    },

    reshape(shape) {
      return new _Tensor(
        addon._reshape(
          this._native_ref,
          shape instanceof BigInt64Array
            ? shape
            : new BigInt64Array(shape.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
        )
      );
    },

    tile(shape) {
      return new _Tensor(
        addon._tile(
          this._native_ref,
          shape instanceof BigInt64Array
            ? shape
            : new BigInt64Array(shape.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
        )
      );
    },

    rint() {
      return new _Tensor(addon._rint(this._native_ref));
    },

    roll(shift, axis) {
      return new _Tensor(addon._roll(this._native_ref, shift, axis));
    },

    isinf() {
      return new _Tensor(addon._isinf(this._native_ref));
    },

    sign() {
      return new _Tensor(addon._sign(this._native_ref));
    },

    tril() {
      return new _Tensor(addon._tril(this._native_ref));
    },

    where(x, y) {
      return new _Tensor(addon._where(this._native_ref, x._native_ref, y._native_ref));
    },

    toFloat32Array() {
      return addon._toFloat32Array(this._native_ref);
    },

    toFloat64Array() {
      return addon._toFloat64Array(this._native_ref);
    },

    toBoolInt8Array() {
      return addon._toBoolInt8Array(this._native_ref);
    },

    toInt16Array() {
      return addon._toInt16Array(this._native_ref);
    },

    toInt32Array() {
      return addon._toInt32Array(this._native_ref);
    },

    toInt64Array() {
      return addon._toInt64Array(this._native_ref);
    },

    toUint8Array() {
      return addon._toUint8Array(this._native_ref);
    },

    toUint16Array() {
      return addon._toUint16Array(this._native_ref);
    },

    toUint32Array() {
      return addon._toUint32Array(this._native_ref);
    },

    toUint64Array() {
      return addon._toUint64Array(this._native_ref);
    },

    toFloat32Scalar() {
      return addon._toFloat32Scalar(this._native_ref);
    },

    toFloat64Scalar() {
      return addon._toFloat64Scalar(this._native_ref);
    },

    toBoolInt8Scalar() {
      return addon._toBoolInt8Scalar(this._native_ref);
    },

    toInt16Scalar() {
      return addon._toInt16Scalar(this._native_ref);
    },

    toInt32Scalar() {
      return addon._toInt32Scalar(this._native_ref);
    },

    toInt64Scalar() {
      return addon._toInt64Scalar(this._native_ref);
    },

    toUint8Scalar() {
      return addon._toUint8Scalar(this._native_ref);
    },

    toUint16Scalar() {
      return addon._toUint16Scalar(this._native_ref);
    },

    toUint32Scalar() {
      return addon._toUint32Scalar(this._native_ref);
    },

    toUint64Scalar() {
      return addon._toUint64Scalar(this._native_ref);
    },

    eval() {
      return addon._eval(this._native_ref);
    },

    dispose() {
      return addon._dispose(this._native_ref);
    },

    tensorFromFloat32Array(v) {
      return addon._tensorFromFloat32Array(v instanceof Float32Array ? v : new Float32Array(v));
    },

    tensorFromFloat64Array(v) {
      return addon._tensorFromFloat64Array(v instanceof Float64Array ? v : new Float64Array(v));
    },

    tensorFromInt8Array(v) {
      return addon._tensorFromInt8Array(v instanceof Int8Array ? v : new Int8Array(v));
    },

    tensorFromInt16Array(v) {
      return addon._tensorFromInt16Array(v instanceof Int16Array ? v : new Int16Array(v));
    },

    tensorFromInt32Array(v) {
      return addon._tensorFromInt32Array(v instanceof Int32Array ? v : new Int32Array(v));
    },

    tensorFromBigInt64Array(v) {
      return addon._tensorFromBigInt64Array(
        v instanceof BigInt64Array
          ? v
          : new BigInt64Array(v.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
      );
    },

    tensorFromUint8Array(v) {
      return addon._tensorFromUint8Array(v instanceof Uint8Array ? v : new Uint8Array(v));
    },

    tensorFromUint16Array(v) {
      return addon._tensorFromUint16Array(v instanceof Uint16Array ? v : new Uint16Array(v));
    },

    tensorFromUint32Array(v) {
      return addon._tensorFromUint32Array(v instanceof Uint32Array ? v : new Uint32Array(v));
    },

    tensorFromBigUint64Array(v) {
      return addon._tensorFromBigUint64Array(
        v instanceof BigUint64Array
          ? v
          : new BigUint64Array(v.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
      );
    },

    save(path) {
      return addon._save(this._native_ref, path);
    }
  };
};
