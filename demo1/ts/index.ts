// Code generated by gen-napi. DO NOT EDIT.
/* eslint-disable */
import { Tensor } from './tensor'
const {
	_copy,
	_shape,
	_elements,
	_dim,
	_ndim,
	_isEmpty,
	_hasAdapter,
	_bytes,
	_type,
	_isSparse,
	_strides,
	_astype,
	_flatten,
	_flat,
	_asContiguousTensor,
	_backendType,
	_unlock,
	_isLocked,
	_isContiguous,
	_toString,
	_toFloat32Array,
	_toFloat64Array,
	_toBoolInt8Array,
	_toInt16Array,
	_toInt32Array,
	_toInt64Array,
	_toUint8Array,
	_toUint16Array,
	_toUint32Array,
	_toUint64Array,
	_toFloat32Scalar,
	_toFloat64Scalar,
	_toBoolInt8Scalar,
	_toInt16Scalar,
	_toInt32Scalar,
	_toInt64Scalar,
	_toUint8Scalar,
	_toUint16Scalar,
	_toUint32Scalar,
	_toUint64Scalar,
	_eval: __eval,
	_dispose,
	_tensorFromFloat32Buffer,
	_tensorFromFloat64Buffer,
	_tensorFromBoolInt8Buffer,
	_tensorFromInt16Buffer,
	_tensorFromInt32Buffer,
	_tensorFromInt64Buffer,
	_tensorFromUint8Buffer,
	_tensorFromUint16Buffer,
	_tensorFromUint32Buffer,
	_tensorFromUint64Buffer,
	_save,
	_concatenate,
	_exp,
	_flip,
	_argsort,
	_areTensorTypesEqual,
	_where,
	_sum,
	_reshape,
	_argmax,
	_log1p,
	_floor,
	_isinf,
	_tile,
	_pad,
	_sin,
	_tensorBackendTypeToString,
	_full,
	_cos,
	_std,
	_norm,
	_countNonzero,
	_power,
	_amax,
	_median,
	_var: __var,
	_roll,
	_amin,
	_minimum,
	_any,
	_matmul,
	_max,
	_identity,
	_iota,
	_log,
	_isnan,
	_tril,
	_triu,
	_transpose,
	_nonzero,
	_logicalNot,
	_sigmoid,
	_clip,
	_sign,
	_arange,
	_negative,
	_tanh,
	_ceil,
	_rint,
	_erf,
	_argmin,
	_mean,
	_all,
	_absolute,
	_isInvalidArray,
	_sqrt,
	_sort,
	_maximum,
	_min,
	_cumsum,
	_allClose,
	_add,
	_eq,
	_neq,
	_bitwiseXor,
	_lShift,
	_bitwiseOr,
	_mod,
	_sub,
	_div,
	_greaterThanEqual,
	_lessThan,
	_logicalOr,
	_mul,
	_lessThanEqual,
	_greaterThan,
	_logicalAnd,
	_bitwiseAnd,
	_rShift,
	_init,
	_bytesUsed,
	_setRowMajor,
	_setColMajor,
	_isRowMajor,
	_isColMajor,
	_rand,
	_randn
} = import.meta.require("../../build/Release/shumai_bindings.node")

export enum TensorBackendType {
	Stub = 0,
	Tracer = 1,
	ArrayFire = 2,
	OneDnn = 3,
	Jit = 4
}

export enum Location {
	Host = 0,
	Device = 1
}

export enum StorageType {
	Dense = 0,
	CSR = 1,
	CSC = 2,
	COO = 3
}

export enum PadType {
	Constant = 0,
	Edge = 1,
	Symmetric = 2
}

export enum SortMode {
	Descending = 0,
	Ascending = 1
}

export enum MatrixProperty {
	None = 0,
	Transpose = 1
}

export enum dtype {
	f16 = 0,
	f32 = 1,
	f64 = 2,
	b8 = 3,
	s16 = 4,
	s32 = 5,
	s64 = 6,
	u8 = 7,
	u16 = 8,
	u32 = 9,
	u64 = 10
}

export const power = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _power(lhs, rhs);
}

export const amax = (input: Tensor, axes: number[] | Int32Array = [], keepDims: boolean = false): Tensor => {
	return _amax(input, axes instanceof Int32Array ? axes : new Int32Array(axes), keepDims);
}

export const median = (input: Tensor, axes: number[] | Int32Array = [], keepDims: boolean = false): Tensor => {
	return _median(input, axes instanceof Int32Array ? axes : new Int32Array(axes), keepDims);
}

export const _var = (input: Tensor, axes: number[] | Int32Array = [], bias: boolean = false, keepDims: boolean = false): Tensor => {
	return __var(input, axes instanceof Int32Array ? axes : new Int32Array(axes), bias, keepDims);
}

export const roll = (tensor: Tensor, shift: number, axis: number): Tensor => {
	return _roll(tensor, shift, axis);
}

export const amin = (input: Tensor, axes: number[] | Int32Array = [], keepDims: boolean = false): Tensor => {
	return _amin(input, axes instanceof Int32Array ? axes : new Int32Array(axes), keepDims);
}

export const minimum = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _minimum(lhs, rhs);
}

export const any = (input: Tensor, axes: number[] | Int32Array = [], keepDims: boolean = false): Tensor => {
	return _any(input, axes instanceof Int32Array ? axes : new Int32Array(axes), keepDims);
}

export const matmul = (lhs: Tensor, rhs: Tensor, lhsProp: MatrixProperty = MatrixProperty.None, rhsProp: MatrixProperty = MatrixProperty.None): Tensor => {
	return _matmul(lhs, rhs, lhsProp, rhsProp);
}

export const max = (values: Tensor, indices: Tensor, input: Tensor, axis: number, keepDims: boolean = false) => {
	return _max(values, indices, input, axis, keepDims);
}

export const identity = (dim: bigint, type: dtype = dtype.f32): Tensor => {
	return _identity(dim, type);
}

export const iota = (dims: Array<number | bigint> | BigInt64Array, tileDims: Array<number | bigint> | BigInt64Array = [1], type: dtype = dtype.f32): Tensor => {
	return _iota(dims instanceof BigInt64Array ? dims : new BigInt64Array(dims.map((v) => typeof v === 'number' ? BigInt(v) : v)), tileDims instanceof BigInt64Array ? tileDims : new BigInt64Array(tileDims.map((v) => typeof v === 'number' ? BigInt(v) : v)), type);
}

export const log = (tensor: Tensor): Tensor => {
	return _log(tensor);
}

export const isnan = (tensor: Tensor): Tensor => {
	return _isnan(tensor);
}

export const tril = (tensor: Tensor): Tensor => {
	return _tril(tensor);
}

export const triu = (tensor: Tensor): Tensor => {
	return _triu(tensor);
}

export const transpose = (tensor: Tensor, axes: Array<number | bigint> | BigInt64Array = []): Tensor => {
	return _transpose(tensor, axes instanceof BigInt64Array ? axes : new BigInt64Array(axes.map((v) => typeof v === 'number' ? BigInt(v) : v)));
}

export const nonzero = (tensor: Tensor): Tensor => {
	return _nonzero(tensor);
}

export const logicalNot = (tensor: Tensor): Tensor => {
	return _logicalNot(tensor);
}

export const sigmoid = (tensor: Tensor): Tensor => {
	return _sigmoid(tensor);
}

export const clip = (tensor: Tensor, low: Tensor, high: Tensor): Tensor => {
	return _clip(tensor, low, high);
}

export const sign = (tensor: Tensor): Tensor => {
	return _sign(tensor);
}

export const arange = (start: number, end: number, step: number = 1, type: dtype): Tensor => {
	return _arange(start, end, step, type);
}

export const negative = (tensor: Tensor): Tensor => {
	return _negative(tensor);
}

export const tanh = (tensor: Tensor): Tensor => {
	return _tanh(tensor);
}

export const ceil = (tensor: Tensor): Tensor => {
	return _ceil(tensor);
}

export const rint = (tensor: Tensor): Tensor => {
	return _rint(tensor);
}

export const erf = (tensor: Tensor): Tensor => {
	return _erf(tensor);
}

export const argmin = (input: Tensor, axis: number, keepDims: boolean = false): Tensor => {
	return _argmin(input, axis, keepDims);
}

export const mean = (input: Tensor, axes: number[] | Int32Array = [], keepDims: boolean = false): Tensor => {
	return _mean(input, axes instanceof Int32Array ? axes : new Int32Array(axes), keepDims);
}

export const all = (input: Tensor, axes: number[] | Int32Array = [], keepDims: boolean = false): Tensor => {
	return _all(input, axes instanceof Int32Array ? axes : new Int32Array(axes), keepDims);
}

export const absolute = (tensor: Tensor): Tensor => {
	return _absolute(tensor);
}

export const isInvalidArray = (tensor: Tensor): boolean => {
	return _isInvalidArray(tensor);
}

export const sqrt = (tensor: Tensor): Tensor => {
	return _sqrt(tensor);
}

export const sort = (input: Tensor, axis: bigint, sortMode: SortMode = SortMode.Ascending): Tensor => {
	return _sort(input, axis, sortMode);
}

export const maximum = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _maximum(lhs, rhs);
}

export const min = (values: Tensor, indices: Tensor, input: Tensor, axis: number, keepDims: boolean = false) => {
	return _min(values, indices, input, axis, keepDims);
}

export const cumsum = (input: Tensor, axis: number): Tensor => {
	return _cumsum(input, axis);
}

export const allClose = (a: Tensor, b: Tensor, absTolerance: number = 1e-5): boolean => {
	return _allClose(a, b, absTolerance);
}

export const concatenate = (tensors: Array<Tensor>, axis: number = 0): Tensor => {
	return _concatenate(tensors, axis);
}

export const exp = (tensor: Tensor): Tensor => {
	return _exp(tensor);
}

export const flip = (tensor: Tensor, dim: number): Tensor => {
	return _flip(tensor, dim);
}

export const argsort = (input: Tensor, axis: bigint, sortMode: SortMode = SortMode.Ascending): Tensor => {
	return _argsort(input, axis, sortMode);
}

export const areTensorTypesEqual = (a: Tensor, b: Tensor): boolean => {
	return _areTensorTypesEqual(a, b);
}

export const where = (condition: Tensor, x: Tensor, y: Tensor): Tensor => {
	return _where(condition, x, y);
}

export const sum = (input: Tensor, axes: number[] | Int32Array = [], keepDims: boolean = false): Tensor => {
	return _sum(input, axes instanceof Int32Array ? axes : new Int32Array(axes), keepDims);
}

export const reshape = (tensor: Tensor, shape: Array<number | bigint> | BigInt64Array): Tensor => {
	return _reshape(tensor, shape instanceof BigInt64Array ? shape : new BigInt64Array(shape.map((v) => typeof v === 'number' ? BigInt(v) : v)));
}

export const argmax = (input: Tensor, axis: number, keepDims: boolean = false): Tensor => {
	return _argmax(input, axis, keepDims);
}

export const log1p = (tensor: Tensor): Tensor => {
	return _log1p(tensor);
}

export const floor = (tensor: Tensor): Tensor => {
	return _floor(tensor);
}

export const isinf = (tensor: Tensor): Tensor => {
	return _isinf(tensor);
}

export const tile = (tensor: Tensor, shape: Array<number | bigint> | BigInt64Array): Tensor => {
	return _tile(tensor, shape instanceof BigInt64Array ? shape : new BigInt64Array(shape.map((v) => typeof v === 'number' ? BigInt(v) : v)));
}

export const pad = (input: Tensor, padWidths: Array<[number, number]>, type: PadType = PadType.Constant): Tensor => {
	return _pad(input, padWidths, type);
}

export const sin = (tensor: Tensor): Tensor => {
	return _sin(tensor);
}

export const tensorBackendTypeToString = (type: TensorBackendType): string => {
	return _tensorBackendTypeToString(type);
}

export const full = (dims: Array<number | bigint> | BigInt64Array, val: number, type: dtype): Tensor => {
	return _full(dims instanceof BigInt64Array ? dims : new BigInt64Array(dims.map((v) => typeof v === 'number' ? BigInt(v) : v)), val, type);
}

export const cos = (tensor: Tensor): Tensor => {
	return _cos(tensor);
}

export const std = (input: Tensor, axes: number[] | Int32Array = [], keepDims: boolean = false): Tensor => {
	return _std(input, axes instanceof Int32Array ? axes : new Int32Array(axes), keepDims);
}

export const norm = (input: Tensor, axes: number[] | Int32Array = [], p: number = 2, keepDims: boolean = false): Tensor => {
	return _norm(input, axes instanceof Int32Array ? axes : new Int32Array(axes), p, keepDims);
}

export const countNonzero = (input: Tensor, axes: number[] | Int32Array = [], keepDims: boolean = false): Tensor => {
	return _countNonzero(input, axes instanceof Int32Array ? axes : new Int32Array(axes), keepDims);
}

export const copy = (_gen_tmp_external_self: Tensor): Tensor => {
	return _copy(_gen_tmp_external_self);
}

export const shape = (_gen_tmp_external_self: Tensor): BigInt64Array => {
	return _shape(_gen_tmp_external_self);
}

export const elements = (_gen_tmp_external_self: Tensor): bigint => {
	return _elements(_gen_tmp_external_self);
}

export const dim = (_gen_tmp_external_self: Tensor, dim: bigint): bigint => {
	return _dim(_gen_tmp_external_self, dim);
}

export const ndim = (_gen_tmp_external_self: Tensor): number => {
	return _ndim(_gen_tmp_external_self);
}

export const isEmpty = (_gen_tmp_external_self: Tensor): boolean => {
	return _isEmpty(_gen_tmp_external_self);
}

export const hasAdapter = (_gen_tmp_external_self: Tensor): boolean => {
	return _hasAdapter(_gen_tmp_external_self);
}

export const bytes = (_gen_tmp_external_self: Tensor): bigint => {
	return _bytes(_gen_tmp_external_self);
}

export const type = (_gen_tmp_external_self: Tensor): dtype => {
	return _type(_gen_tmp_external_self);
}

export const isSparse = (_gen_tmp_external_self: Tensor): boolean => {
	return _isSparse(_gen_tmp_external_self);
}

export const strides = (_gen_tmp_external_self: Tensor): BigInt64Array => {
	return _strides(_gen_tmp_external_self);
}

export const astype = (_gen_tmp_external_self: Tensor, type: dtype): Tensor => {
	return _astype(_gen_tmp_external_self, type);
}

export const flatten = (_gen_tmp_external_self: Tensor): Tensor => {
	return _flatten(_gen_tmp_external_self);
}

export const flat = (_gen_tmp_external_self: Tensor, idx: Index): Tensor => {
	return _flat(_gen_tmp_external_self, idx);
}

export const asContiguousTensor = (_gen_tmp_external_self: Tensor): Tensor => {
	return _asContiguousTensor(_gen_tmp_external_self);
}

export const backendType = (_gen_tmp_external_self: Tensor): TensorBackendType => {
	return _backendType(_gen_tmp_external_self);
}

export const unlock = (_gen_tmp_external_self: Tensor) => {
	return _unlock(_gen_tmp_external_self);
}

export const isLocked = (_gen_tmp_external_self: Tensor): boolean => {
	return _isLocked(_gen_tmp_external_self);
}

export const isContiguous = (_gen_tmp_external_self: Tensor): boolean => {
	return _isContiguous(_gen_tmp_external_self);
}

export const toString = (_gen_tmp_external_self: Tensor): string => {
	return _toString(_gen_tmp_external_self);
}

export const toFloat32Array = (tensor: Tensor): Float32Array => {
	return _toFloat32Array(tensor._native_self);
}

export const toFloat64Array = (tensor: Tensor): Float64Array => {
	return _toFloat64Array(tensor._native_self);
}

export const toBoolInt8Array = (tensor: Tensor): Int8Array => {
	return _toBoolInt8Array(tensor._native_self);
}

export const toInt16Array = (tensor: Tensor): Int16Array => {
	return _toInt16Array(tensor._native_self);
}

export const toInt32Array = (tensor: Tensor): Int32Array => {
	return _toInt32Array(tensor._native_self);
}

export const toInt64Array = (tensor: Tensor): BigInt64Array => {
	return _toInt64Array(tensor._native_self);
}

export const toUint8Array = (tensor: Tensor): Uint8Array => {
	return _toUint8Array(tensor._native_self);
}

export const toUint16Array = (tensor: Tensor): Uint16Array => {
	return _toUint16Array(tensor._native_self);
}

export const toUint32Array = (tensor: Tensor): Uint32Array => {
	return _toUint32Array(tensor._native_self);
}

export const toUint64Array = (tensor: Tensor): BigUint64Array => {
	return _toUint64Array(tensor._native_self);
}

export const toFloat32Scalar = (tensor: Tensor): number => {
	return _toFloat32Scalar(tensor._native_self);
}

export const toFloat64Scalar = (tensor: Tensor): number => {
	return _toFloat64Scalar(tensor._native_self);
}

export const toBoolInt8Scalar = (tensor: Tensor): number => {
	return _toBoolInt8Scalar(tensor._native_self);
}

export const toInt16Scalar = (tensor: Tensor): number => {
	return _toInt16Scalar(tensor._native_self);
}

export const toInt32Scalar = (tensor: Tensor): number => {
	return _toInt32Scalar(tensor._native_self);
}

export const toInt64Scalar = (tensor: Tensor): bigint => {
	return _toInt64Scalar(tensor._native_self);
}

export const toUint8Scalar = (tensor: Tensor): number => {
	return _toUint8Scalar(tensor._native_self);
}

export const toUint16Scalar = (tensor: Tensor): number => {
	return _toUint16Scalar(tensor._native_self);
}

export const toUint32Scalar = (tensor: Tensor): number => {
	return _toUint32Scalar(tensor._native_self);
}

export const toUint64Scalar = (tensor: Tensor): bigint => {
	return _toUint64Scalar(tensor._native_self);
}

export const _eval = (tensor: Tensor): void => {
	return __eval(tensor._native_self);
}

export const dispose = (tensor: Tensor): void => {
	return _dispose(tensor._native_self);
}

export const tensorFromFloat32Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromFloat32Buffer(buffer);
}

export const tensorFromFloat64Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromFloat64Buffer(buffer);
}

export const tensorFromBoolInt8Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromBoolInt8Buffer(buffer);
}

export const tensorFromInt16Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromInt16Buffer(buffer);
}

export const tensorFromInt32Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromInt32Buffer(buffer);
}

export const tensorFromInt64Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromInt64Buffer(buffer);
}

export const tensorFromUint8Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromUint8Buffer(buffer);
}

export const tensorFromUint16Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromUint16Buffer(buffer);
}

export const tensorFromUint32Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromUint32Buffer(buffer);
}

export const tensorFromUint64Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromUint64Buffer(buffer);
}

export const save = (tensor: Tensor, path: string): void => {
	return _save(tensor._native_self, path);
}

export const add = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _add(lhs, rhs);
}

export const eq = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _eq(lhs, rhs);
}

export const neq = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _neq(lhs, rhs);
}

export const bitwiseXor = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _bitwiseXor(lhs, rhs);
}

export const lShift = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _lShift(lhs, rhs);
}

export const bitwiseOr = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _bitwiseOr(lhs, rhs);
}

export const mod = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _mod(lhs, rhs);
}

export const sub = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _sub(lhs, rhs);
}

export const div = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _div(lhs, rhs);
}

export const greaterThanEqual = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _greaterThanEqual(lhs, rhs);
}

export const lessThan = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _lessThan(lhs, rhs);
}

export const logicalOr = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _logicalOr(lhs, rhs);
}

export const mul = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _mul(lhs, rhs);
}

export const lessThanEqual = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _lessThanEqual(lhs, rhs);
}

export const greaterThan = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _greaterThan(lhs, rhs);
}

export const logicalAnd = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _logicalAnd(lhs, rhs);
}

export const bitwiseAnd = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _bitwiseAnd(lhs, rhs);
}

export const rShift = (lhs: Tensor, rhs: Tensor): Tensor => {
	return _rShift(lhs, rhs);
}

export const init = (): void => {
	return _init();
}

export const bytesUsed = (): bigint => {
	return _bytesUsed();
}

export const setRowMajor = (): void => {
	return _setRowMajor();
}

export const setColMajor = (): void => {
	return _setColMajor();
}

export const isRowMajor = (): boolean => {
	return _isRowMajor();
}

export const isColMajor = (): boolean => {
	return _isColMajor();
}

export const rand = (shape: BigInt64Array): Tensor => {
	return new Tensor(_rand(shape.buffer));
}

export const randn = (shape: BigInt64Array): Tensor => {
	return new Tensor(_randn(shape.buffer));
}

