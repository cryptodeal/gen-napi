// Code generated by gen-napi. DO NOT EDIT.
import { dtype, MatrixProperty, PadType, SortMode, TensorBackendType } from './gen_enums';
import { Tensor } from './tensor';
const addon = import.meta.require('../../build/Release/shumai_bindings.node');

export const concatenate = (tensors: Array<Tensor>, axis = 0): Tensor => {
  return new Tensor(addon._concatenate(tensors, axis));
};

export const floor = (tensor: Tensor): Tensor => {
  return new Tensor(addon._floor(tensor._native_ref));
};

export const power = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._power(lhs._native_ref, rhs._native_ref));
};

export const amax = (input: Tensor, axes: number[] | Int32Array = [], keepDims = false): Tensor => {
  return new Tensor(
    addon._amax(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

export const std = (input: Tensor, axes: number[] | Int32Array = [], keepDims = false): Tensor => {
  return new Tensor(
    addon._std(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

export const sigmoid = (tensor: Tensor): Tensor => {
  return new Tensor(addon._sigmoid(tensor._native_ref));
};

export const where = (condition: Tensor, x: Tensor, y: Tensor): Tensor => {
  return new Tensor(addon._where(condition._native_ref, x._native_ref, y._native_ref));
};

export const roll = (tensor: Tensor, shift: number, axis: number): Tensor => {
  return new Tensor(addon._roll(tensor._native_ref, shift, axis));
};

export const min = (
  values: Tensor,
  indices: Tensor,
  input: Tensor,
  axis: number,
  keepDims = false
) => {
  return addon._min(values._native_ref, indices._native_ref, input._native_ref, axis, keepDims);
};

export const countNonzero = (
  input: Tensor,
  axes: number[] | Int32Array = [],
  keepDims = false
): Tensor => {
  return new Tensor(
    addon._countNonzero(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

export const tensorBackendTypeToString = (type: TensorBackendType): string => {
  return addon._tensorBackendTypeToString(type);
};

export const logicalNot = (tensor: Tensor): Tensor => {
  return new Tensor(addon._logicalNot(tensor._native_ref));
};

export const sort = (
  input: Tensor,
  axis: bigint,
  sortMode: SortMode = SortMode.Ascending
): Tensor => {
  return new Tensor(addon._sort(input._native_ref, axis, sortMode));
};

export const argsort = (
  input: Tensor,
  axis: bigint,
  sortMode: SortMode = SortMode.Ascending
): Tensor => {
  return new Tensor(addon._argsort(input._native_ref, axis, sortMode));
};

export const minimum = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._minimum(lhs._native_ref, rhs._native_ref));
};

export const all = (input: Tensor, axes: number[] | Int32Array = [], keepDims = false): Tensor => {
  return new Tensor(
    addon._all(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

export const arange = (start: number, end: number, step = 1, type: dtype): Tensor => {
  return new Tensor(addon._arange(start, end, step, type));
};

export const transpose = (
  tensor: Tensor,
  axes: Array<number | bigint> | BigInt64Array = []
): Tensor => {
  return new Tensor(
    addon._transpose(
      tensor._native_ref,
      axes instanceof BigInt64Array
        ? axes
        : new BigInt64Array(axes.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
    )
  );
};

export const erf = (tensor: Tensor): Tensor => {
  return new Tensor(addon._erf(tensor._native_ref));
};

export const allClose = (a: Tensor, b: Tensor, absTolerance = 1e-5): boolean => {
  return addon._allClose(a._native_ref, b._native_ref, absTolerance);
};

export const sqrt = (tensor: Tensor): Tensor => {
  return new Tensor(addon._sqrt(tensor._native_ref));
};

export const tanh = (tensor: Tensor): Tensor => {
  return new Tensor(addon._tanh(tensor._native_ref));
};

export const _var = (
  input: Tensor,
  axes: number[] | Int32Array = [],
  bias = false,
  keepDims = false
): Tensor => {
  return new Tensor(
    addon._var(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      bias,
      keepDims
    )
  );
};

export const norm = (
  input: Tensor,
  axes: number[] | Int32Array = [],
  p = 2,
  keepDims = false
): Tensor => {
  return new Tensor(
    addon._norm(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      p,
      keepDims
    )
  );
};

export const full = (
  dims: Array<number | bigint> | BigInt64Array,
  val: number,
  type: dtype
): Tensor => {
  return new Tensor(
    addon._full(
      dims instanceof BigInt64Array
        ? dims
        : new BigInt64Array(dims.map((v) => (typeof v === 'number' ? BigInt(v) : v))),
      val,
      type
    )
  );
};

export const log1p = (tensor: Tensor): Tensor => {
  return new Tensor(addon._log1p(tensor._native_ref));
};

export const isinf = (tensor: Tensor): Tensor => {
  return new Tensor(addon._isinf(tensor._native_ref));
};

export const sign = (tensor: Tensor): Tensor => {
  return new Tensor(addon._sign(tensor._native_ref));
};

export const any = (input: Tensor, axes: number[] | Int32Array = [], keepDims = false): Tensor => {
  return new Tensor(
    addon._any(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

export const areTensorTypesEqual = (a: Tensor, b: Tensor): boolean => {
  return addon._areTensorTypesEqual(a._native_ref, b._native_ref);
};

export const tril = (tensor: Tensor): Tensor => {
  return new Tensor(addon._tril(tensor._native_ref));
};

export const mean = (input: Tensor, axes: number[] | Int32Array = [], keepDims = false): Tensor => {
  return new Tensor(
    addon._mean(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

export const median = (
  input: Tensor,
  axes: number[] | Int32Array = [],
  keepDims = false
): Tensor => {
  return new Tensor(
    addon._median(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

export const reshape = (tensor: Tensor, shape: Array<number | bigint> | BigInt64Array): Tensor => {
  return new Tensor(
    addon._reshape(
      tensor._native_ref,
      shape instanceof BigInt64Array
        ? shape
        : new BigInt64Array(shape.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
    )
  );
};

export const negative = (tensor: Tensor): Tensor => {
  return new Tensor(addon._negative(tensor._native_ref));
};

export const exp = (tensor: Tensor): Tensor => {
  return new Tensor(addon._exp(tensor._native_ref));
};

export const absolute = (tensor: Tensor): Tensor => {
  return new Tensor(addon._absolute(tensor._native_ref));
};

export const triu = (tensor: Tensor): Tensor => {
  return new Tensor(addon._triu(tensor._native_ref));
};

export const argmax = (input: Tensor, axis: number, keepDims = false): Tensor => {
  return new Tensor(addon._argmax(input._native_ref, axis, keepDims));
};

export const nonzero = (tensor: Tensor): Tensor => {
  return new Tensor(addon._nonzero(tensor._native_ref));
};

export const sin = (tensor: Tensor): Tensor => {
  return new Tensor(addon._sin(tensor._native_ref));
};

export const maximum = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._maximum(lhs._native_ref, rhs._native_ref));
};

export const amin = (input: Tensor, axes: number[] | Int32Array = [], keepDims = false): Tensor => {
  return new Tensor(
    addon._amin(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

export const max = (
  values: Tensor,
  indices: Tensor,
  input: Tensor,
  axis: number,
  keepDims = false
) => {
  return addon._max(values._native_ref, indices._native_ref, input._native_ref, axis, keepDims);
};

export const sum = (input: Tensor, axes: number[] | Int32Array = [], keepDims = false): Tensor => {
  return new Tensor(
    addon._sum(
      input._native_ref,
      axes instanceof Int32Array ? axes : new Int32Array(axes),
      keepDims
    )
  );
};

export const iota = (
  dims: Array<number | bigint> | BigInt64Array,
  tileDims: Array<number | bigint> | BigInt64Array = [1],
  type: dtype = dtype.f32
): Tensor => {
  return new Tensor(
    addon._iota(
      dims instanceof BigInt64Array
        ? dims
        : new BigInt64Array(dims.map((v) => (typeof v === 'number' ? BigInt(v) : v))),
      tileDims instanceof BigInt64Array
        ? tileDims
        : new BigInt64Array(tileDims.map((v) => (typeof v === 'number' ? BigInt(v) : v))),
      type
    )
  );
};

export const tile = (tensor: Tensor, shape: Array<number | bigint> | BigInt64Array): Tensor => {
  return new Tensor(
    addon._tile(
      tensor._native_ref,
      shape instanceof BigInt64Array
        ? shape
        : new BigInt64Array(shape.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
    )
  );
};

export const pad = (
  input: Tensor,
  padWidths: Array<[number, number]>,
  type: PadType = PadType.Constant
): Tensor => {
  return new Tensor(addon._pad(input._native_ref, padWidths, type));
};

export const log = (tensor: Tensor): Tensor => {
  return new Tensor(addon._log(tensor._native_ref));
};

export const ceil = (tensor: Tensor): Tensor => {
  return new Tensor(addon._ceil(tensor._native_ref));
};

export const rint = (tensor: Tensor): Tensor => {
  return new Tensor(addon._rint(tensor._native_ref));
};

export const clip = (tensor: Tensor, low: Tensor, high: Tensor): Tensor => {
  return new Tensor(addon._clip(tensor._native_ref, low._native_ref, high._native_ref));
};

export const identity = (dim: bigint, type: dtype = dtype.f32): Tensor => {
  return new Tensor(addon._identity(dim, type));
};

export const cos = (tensor: Tensor): Tensor => {
  return new Tensor(addon._cos(tensor._native_ref));
};

export const flip = (tensor: Tensor, dim: number): Tensor => {
  return new Tensor(addon._flip(tensor._native_ref, dim));
};

export const isnan = (tensor: Tensor): Tensor => {
  return new Tensor(addon._isnan(tensor._native_ref));
};

export const argmin = (input: Tensor, axis: number, keepDims = false): Tensor => {
  return new Tensor(addon._argmin(input._native_ref, axis, keepDims));
};

export const cumsum = (input: Tensor, axis: number): Tensor => {
  return new Tensor(addon._cumsum(input._native_ref, axis));
};

export const isInvalidArray = (tensor: Tensor): boolean => {
  return addon._isInvalidArray(tensor._native_ref);
};

export const matmul = (
  lhs: Tensor,
  rhs: Tensor,
  lhsProp: MatrixProperty = MatrixProperty.None,
  rhsProp: MatrixProperty = MatrixProperty.None
): Tensor => {
  return new Tensor(addon._matmul(lhs._native_ref, rhs._native_ref, lhsProp, rhsProp));
};

export const sub = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._sub(lhs._native_ref, rhs._native_ref));
};

export const lessThan = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._lessThan(lhs._native_ref, rhs._native_ref));
};

export const lessThanEqual = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._lessThanEqual(lhs._native_ref, rhs._native_ref));
};

export const bitwiseAnd = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._bitwiseAnd(lhs._native_ref, rhs._native_ref));
};

export const bitwiseOr = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._bitwiseOr(lhs._native_ref, rhs._native_ref));
};

export const rShift = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._rShift(lhs._native_ref, rhs._native_ref));
};

export const bitwiseXor = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._bitwiseXor(lhs._native_ref, rhs._native_ref));
};

export const neq = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._neq(lhs._native_ref, rhs._native_ref));
};

export const greaterThan = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._greaterThan(lhs._native_ref, rhs._native_ref));
};

export const lShift = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._lShift(lhs._native_ref, rhs._native_ref));
};

export const logicalAnd = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._logicalAnd(lhs._native_ref, rhs._native_ref));
};

export const mod = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._mod(lhs._native_ref, rhs._native_ref));
};

export const add = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._add(lhs._native_ref, rhs._native_ref));
};

export const mul = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._mul(lhs._native_ref, rhs._native_ref));
};

export const div = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._div(lhs._native_ref, rhs._native_ref));
};

export const logicalOr = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._logicalOr(lhs._native_ref, rhs._native_ref));
};

export const eq = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._eq(lhs._native_ref, rhs._native_ref));
};

export const greaterThanEqual = (lhs: Tensor, rhs: Tensor): Tensor => {
  return new Tensor(addon._greaterThanEqual(lhs._native_ref, rhs._native_ref));
};

export const copy = (_gen_tmp_external_self: Tensor): Tensor => {
  return new Tensor(addon._copy(_gen_tmp_external_self._native_ref));
};

export const shape = (_gen_tmp_external_self: Tensor): BigInt64Array => {
  return addon._shape(_gen_tmp_external_self._native_ref);
};

export const elements = (_gen_tmp_external_self: Tensor): bigint => {
  return addon._elements(_gen_tmp_external_self._native_ref);
};

export const dim = (_gen_tmp_external_self: Tensor, dim: bigint): bigint => {
  return addon._dim(_gen_tmp_external_self._native_ref, dim);
};

export const ndim = (_gen_tmp_external_self: Tensor): number => {
  return addon._ndim(_gen_tmp_external_self._native_ref);
};

export const isEmpty = (_gen_tmp_external_self: Tensor): boolean => {
  return addon._isEmpty(_gen_tmp_external_self._native_ref);
};

export const hasAdapter = (_gen_tmp_external_self: Tensor): boolean => {
  return addon._hasAdapter(_gen_tmp_external_self._native_ref);
};

export const bytes = (_gen_tmp_external_self: Tensor): bigint => {
  return addon._bytes(_gen_tmp_external_self._native_ref);
};

export const type = (_gen_tmp_external_self: Tensor): dtype => {
  return addon._type(_gen_tmp_external_self._native_ref);
};

export const isSparse = (_gen_tmp_external_self: Tensor): boolean => {
  return addon._isSparse(_gen_tmp_external_self._native_ref);
};

export const strides = (_gen_tmp_external_self: Tensor): BigInt64Array => {
  return addon._strides(_gen_tmp_external_self._native_ref);
};

export const astype = (_gen_tmp_external_self: Tensor, type: dtype): Tensor => {
  return new Tensor(addon._astype(_gen_tmp_external_self._native_ref, type));
};

export const flatten = (_gen_tmp_external_self: Tensor): Tensor => {
  return new Tensor(addon._flatten(_gen_tmp_external_self._native_ref));
};

export const asContiguousTensor = (_gen_tmp_external_self: Tensor): Tensor => {
  return new Tensor(addon._asContiguousTensor(_gen_tmp_external_self._native_ref));
};

export const backendType = (_gen_tmp_external_self: Tensor): TensorBackendType => {
  return addon._backendType(_gen_tmp_external_self._native_ref);
};

export const unlock = (_gen_tmp_external_self: Tensor) => {
  return addon._unlock(_gen_tmp_external_self._native_ref);
};

export const isLocked = (_gen_tmp_external_self: Tensor): boolean => {
  return addon._isLocked(_gen_tmp_external_self._native_ref);
};

export const isContiguous = (_gen_tmp_external_self: Tensor): boolean => {
  return addon._isContiguous(_gen_tmp_external_self._native_ref);
};

export const toString = (_gen_tmp_external_self: Tensor): string => {
  return addon._toString(_gen_tmp_external_self._native_ref);
};

export const toFloat32Array = (tensor: Tensor): Float32Array => {
  return addon._toFloat32Array(tensor._native_ref);
};

export const toFloat64Array = (tensor: Tensor): Float64Array => {
  return addon._toFloat64Array(tensor._native_ref);
};

export const toBoolInt8Array = (tensor: Tensor): Int8Array => {
  return addon._toBoolInt8Array(tensor._native_ref);
};

export const toInt16Array = (tensor: Tensor): Int16Array => {
  return addon._toInt16Array(tensor._native_ref);
};

export const toInt32Array = (tensor: Tensor): Int32Array => {
  return addon._toInt32Array(tensor._native_ref);
};

export const toInt64Array = (tensor: Tensor): BigInt64Array => {
  return addon._toInt64Array(tensor._native_ref);
};

export const toUint8Array = (tensor: Tensor): Uint8Array => {
  return addon._toUint8Array(tensor._native_ref);
};

export const toUint16Array = (tensor: Tensor): Uint16Array => {
  return addon._toUint16Array(tensor._native_ref);
};

export const toUint32Array = (tensor: Tensor): Uint32Array => {
  return addon._toUint32Array(tensor._native_ref);
};

export const toUint64Array = (tensor: Tensor): BigUint64Array => {
  return addon._toUint64Array(tensor._native_ref);
};

export const toFloat32Scalar = (tensor: Tensor): number => {
  return addon._toFloat32Scalar(tensor._native_ref);
};

export const toFloat64Scalar = (tensor: Tensor): number => {
  return addon._toFloat64Scalar(tensor._native_ref);
};

export const toBoolInt8Scalar = (tensor: Tensor): number => {
  return addon._toBoolInt8Scalar(tensor._native_ref);
};

export const toInt16Scalar = (tensor: Tensor): number => {
  return addon._toInt16Scalar(tensor._native_ref);
};

export const toInt32Scalar = (tensor: Tensor): number => {
  return addon._toInt32Scalar(tensor._native_ref);
};

export const toInt64Scalar = (tensor: Tensor): bigint => {
  return addon._toInt64Scalar(tensor._native_ref);
};

export const toUint8Scalar = (tensor: Tensor): number => {
  return addon._toUint8Scalar(tensor._native_ref);
};

export const toUint16Scalar = (tensor: Tensor): number => {
  return addon._toUint16Scalar(tensor._native_ref);
};

export const toUint32Scalar = (tensor: Tensor): number => {
  return addon._toUint32Scalar(tensor._native_ref);
};

export const toUint64Scalar = (tensor: Tensor): bigint => {
  return addon._toUint64Scalar(tensor._native_ref);
};

export const _eval = (tensor: Tensor): void => {
  return addon._eval(tensor._native_ref);
};

export const dispose = (tensor: Tensor): void => {
  return addon._dispose(tensor._native_ref);
};

export const tensorFromFloat32Buffer = (buffer: ArrayBuffer) => {
  return addon._tensorFromFloat32Buffer(buffer);
};

export const tensorFromFloat64Buffer = (buffer: ArrayBuffer) => {
  return addon._tensorFromFloat64Buffer(buffer);
};

export const tensorFromBoolInt8Buffer = (buffer: ArrayBuffer) => {
  return addon._tensorFromBoolInt8Buffer(buffer);
};

export const tensorFromInt16Buffer = (buffer: ArrayBuffer) => {
  return addon._tensorFromInt16Buffer(buffer);
};

export const tensorFromInt32Buffer = (buffer: ArrayBuffer) => {
  return addon._tensorFromInt32Buffer(buffer);
};

export const tensorFromInt64Buffer = (buffer: ArrayBuffer) => {
  return addon._tensorFromInt64Buffer(buffer);
};

export const tensorFromUint8Buffer = (buffer: ArrayBuffer) => {
  return addon._tensorFromUint8Buffer(buffer);
};

export const tensorFromUint16Buffer = (buffer: ArrayBuffer) => {
  return addon._tensorFromUint16Buffer(buffer);
};

export const tensorFromUint32Buffer = (buffer: ArrayBuffer) => {
  return addon._tensorFromUint32Buffer(buffer);
};

export const tensorFromUint64Buffer = (buffer: ArrayBuffer) => {
  return addon._tensorFromUint64Buffer(buffer);
};

export const save = (tensor: Tensor, path: string): void => {
  return addon._save(tensor._native_ref, path);
};

export const init = (): void => {
  return addon._init();
};

export const bytesUsed = (): bigint => {
  return addon._bytesUsed();
};

export const setRowMajor = (): void => {
  return addon._setRowMajor();
};

export const setColMajor = (): void => {
  return addon._setColMajor();
};

export const isRowMajor = (): boolean => {
  return addon._isRowMajor();
};

export const isColMajor = (): boolean => {
  return addon._isColMajor();
};

export const rand = (shape: BigInt64Array): Tensor => {
  return new Tensor(addon._rand(shape));
};

export const randn = (shape: BigInt64Array): Tensor => {
  return new Tensor(addon._randn(shape));
};
