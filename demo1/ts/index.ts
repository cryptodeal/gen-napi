// Code generated by gen-napi. DO NOT EDIT.
/* eslint-disable */
import { Tensor } from './tensor'
const {
	_toFloat32Array,
	_toFloat64Array,
	_toBoolInt8Array,
	_toInt16Array,
	_toInt32Array,
	_toInt64Array,
	_toUint8Array,
	_toUint16Array,
	_toUint32Array,
	_toUint64Array,
	_toFloat32Scalar,
	_toFloat64Scalar,
	_toBoolInt8Scalar,
	_toInt16Scalar,
	_toInt32Scalar,
	_toInt64Scalar,
	_toUint8Scalar,
	_toUint16Scalar,
	_toUint32Scalar,
	_toUint64Scalar,
	_eval: __eval,
	_dispose,
	_tensorFromFloat32Buffer,
	_tensorFromFloat64Buffer,
	_tensorFromBoolInt8Buffer,
	_tensorFromInt16Buffer,
	_tensorFromInt32Buffer,
	_tensorFromInt64Buffer,
	_tensorFromUint8Buffer,
	_tensorFromUint16Buffer,
	_tensorFromUint32Buffer,
	_tensorFromUint64Buffer,
	_save,
	_rint,
	_tril,
	_std,
	_norm,
	_all,
	_arange,
	_iota,
	_cos,
	_exp,
	_clip,
	_cumsum,
	_where,
	_amax,
	_sum,
	_maximum,
	_max,
	_reshape,
	_log1p,
	_argsort,
	_sigmoid,
	_sign,
	_power,
	_argmax,
	_log,
	_erf,
	_flip,
	_amin,
	_countNonzero,
	_floor,
	_allClose,
	_concatenate,
	_sin,
	_tanh,
	_sort,
	_median,
	_transpose,
	_tile,
	_logicalNot,
	_minimum,
	_min,
	_mean,
	_isinf,
	_matmul,
	_tensorBackendTypeToString,
	_identity,
	_negative,
	_sqrt,
	_argmin,
	_var: __var,
	_absolute,
	_isnan,
	_triu,
	_roll,
	_areTensorTypesEqual,
	_full,
	_nonzero,
	_ceil,
	_pad,
	_any,
	_isInvalidArray,
	_mod,
	_neq,
	_lessThanEqual,
	_div,
	_add,
	_greaterThan,
	_rShift,
	_bitwiseXor,
	_lessThan,
	_bitwiseOr,
	_eq,
	_greaterThanEqual,
	_logicalOr,
	_sub,
	_bitwiseAnd,
	_logicalAnd,
	_lShift,
	_mul,
	_init,
	_bytesUsed,
	_setRowMajor,
	_setColMajor,
	_isRowMajor,
	_isColMajor,
	_rand,
	_randn
} = import.meta.require("../../build/Release/shumai_bindings.node")

export enum TensorBackendType {
	Stub = 0,
	Tracer = 1,
	ArrayFire = 2,
	OneDnn = 3,
	Jit = 4
}

export enum Location {
	Host = 0,
	Device = 1
}

export enum StorageType {
	Dense = 0,
	CSR = 1,
	CSC = 2,
	COO = 3
}

export enum PadType {
	Constant = 0,
	Edge = 1,
	Symmetric = 2
}

export enum SortMode {
	Descending = 0,
	Ascending = 1
}

export enum MatrixProperty {
	None = 0,
	Transpose = 1
}

export enum dtype {
	f16 = 0,
	f32 = 1,
	f64 = 2,
	b8 = 3,
	s16 = 4,
	s32 = 5,
	s64 = 6,
	u8 = 7,
	u16 = 8,
	u32 = 9,
	u64 = 10
}

export const sigmoid = (): Tensor => {
	return new Tensor(_sigmoid());
}

export const log = (): Tensor => {
	return new Tensor(_log());
}

export const erf = (): Tensor => {
	return new Tensor(_erf());
}

export const flip = (): Tensor => {
	return new Tensor(_flip());
}

export const sign = (): Tensor => {
	return new Tensor(_sign());
}

export const power = (): Tensor => {
	return new Tensor(_power());
}

export const argmax = (): Tensor => {
	return new Tensor(_argmax());
}

export const amin = (): Tensor => {
	return new Tensor(_amin());
}

export const countNonzero = (): Tensor => {
	return new Tensor(_countNonzero());
}

export const concatenate = (): Tensor => {
	return new Tensor(_concatenate());
}

export const sin = (): Tensor => {
	return new Tensor(_sin());
}

export const tanh = (): Tensor => {
	return new Tensor(_tanh());
}

export const floor = (): Tensor => {
	return new Tensor(_floor());
}

export const allClose = (): boolean => {
	return _allClose();
}

export const transpose = (): Tensor => {
	return new Tensor(_transpose());
}

export const tile = (): Tensor => {
	return new Tensor(_tile());
}

export const logicalNot = (): Tensor => {
	return new Tensor(_logicalNot());
}

export const sort = (): Tensor => {
	return new Tensor(_sort());
}

export const median = (): Tensor => {
	return new Tensor(_median());
}

export const minimum = (): Tensor => {
	return new Tensor(_minimum());
}

export const min = (): void => {
	return _min();
}

export const mean = (): Tensor => {
	return new Tensor(_mean());
}

export const isinf = (): Tensor => {
	return new Tensor(_isinf());
}

export const matmul = (): Tensor => {
	return new Tensor(_matmul());
}

export const tensorBackendTypeToString = (): string => {
	return _tensorBackendTypeToString();
}

export const identity = (): Tensor => {
	return new Tensor(_identity());
}

export const negative = (): Tensor => {
	return new Tensor(_negative());
}

export const sqrt = (): Tensor => {
	return new Tensor(_sqrt());
}

export const absolute = (): Tensor => {
	return new Tensor(_absolute());
}

export const isnan = (): Tensor => {
	return new Tensor(_isnan());
}

export const triu = (): Tensor => {
	return new Tensor(_triu());
}

export const argmin = (): Tensor => {
	return new Tensor(_argmin());
}

export const _var = (): Tensor => {
	return new Tensor(__var());
}

export const full = (): Tensor => {
	return new Tensor(_full());
}

export const nonzero = (): Tensor => {
	return new Tensor(_nonzero());
}

export const ceil = (): Tensor => {
	return new Tensor(_ceil());
}

export const roll = (): Tensor => {
	return new Tensor(_roll());
}

export const areTensorTypesEqual = (): boolean => {
	return _areTensorTypesEqual();
}

export const pad = (): Tensor => {
	return new Tensor(_pad());
}

export const any = (): Tensor => {
	return new Tensor(_any());
}

export const isInvalidArray = (): boolean => {
	return _isInvalidArray();
}

export const norm = (): Tensor => {
	return new Tensor(_norm());
}

export const all = (): Tensor => {
	return new Tensor(_all());
}

export const arange = (): Tensor => {
	return new Tensor(_arange());
}

export const iota = (): Tensor => {
	return new Tensor(_iota());
}

export const cos = (): Tensor => {
	return new Tensor(_cos());
}

export const rint = (): Tensor => {
	return new Tensor(_rint());
}

export const tril = (): Tensor => {
	return new Tensor(_tril());
}

export const std = (): Tensor => {
	return new Tensor(_std());
}

export const exp = (): Tensor => {
	return new Tensor(_exp());
}

export const clip = (): Tensor => {
	return new Tensor(_clip());
}

export const cumsum = (): Tensor => {
	return new Tensor(_cumsum());
}

export const where = (): Tensor => {
	return new Tensor(_where());
}

export const amax = (): Tensor => {
	return new Tensor(_amax());
}

export const sum = (): Tensor => {
	return new Tensor(_sum());
}

export const reshape = (): Tensor => {
	return new Tensor(_reshape());
}

export const log1p = (): Tensor => {
	return new Tensor(_log1p());
}

export const argsort = (): Tensor => {
	return new Tensor(_argsort());
}

export const maximum = (): Tensor => {
	return new Tensor(_maximum());
}

export const max = (): void => {
	return _max();
}

export const toFloat32Array = (tensor: Tensor): Float32Array => {
	return _toFloat32Array(tensor._native_self);
}

export const toFloat64Array = (tensor: Tensor): Float64Array => {
	return _toFloat64Array(tensor._native_self);
}

export const toBoolInt8Array = (tensor: Tensor): Int8Array => {
	return _toBoolInt8Array(tensor._native_self);
}

export const toInt16Array = (tensor: Tensor): Int16Array => {
	return _toInt16Array(tensor._native_self);
}

export const toInt32Array = (tensor: Tensor): Int32Array => {
	return _toInt32Array(tensor._native_self);
}

export const toInt64Array = (tensor: Tensor): BigInt64Array => {
	return _toInt64Array(tensor._native_self);
}

export const toUint8Array = (tensor: Tensor): Uint8Array => {
	return _toUint8Array(tensor._native_self);
}

export const toUint16Array = (tensor: Tensor): Uint16Array => {
	return _toUint16Array(tensor._native_self);
}

export const toUint32Array = (tensor: Tensor): Uint32Array => {
	return _toUint32Array(tensor._native_self);
}

export const toUint64Array = (tensor: Tensor): BigUint64Array => {
	return _toUint64Array(tensor._native_self);
}

export const toFloat32Scalar = (tensor: Tensor): number => {
	return _toFloat32Scalar(tensor._native_self);
}

export const toFloat64Scalar = (tensor: Tensor): number => {
	return _toFloat64Scalar(tensor._native_self);
}

export const toBoolInt8Scalar = (tensor: Tensor): number => {
	return _toBoolInt8Scalar(tensor._native_self);
}

export const toInt16Scalar = (tensor: Tensor): number => {
	return _toInt16Scalar(tensor._native_self);
}

export const toInt32Scalar = (tensor: Tensor): number => {
	return _toInt32Scalar(tensor._native_self);
}

export const toInt64Scalar = (tensor: Tensor): bigint => {
	return _toInt64Scalar(tensor._native_self);
}

export const toUint8Scalar = (tensor: Tensor): number => {
	return _toUint8Scalar(tensor._native_self);
}

export const toUint16Scalar = (tensor: Tensor): number => {
	return _toUint16Scalar(tensor._native_self);
}

export const toUint32Scalar = (tensor: Tensor): number => {
	return _toUint32Scalar(tensor._native_self);
}

export const toUint64Scalar = (tensor: Tensor): bigint => {
	return _toUint64Scalar(tensor._native_self);
}

export const _eval = (tensor: Tensor): void => {
	return __eval(tensor._native_self);
}

export const dispose = (tensor: Tensor): void => {
	return _dispose(tensor._native_self);
}

export const tensorFromFloat32Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromFloat32Buffer(buffer);
}

export const tensorFromFloat64Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromFloat64Buffer(buffer);
}

export const tensorFromBoolInt8Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromBoolInt8Buffer(buffer);
}

export const tensorFromInt16Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromInt16Buffer(buffer);
}

export const tensorFromInt32Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromInt32Buffer(buffer);
}

export const tensorFromInt64Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromInt64Buffer(buffer);
}

export const tensorFromUint8Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromUint8Buffer(buffer);
}

export const tensorFromUint16Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromUint16Buffer(buffer);
}

export const tensorFromUint32Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromUint32Buffer(buffer);
}

export const tensorFromUint64Buffer = (buffer: ArrayBuffer) => {
	return _tensorFromUint64Buffer(buffer);
}

export const save = (tensor: Tensor, path: string): void => {
	return _save(tensor._native_self, path);
}

export const bitwiseAnd = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_bitwiseAnd(lhs._native_self, rhs._native_self));
}

export const logicalAnd = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_logicalAnd(lhs._native_self, rhs._native_self));
}

export const lShift = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_lShift(lhs._native_self, rhs._native_self));
}

export const mul = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_mul(lhs._native_self, rhs._native_self));
}

export const mod = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_mod(lhs._native_self, rhs._native_self));
}

export const neq = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_neq(lhs._native_self, rhs._native_self));
}

export const lessThanEqual = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_lessThanEqual(lhs._native_self, rhs._native_self));
}

export const div = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_div(lhs._native_self, rhs._native_self));
}

export const add = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_add(lhs._native_self, rhs._native_self));
}

export const greaterThan = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_greaterThan(lhs._native_self, rhs._native_self));
}

export const rShift = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_rShift(lhs._native_self, rhs._native_self));
}

export const bitwiseXor = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_bitwiseXor(lhs._native_self, rhs._native_self));
}

export const lessThan = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_lessThan(lhs._native_self, rhs._native_self));
}

export const bitwiseOr = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_bitwiseOr(lhs._native_self, rhs._native_self));
}

export const eq = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_eq(lhs._native_self, rhs._native_self));
}

export const greaterThanEqual = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_greaterThanEqual(lhs._native_self, rhs._native_self));
}

export const logicalOr = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_logicalOr(lhs._native_self, rhs._native_self));
}

export const sub = (lhs: Tensor, rhs: Tensor): Tensor => {
	return new Tensor(_sub(lhs._native_self, rhs._native_self));
}

export const init = (): void => {
	return _init();
}

export const bytesUsed = (): bigint => {
	return _bytesUsed();
}

export const setRowMajor = (): void => {
	return _setRowMajor();
}

export const setColMajor = (): void => {
	return _setColMajor();
}

export const isRowMajor = (): boolean => {
	return _isRowMajor();
}

export const isColMajor = (): boolean => {
	return _isColMajor();
}

export const rand = (shape: BigInt64Array): Tensor => {
	return new Tensor(_rand(shape.buffer));
}

export const randn = (shape: BigInt64Array): Tensor => {
	return new Tensor(_randn(shape.buffer));
}

