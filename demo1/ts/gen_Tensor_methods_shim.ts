import { dtype, MatrixProperty, PadType, SortMode, TensorBackendType } from './gen_enums';
// Code generated by gen-napi. DO NOT EDIT.
import type { Tensor } from './tensor';
const addon = import.meta.require('../../build/Release/shumai_bindings.node');

//////////
// source: TensorBase.h

export type _Native_Tensor = unknown & Record<string, never>;

export abstract class _Base_Tensor {
	protected _native_Tensor: _Native_Tensor;

	get _native_ref(): _Native_Tensor {
		return this._native_Tensor;
	}
}

/**
 * USAGE INSTRUCTIONS:
 * 1. Import `gen_Tensor_ops_shim` to file where corresponding js impl lives
 * 2. copy the following logic following class declaration:
 * export interface Tensor extends ReturnType<typeof gen_Tensor_ops_shim> {} // eslint-disable-line
 * for (const [method, closure] of Object.entries(gen_Tensor_ops_shim(Tensor))) {
 *   Tensor.prototype[method] = closure;
 * }
 */

export const gen_Tensor_ops_shim = (_Tensor: new (...args: unknown[]) => Tensor) => {
	return {
		copy(): Tensor {
			return new _Tensor(addon._copy(this._native_ref));
		},

		shape(): BigInt64Array {
			return addon._shape(this._native_ref);
		},

		elements(): bigint {
			return addon._elements(this._native_ref);
		},

		dim(dim: bigint): bigint {
			return addon._dim(this._native_ref, dim);
		},

		ndim(): number {
			return addon._ndim(this._native_ref);
		},

		isEmpty(): boolean {
			return addon._isEmpty(this._native_ref);
		},

		hasAdapter(): boolean {
			return addon._hasAdapter(this._native_ref);
		},

		bytes(): bigint {
			return addon._bytes(this._native_ref);
		},

		type(): dtype {
			return addon._type(this._native_ref);
		},

		isSparse(): boolean {
			return addon._isSparse(this._native_ref);
		},

		strides(): BigInt64Array {
			return addon._strides(this._native_ref);
		},

		astype(type: dtype): Tensor {
			return new _Tensor(addon._astype(this._native_ref, type));
		},

		flatten(): Tensor {
			return new _Tensor(addon._flatten(this._native_ref));
		},

		asContiguousTensor(): Tensor {
			return new _Tensor(addon._asContiguousTensor(this._native_ref));
		},

		backendType(): TensorBackendType {
			return addon._backendType(this._native_ref);
		},

		unlock() {
			return addon._unlock(this._native_ref);
		},

		isLocked(): boolean {
			return addon._isLocked(this._native_ref);
		},

		isContiguous(): boolean {
			return addon._isContiguous(this._native_ref);
		},

		toString(): string {
			return addon._toString(this._native_ref);
		},

		greaterThan(rhs: Tensor): Tensor {
			return new _Tensor(addon._greaterThan(this._native_ref, rhs._native_ref));
		},

		bitwiseXor(rhs: Tensor): Tensor {
			return new _Tensor(addon._bitwiseXor(this._native_ref, rhs._native_ref));
		},

		lessThan(rhs: Tensor): Tensor {
			return new _Tensor(addon._lessThan(this._native_ref, rhs._native_ref));
		},

		bitwiseAnd(rhs: Tensor): Tensor {
			return new _Tensor(addon._bitwiseAnd(this._native_ref, rhs._native_ref));
		},

		lShift(rhs: Tensor): Tensor {
			return new _Tensor(addon._lShift(this._native_ref, rhs._native_ref));
		},

		div(rhs: Tensor): Tensor {
			return new _Tensor(addon._div(this._native_ref, rhs._native_ref));
		},

		mul(rhs: Tensor): Tensor {
			return new _Tensor(addon._mul(this._native_ref, rhs._native_ref));
		},

		eq(rhs: Tensor): Tensor {
			return new _Tensor(addon._eq(this._native_ref, rhs._native_ref));
		},

		logicalOr(rhs: Tensor): Tensor {
			return new _Tensor(addon._logicalOr(this._native_ref, rhs._native_ref));
		},

		mod(rhs: Tensor): Tensor {
			return new _Tensor(addon._mod(this._native_ref, rhs._native_ref));
		},

		logicalAnd(rhs: Tensor): Tensor {
			return new _Tensor(addon._logicalAnd(this._native_ref, rhs._native_ref));
		},

		rShift(rhs: Tensor): Tensor {
			return new _Tensor(addon._rShift(this._native_ref, rhs._native_ref));
		},

		neq(rhs: Tensor): Tensor {
			return new _Tensor(addon._neq(this._native_ref, rhs._native_ref));
		},

		greaterThanEqual(rhs: Tensor): Tensor {
			return new _Tensor(addon._greaterThanEqual(this._native_ref, rhs._native_ref));
		},

		lessThanEqual(rhs: Tensor): Tensor {
			return new _Tensor(addon._lessThanEqual(this._native_ref, rhs._native_ref));
		},

		add(rhs: Tensor): Tensor {
			return new _Tensor(addon._add(this._native_ref, rhs._native_ref));
		},

		sub(rhs: Tensor): Tensor {
			return new _Tensor(addon._sub(this._native_ref, rhs._native_ref));
		},

		bitwiseOr(rhs: Tensor): Tensor {
			return new _Tensor(addon._bitwiseOr(this._native_ref, rhs._native_ref));
		},

		logicalNot(): Tensor {
			return new _Tensor(addon._logicalNot(this._native_ref));
		},

		sqrt(): Tensor {
			return new _Tensor(addon._sqrt(this._native_ref));
		},

		sign(): Tensor {
			return new _Tensor(addon._sign(this._native_ref));
		},

		minimum(rhs: Tensor): Tensor {
			return new _Tensor(addon._minimum(this._native_ref, rhs._native_ref));
		},

		argmin(axis: number, keepDims = false): Tensor {
			return new _Tensor(addon._argmin(this._native_ref, axis, keepDims));
		},

		ceil(): Tensor {
			return new _Tensor(addon._ceil(this._native_ref));
		},

		norm(axes: number[] | Int32Array = [], p = 2, keepDims = false): Tensor {
			return new _Tensor(
				addon._norm(
					this._native_ref,
					axes instanceof Int32Array ? axes : new Int32Array(axes),
					p,
					keepDims
				)
			);
		},

		all(axes: number[] | Int32Array = [], keepDims = false): Tensor {
			return new _Tensor(
				addon._all(
					this._native_ref,
					axes instanceof Int32Array ? axes : new Int32Array(axes),
					keepDims
				)
			);
		},

		floor(): Tensor {
			return new _Tensor(addon._floor(this._native_ref));
		},

		exp(): Tensor {
			return new _Tensor(addon._exp(this._native_ref));
		},

		median(axes: number[] | Int32Array = [], keepDims = false): Tensor {
			return new _Tensor(
				addon._median(
					this._native_ref,
					axes instanceof Int32Array ? axes : new Int32Array(axes),
					keepDims
				)
			);
		},

		clip(low: Tensor, high: Tensor): Tensor {
			return new _Tensor(addon._clip(this._native_ref, low._native_ref, high._native_ref));
		},

		power(rhs: Tensor): Tensor {
			return new _Tensor(addon._power(this._native_ref, rhs._native_ref));
		},

		mean(axes: number[] | Int32Array = [], keepDims = false): Tensor {
			return new _Tensor(
				addon._mean(
					this._native_ref,
					axes instanceof Int32Array ? axes : new Int32Array(axes),
					keepDims
				)
			);
		},

		reshape(shape: Array<number | bigint> | BigInt64Array): Tensor {
			return new _Tensor(
				addon._reshape(
					this._native_ref,
					shape instanceof BigInt64Array
						? shape
						: new BigInt64Array(shape.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
				)
			);
		},

		tile(shape: Array<number | bigint> | BigInt64Array): Tensor {
			return new _Tensor(
				addon._tile(
					this._native_ref,
					shape instanceof BigInt64Array
						? shape
						: new BigInt64Array(shape.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
				)
			);
		},

		tanh(): Tensor {
			return new _Tensor(addon._tanh(this._native_ref));
		},

		triu(): Tensor {
			return new _Tensor(addon._triu(this._native_ref));
		},

		pad(padWidths: Array<[number, number]>, type: PadType = PadType.Constant): Tensor {
			return new _Tensor(addon._pad(this._native_ref, padWidths, type));
		},

		sin(): Tensor {
			return new _Tensor(addon._sin(this._native_ref));
		},

		var(axes: number[] | Int32Array = [], bias = false, keepDims = false): Tensor {
			return new _Tensor(
				addon._var(
					this._native_ref,
					axes instanceof Int32Array ? axes : new Int32Array(axes),
					bias,
					keepDims
				)
			);
		},

		std(axes: number[] | Int32Array = [], keepDims = false): Tensor {
			return new _Tensor(
				addon._std(
					this._native_ref,
					axes instanceof Int32Array ? axes : new Int32Array(axes),
					keepDims
				)
			);
		},

		nonzero(): Tensor {
			return new _Tensor(addon._nonzero(this._native_ref));
		},

		absolute(): Tensor {
			return new _Tensor(addon._absolute(this._native_ref));
		},

		erf(): Tensor {
			return new _Tensor(addon._erf(this._native_ref));
		},

		tril(): Tensor {
			return new _Tensor(addon._tril(this._native_ref));
		},

		where(x: Tensor, y: Tensor): Tensor {
			return new _Tensor(addon._where(this._native_ref, x._native_ref, y._native_ref));
		},

		sort(axis: bigint, sortMode: SortMode = SortMode.Ascending): Tensor {
			return new _Tensor(addon._sort(this._native_ref, axis, sortMode));
		},

		argmax(axis: number, keepDims = false): Tensor {
			return new _Tensor(addon._argmax(this._native_ref, axis, keepDims));
		},

		log(): Tensor {
			return new _Tensor(addon._log(this._native_ref));
		},

		cos(): Tensor {
			return new _Tensor(addon._cos(this._native_ref));
		},

		isnan(): Tensor {
			return new _Tensor(addon._isnan(this._native_ref));
		},

		amin(axes: number[] | Int32Array = [], keepDims = false): Tensor {
			return new _Tensor(
				addon._amin(
					this._native_ref,
					axes instanceof Int32Array ? axes : new Int32Array(axes),
					keepDims
				)
			);
		},

		rint(): Tensor {
			return new _Tensor(addon._rint(this._native_ref));
		},

		roll(shift: number, axis: number): Tensor {
			return new _Tensor(addon._roll(this._native_ref, shift, axis));
		},

		cumsum(axis: number): Tensor {
			return new _Tensor(addon._cumsum(this._native_ref, axis));
		},

		negative(): Tensor {
			return new _Tensor(addon._negative(this._native_ref));
		},

		sigmoid(): Tensor {
			return new _Tensor(addon._sigmoid(this._native_ref));
		},

		isinf(): Tensor {
			return new _Tensor(addon._isinf(this._native_ref));
		},

		countNonzero(axes: number[] | Int32Array = [], keepDims = false): Tensor {
			return new _Tensor(
				addon._countNonzero(
					this._native_ref,
					axes instanceof Int32Array ? axes : new Int32Array(axes),
					keepDims
				)
			);
		},

		amax(axes: number[] | Int32Array = [], keepDims = false): Tensor {
			return new _Tensor(
				addon._amax(
					this._native_ref,
					axes instanceof Int32Array ? axes : new Int32Array(axes),
					keepDims
				)
			);
		},

		sum(axes: number[] | Int32Array = [], keepDims = false): Tensor {
			return new _Tensor(
				addon._sum(
					this._native_ref,
					axes instanceof Int32Array ? axes : new Int32Array(axes),
					keepDims
				)
			);
		},

		any(axes: number[] | Int32Array = [], keepDims = false): Tensor {
			return new _Tensor(
				addon._any(
					this._native_ref,
					axes instanceof Int32Array ? axes : new Int32Array(axes),
					keepDims
				)
			);
		},

		maximum(rhs: Tensor): Tensor {
			return new _Tensor(addon._maximum(this._native_ref, rhs._native_ref));
		},

		matmul(
			rhs: Tensor,
			lhsProp: MatrixProperty = MatrixProperty.None,
			rhsProp: MatrixProperty = MatrixProperty.None
		): Tensor {
			return new _Tensor(addon._matmul(this._native_ref, rhs._native_ref, lhsProp, rhsProp));
		},

		transpose(axes: Array<number | bigint> | BigInt64Array = []): Tensor {
			return new _Tensor(
				addon._transpose(
					this._native_ref,
					axes instanceof BigInt64Array
						? axes
						: new BigInt64Array(axes.map((v) => (typeof v === 'number' ? BigInt(v) : v)))
				)
			);
		},

		log1p(): Tensor {
			return new _Tensor(addon._log1p(this._native_ref));
		},

		flip(dim: number): Tensor {
			return new _Tensor(addon._flip(this._native_ref, dim));
		},

		argsort(axis: bigint, sortMode: SortMode = SortMode.Ascending): Tensor {
			return new _Tensor(addon._argsort(this._native_ref, axis, sortMode));
		}
	};
};
