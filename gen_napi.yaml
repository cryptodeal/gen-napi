# This is a config file that typescriptifies the packages under the example folder.
# and some other packages.
packages:
  - path: 'test/TensorBase.h'
    bindings_out_path: 'test/out'
    indent: "\t"
    type_mappings:
      Shape:
        ts: 'number[]'
      Dim:
        ts: 'number'
      dtype:
        ts: 'number'
        napi: 'Number'
        casts_to: 'fl::dtype'
        cast_napi: 'Int32Value'
      T:
        ts: 'number'
        napi: 'Number'
    js_wrapper_opts:
      front_matter: |
        import { Tensor } from './tensor'
      addon_path: 'build/Release/shumai_bindings.node'
      wrapper_out_path: 'test/ts/index.ts'
    ignored_methods:
      - 'scalar'
      - 'pad'
      - 'argsort'
      - 'fromScalar'
      # TODO: following op should not be ignored (ignored for compilation errors)
    header_frontmatter: |
      #include "flashlight/fl/autograd/Functions.h"
      #include "flashlight/fl/autograd/tensor/AutogradExtension.h"
      #include "flashlight/fl/autograd/tensor/AutogradOps.h"
      #include "flashlight/fl/common/DynamicBenchmark.h"
      #include "flashlight/fl/nn/Init.h"
      #include "flashlight/fl/runtime/Device.h"
      #include "flashlight/fl/runtime/Stream.h"
      #include "flashlight/fl/tensor/Compute.h"
      #include "flashlight/fl/tensor/Index.h"
      #include "flashlight/fl/tensor/Init.h"
      #include "flashlight/fl/tensor/Random.h"
      #include "flashlight/fl/tensor/TensorAdapter.h"
    bindings_frontmatter: |
      #include <atomic>
      #include <iostream>
      #include <string>
    global_vars: |
      static std::atomic<size_t> g_bytes_used = 0;
      static std::atomic<bool> g_row_major = true;
    global_type_out_transforms:
      Tensor: |
        g_bytes_used += /return/.bytes();
        Napi::MemoryManagement::AdjustExternalMemory(env, /return/.bytes());
    method_transforms:
      arange:
        arg_count: 3
        arg_check_transforms: |
          if (!info[0].IsNumber()) {
             Napi::TypeError::New(info.Env(), "`arange` expects args[0] to be typeof `number`").ThrowAsJavaScriptException();
             return env.Null();
           }
           if (!info[1].IsNumber()) {
             Napi::TypeError::New(info.Env(),"`arange` expects args[1] to be typeof `number`").ThrowAsJavaScriptException();
             return env.Null();
           }
           if (!info[2].IsNumber()) {
             Napi::TypeError::New(info.Env(), "`arange` expects args[2] to be typeof `number`").ThrowAsJavaScriptException();
             return env.Null();
           }
        return_transforms: |
          /return/ = fl::arange(/arg_0/, /arg_1/, /arg_2/);
        arg_transforms:
          start: |
            float start = /arg/.As<Napi::Number>().FloatValue();
          end: |
            float end = /arg/.As<Napi::Number>().FloatValue();
          step: |
            float step = /arg/.As<Napi::Number>().FloatValue();
      any:
        arg_count: 3
        return_transforms: |
          /return/ = fl::any(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      all:
        arg_count: 3
        return_transforms: |
          /return/ = fl::all(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      amin:
        arg_count: 3
        return_transforms: |
          /return/ = fl::amin(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      amax:
        arg_count: 3
        return_transforms: |
          /return/ = fl::amax(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      argmin:
        arg_count: 3
        return_transforms: |
          /return/ = fl::argmin(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>{static_cast<int>(/arg_1/)};
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
        arg_transforms:
          axis: |
            auto axis = axisArg(/arg/.As<Napi::Number>().Uint32Value(), g_row_major, /arg_0/->ndim());
      argmax:
        arg_count: 3
        return_transforms: |
          /return/ = fl::argmax(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>{static_cast<int>(/arg_1/)};
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
        arg_transforms:
          axis: |
            auto axis = axisArg(/arg/.As<Napi::Number>().Uint32Value(), g_row_major, /arg_0/->ndim());
      countNonzero:
        arg_count: 3
        return_transforms: |
          /return/ = fl::countNonzero(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      sum:
        arg_count: 3
        return_transforms: |
          /return/ = fl::sum(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      mean:
        arg_count: 3
        return_transforms: |
          /return/ = fl::mean(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      median:
        arg_count: 3
        return_transforms: |
          /return/ = fl::median(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      var:
        arg_count: 4
        return_transforms: |
          /return/ = fl::var(/arg_0/, /arg_1/, /arg_2/, /arg_3/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_3/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      std:
        arg_count: 3
        return_transforms: |
          /return/ = fl::median(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      norm:
        arg_count: 4
        return_transforms: |
          /return/ = fl::norm(/arg_0/, /arg_1/, /arg_2/, /arg_3/);
          if (p == std::numeric_limits<double>::infinity()) {
            /return/ = fl::abs(/arg_0/);
            /return/ = fl::amax(/arg_0/, /arg_1/, /arg_3/);
          }
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_3/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      full:
        arg_count: 2
        return_transforms: |
          /return/ = fl::full(fl::Shape(/arg_0/), /arg_1/);
        arg_transforms:
          dims: |
            std::vector<long long> dims = jsArrayArg<long long>(/arg/.As<Napi::Array>(), g_row_major, false, env);
          val: |
            float val = /arg/.As<Napi::Number>().FloatValue();
      identity:
        arg_count: 1
        return_transforms: |
          /return/ = fl::identity(/arg_0/);
        arg_transforms:
          dim: |
            int64_t dim = /arg/.As<Napi::Number>().Int64Value();
      iota:
        arg_count: 2
        ts_return_type: 'Tensor'
        return_transforms: |
          /return/ = fl::iota(fl::Shape(/arg_0/), fl::Shape(/arg_1/));
        arg_transforms:
          dims: |
            auto dims = jsArrayArg<long long>(/arg/.As<Napi::Array>(), g_row_major, false, env);
          tileDims: |
            auto tileDims = jsArrayArg<long long>(/arg/.As<Napi::Array>(), g_row_major, false, env);
      concatenate:
        arg_count: 2
        arg_transforms:
          axis: |
            auto axis = axisArg(/arg/.As<Napi::Number>().Int32Value(), g_row_major, (&tensors[0])->ndim());
          tensors: |
            auto tensors = jsTensorArrayArg<fl::Tensor>(/arg/.As<Napi::Array>(), env);
      tril:
        arg_count: 1
        return_transforms: |
          if (g_row_major) {
            /return/ = fl::triu(/arg_0/);
          } else {
            /return/ = fl::tril(/arg_0/);
          }
      triu:
        arg_count: 1
        return_transforms: |
          if (g_row_major) {
            /return/ = fl::tril(/arg_0/);
          } else {
            /return/ = fl::triu(/arg_0/);
          }
      sort:
        arg_count: 2
        return_transforms: |
          /return/ = fl::sort(/arg_0/, /arg_1/);
        arg_transforms:
          axis: |
            auto axis = /arg/.As<Napi::Number>().Uint32Value();
      matmul:
        arg_count: 2
        return_transforms: |
          if (g_row_major) {
            /return/ = fl::matmul(/arg_1/, /arg_0/);
          } else {
            /return/ = fl::matmul(/arg_0/, /arg_1/);
          }
      tile:
        arg_count: 2
        arg_transforms:
          shape: |
            auto shape = jsArrayArg<long long>(/arg/.As<Napi::Array>(), g_row_major, false, env);
      transpose:
        arg_count: 2
        arg_transforms:
          axes: |
            auto axes = jsArrayArg<long long>(/arg/.As<Napi::Array>(), g_row_major, /arg_0/->ndim(), env);
      reshape:
        arg_count: 2
        arg_transforms:
          shape: |
            auto shape = jsArrayArg<long long>(/arg/.As<Napi::Array>(), g_row_major, false, env);
    helper_funcs:
      arrayArg: |
        template <typename T>
        std::vector<T> arrayArg(const void* ptr, int len, bool reverse, int invert) {
          std::vector<T> out;
          out.reserve(len);
          for (auto i = 0; i < len; ++i) {
            const auto idx = reverse ? len - i - 1 : i;
            auto v = reinterpret_cast<const int64_t*>(ptr)[idx];
            if (invert && v < 0) {
              v = -v - 1;
            } else if (invert) {
              v = invert - v - 1;
            }
            out.emplace_back(v);
          }
          return out;
        }
      jsArrayArg: |
        template <typename T>
        std::vector<T> jsArrayArg(Napi::Array arr, bool reverse, int invert, Napi::Env env) {
          std::vector<T> out;
          const size_t len = static_cast<size_t>(arr.Length());
          out.reserve(len);
          for (size_t i = 0; i < len; ++i) {
            const auto idx = reverse ? len - i - 1 : i;
            Napi::Value val = arr[idx];
            if (!val.IsNumber()) {
              Napi::TypeError::New(env, "jsArrayArg requires `number[]`")
                  .ThrowAsJavaScriptException();
              return out;
            } else {
              int64_t v = val.As<Napi::Number>().Int64Value();
              if (invert && v < 0) {
                v = -v - 1;
              } else if (invert) {
                v = invert - v - 1;
              }
              out.emplace_back(v);
            }
          }
          return out;
        }
      jsTensorArrayArg: |
        template <typename T>
        std::vector<T> jsTensorArrayArg(Napi::Array arr, Napi::Env env) {
          std::vector<T> out;
          const size_t len = static_cast<size_t>(arr.Length());
          out.reserve(len);
          for (size_t i = 0; i < len; ++i) {
            Napi::Value temp = arr[i];
            if (temp.IsExternal()) {
              fl::Tensor* tensor = static_cast<fl::Tensor*>(temp.As<Napi::External<fl::Tensor>>().Data());
              out.emplace_back(*(tensor));
            } else {
              Napi::TypeError::New(env, "jsTensorArrayArg requires `Tensor[]`")
                    .ThrowAsJavaScriptException();
              return out;
            }
          }
          return out;
        }
      axisArg: |
        uint32_t axisArg(int32_t axis, bool reverse, int ndim) {
          if (!reverse) {
            return static_cast<uint32_t>(axis);
          }
          if (axis >= 0) {
            return static_cast<uint32_t>(ndim - axis - 1);
          } else {
            return static_cast<uint32_t>(-axis - 1);
          }
        }
      ptrArrayArg: |
        template <typename T>
        std::vector<T> ptrArrayArg(const void* ptr, int len) {
          std::vector<T> out;
          out.reserve(len);
          for (auto i = 0; i < len; ++i) {
            auto ptrAsInt = reinterpret_cast<const int64_t*>(ptr)[i];
            auto ptr = reinterpret_cast<T*>(ptrAsInt);
            out.emplace_back(*ptr);
          }
          return out;
        }
      load: |
        fl::Tensor* load(std::string filename, Napi::Env env) {
          try {
            fl::Tensor tensor;
            fl::load(filename, tensor);
            auto* t = new fl::Tensor(tensor);
            g_bytes_used += t->bytes();
            return t;
          } catch (std::exception const& e) {
            Napi::TypeError::New(env, e.what()).ThrowAsJavaScriptException();
          }
        }
    global_methods:
      - name: 'init'
        is_void: true
        body: |
          static void init(const Napi::CallbackInfo& info) {
            fl::init();
          }
      - name: 'bytesUsed'
        ts_return_type: 'bigint'
        body: |
          static Napi::Value bytesUsed(const Napi::CallbackInfo& info) {
            return Napi::BigInt::New(info.Env(), static_cast<int64_t>(g_bytes_used));
          }
      - name: 'setRowMajor'
        is_void: true
        body: |
          static void setRowMajor(const Napi::CallbackInfo& info) {
            g_row_major = true;
          }
      - name: 'setColMajor'
        is_void: true
        body: |
          static void setColMajor(const Napi::CallbackInfo& info) {
            g_row_major = true;
          }
      - name: 'isRowMajor'
        ts_return_type: 'boolean'
        body: |
          static Napi::Value isRowMajor(const Napi::CallbackInfo& info) {
            return Napi::Boolean::New(info.Env(), g_row_major);
          }
      - name: 'isColMajor'
        ts_return_type: 'boolean'
        body: |
          static Napi::Value isColMajor(const Napi::CallbackInfo& info) {
            return Napi::Boolean::New(info.Env(), !g_row_major);
          }
      - name: 'dtypeFloat32'
        ts_return_type: 'number'
        body: |
          static Napi::Value dtypeFloat32(const Napi::CallbackInfo& info) {
            return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::f32));
          }
      - name: 'dtypeFloat64'
        ts_return_type: 'number'
        body: |
          static Napi::Value dtypeFloat64(const Napi::CallbackInfo& info) {
            return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::f64));
          }
      - name: 'dtypeBoolInt8'
        ts_return_type: 'number'
        body: |
          static Napi::Value dtypeBoolInt8(const Napi::CallbackInfo& info) {
            return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::b8));
          }
      - name: 'dtypeInt16'
        ts_return_type: 'number'
        body: |
          static Napi::Value dtypeInt16(const Napi::CallbackInfo& info) {
            return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::s16));
          }
      - name: 'dtypeInt32'
        ts_return_type: 'number'
        body: |
          static Napi::Value dtypeInt32(const Napi::CallbackInfo& info) {
            return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::s32));
          }
      - name: 'dtypeInt64'
        ts_return_type: 'number'
        body: |
          static Napi::Value dtypeInt64(const Napi::CallbackInfo& info) {
            return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::s64));
          }
      - name: 'dtypeUint8'
        ts_return_type: 'number'
        body: |
          static Napi::Value dtypeUint8(const Napi::CallbackInfo& info) {
            return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::u8));
          }
      - name: 'dtypeUint16'
        ts_return_type: 'number'
        body: |
          static Napi::Value dtypeUint16(const Napi::CallbackInfo& info) {
            return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::u16));
          }
      - name: 'dtypeUint32'
        ts_return_type: 'number'
        body: |
          static Napi::Value dtypeUint32(const Napi::CallbackInfo& info) {
            return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::u32));
          }
      - name: 'dtypeUint64'
        ts_return_type: 'number'
        body: |
          static Napi::Value dtypeUint64(const Napi::CallbackInfo& info) {
            return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::u64));
          }
      - name: 'rand'
        ts_return_type: 'Tensor'
        args:
          - name: shape
            ts_type: number[]
        body: |
          static Napi::Value rand(const Napi::CallbackInfo& info) {
            Napi::Env env = info.Env();
            if (info.Length() != 1 || !info[0].IsArray()) {
              Napi::TypeError::New(info.Env(),
                                  "`rand` expects exactly 1 arg; "
                                  "(expected type `number[]`)...")
                  .ThrowAsJavaScriptException();
              return env.Null();
            }
            std::vector<long long> shape =
                jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major, false, env);
            fl::Tensor t;
            t = fl::rand(fl::Shape(shape));
            g_bytes_used += t.bytes();
            auto* tensor = new fl::Tensor(t);
            Napi::External<fl::Tensor> wrapped = ExternalizeTensor(env, tensor);
            return wrapped;
          }
      - name: 'randn'
        ts_return_type: 'Tensor'
        args:
          - name: shape
            ts_type: number[]
        body: |
          static Napi::Value randn(const Napi::CallbackInfo& info) {
            Napi::Env env = info.Env();
            if (info.Length() != 1 || !info[0].IsArray()) {
              Napi::TypeError::New(env, "`randn` expects exactly 1 arg; (expected type `number[]`)...").ThrowAsJavaScriptException();
              return env.Null();
            }
            std::vector<long long> shape =
                jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major, false, env);
            fl::Tensor t;
            t = fl::randn(fl::Shape(shape));
            g_bytes_used += t.bytes();
            auto* tensor = new fl::Tensor(t);
            Napi::External<fl::Tensor> wrapped = ExternalizeTensor(env, tensor);
            return wrapped;
          }
    type_handlers:
      dtype:
        out_type: 'Napi::Number'
        out_var: '_out'
        handler: |
          Napi::Number _out = Napi::Number::New(env, static_cast<int>(/val/));
      Shape:
        out_type: 'Napi::TypedArrayOf<int64_t>'
        out_var: '_out'
        handler: |
          const size_t length = static_cast<const size_t>(info[0].As<Napi::External<fl::Tensor>>().Data()->ndim());
          Napi::TypedArrayOf<int64_t> _out =
              Napi::TypedArrayOf<int64_t>::New(env, length, napi_bigint64_array);
          const int out_len = static_cast<int>(length);
          for (auto i = 0; i < out_len; ++i) {
            const auto idx = g_row_major ? out_len - i - 1 : i;
            _out[i] = static_cast<long long>(/val/[idx]);
          }
    class_opts:
      Tensor:
        ext_finalizer_transform: |
          if (/this/->hasAdapter()) {
            g_bytes_used -= /this/->bytes();
          }
        fields:
          - name: 'copy'
          - name: 'shape'
          - name: 'elements'
          - name: 'ndim'
          - name: 'isEmpty'
          - name: 'bytes'
          - name: 'strides'
          - name: 'astype'
          - name: 'type'
          - name: 'isSparse'
          - name: 'flatten'
          - name: 'asContiguousTensor'
          - name: 'isContiguous'
        forced_methods:
          - name: 'toFloat32Array'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'Float32Array'
            body: |
              Napi::Value toFloat32Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toFloat32Array` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                size_t elemLen = static_cast<size_t>(t->elements());
                size_t byteLen = elemLen * sizeof(float);
                void* ptr = t->astype(fl::dtype::f32).host<float>();
                Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
                Napi::TypedArrayOf<float> out = Napi::TypedArrayOf<float>::New(env, elemLen, buff, 0, napi_float32_array);
                return out;
              }
          - name: 'toFloat64Array'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'Float64Array'
            body: |
              Napi::Value toFloat64Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toFloat32Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                size_t elemLen = static_cast<size_t>(t->elements());
                size_t byteLen = elemLen * sizeof(double);
                void* ptr = t->astype(fl::dtype::f64).host<double>();
                Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
                Napi::TypedArrayOf<double> out = Napi::TypedArrayOf<double>::New(env, elemLen, buff, 0, napi_float64_array);
                return out;
              }
          - name: 'toBoolInt8Array'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'Int8Array'
            body: |
              Napi::Value toBoolInt8Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toBoolInt8Array` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                size_t elemLen = static_cast<size_t>(t->elements());
                size_t byteLen = elemLen * sizeof(int8_t);
                void* ptr = t->astype(fl::dtype::b8).host<int>();
                Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
                Napi::TypedArrayOf<int8_t> out = Napi::TypedArrayOf<int8_t>::New(env, elemLen, buff, 0, napi_int8_array);
                return out;
              }
          - name: 'toInt16Array'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'Int16Array'
            body: |
              Napi::Value toInt16Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toInt16Array` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                size_t elemLen = static_cast<size_t>(t->elements());
                size_t byteLen = elemLen * sizeof(int16_t);
                void* ptr = t->astype(fl::dtype::s16).host<int>();
                Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
                Napi::TypedArrayOf<int16_t> out = Napi::TypedArrayOf<int16_t>::New(env, elemLen, buff, 0, napi_int16_array);
                return out;
              }
          - name: 'toInt32Array'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'Int32Array'
            body: |
              Napi::Value toInt32Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toInt32Array` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                size_t elemLen = static_cast<size_t>(t->elements());
                size_t byteLen = elemLen * sizeof(int32_t);
                void* ptr = t->astype(fl::dtype::s32).host<int>();
                Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
                Napi::TypedArrayOf<int32_t> out = Napi::TypedArrayOf<int32_t>::New(env, elemLen, buff, 0, napi_int32_array);
                return out;
              }
          - name: 'save'
            args:
              - name: 'filename'
                ts_type: 'string'
            is_void: true
            body: |
              void save(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (info.Length() != 2) {
                  Napi::TypeError::New(env, "`save` expects exactly 2 args").ThrowAsJavaScriptException();
                  return;
                }
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toInt32Array` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                if (!info[1].IsString()) {
                  Napi::TypeError::New(
                      env,
                      "Tensor method `save` requires arg `filename` of type `string`... ")
                      .ThrowAsJavaScriptException();
                }
                Napi::String str = info[1].As<Napi::String>();
                std::string filename = str.Utf8Value();
                fl::save(filename, *(t));
              }
          - name: 'toInt64Array'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'BigInt64Array'
            body: |
              Napi::Value toInt64Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toInt64Array` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                size_t elemLen = static_cast<size_t>(t->elements());
                size_t byteLen = elemLen * sizeof(int64_t);
                void* ptr = t->astype(fl::dtype::s64).host<int>();
                Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
                Napi::TypedArrayOf<int64_t> out = Napi::TypedArrayOf<int64_t>::New(env, elemLen, buff, 0, napi_bigint64_array);
                return out;
              }
          - name: 'toUint8Array'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'Uint8Array'
            body: |
              Napi::Value toUint8Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`Uint8Array` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                size_t elemLen = static_cast<size_t>(t->elements());
                size_t byteLen = elemLen * sizeof(uint8_t);
                void* ptr = t->astype(fl::dtype::u8).host<unsigned>();
                Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
                Napi::TypedArrayOf<uint8_t> out = Napi::TypedArrayOf<uint8_t>::New(env, elemLen, buff, 0, napi_uint8_array);
                return out;
              }
          - name: 'toUint16Array'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'Uint16Array'
            body: |
              Napi::Value toUint16Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toUint16Array` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                size_t elemLen = static_cast<size_t>(t->elements());
                size_t byteLen = elemLen * sizeof(uint16_t);
                void* ptr = t->astype(fl::dtype::u16).host<unsigned>();
                Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
                Napi::TypedArrayOf<uint16_t> out = Napi::TypedArrayOf<uint16_t>::New(env, elemLen, buff, 0, napi_uint16_array);
                return out;
              }
          - name: 'toUint32Array'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'Uint32Array'
            body: |
              Napi::Value toUint32Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toUint32Array` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                size_t elemLen = static_cast<size_t>(t->elements());
                size_t byteLen = elemLen * sizeof(uint32_t);
                void* ptr = t->astype(fl::dtype::u32).host<unsigned>();
                Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
                Napi::TypedArrayOf<uint32_t> out = Napi::TypedArrayOf<uint32_t>::New(env, elemLen, buff, 0, napi_uint32_array);
                return out;
              }
          - name: 'toUint64Array'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'BigUint64Array'
            body: |
              Napi::Value toUint64Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toUint64Array` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                size_t elemLen = static_cast<size_t>(t->elements());
                size_t byteLen = elemLen * sizeof(uint64_t);
                void* ptr = t->astype(fl::dtype::u64).host<unsigned>();
                Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
                Napi::TypedArrayOf<uint64_t> out = Napi::TypedArrayOf<uint64_t>::New(env, elemLen, buff, 0, napi_biguint64_array);
                return out;
              }
          - name: 'toFloat32Scalar'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'number'
            body: |
              static Napi::Value toFloat32Scalar(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toFloat32Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                return Napi::Number::New(info.Env(), t->asScalar<float>());
              }
          - name: 'toFloat64Scalar'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'number'
            body: |
              static Napi::Value toFloat64Scalar(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toFloat64Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                return Napi::Number::New(info.Env(), t->asScalar<double>());
              }
          - name: 'toBoolInt8Scalar'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'number'
            body: |
              static Napi::Value toBoolInt8Scalar(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toBoolInt8Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                return Napi::Number::New(info.Env(), t->asScalar<char>());
              }
          - name: 'toInt16Scalar'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'number'
            body: |
              static Napi::Value toInt16Scalar(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toInt16Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                return Napi::Number::New(info.Env(), t->asScalar<int16_t>());
              }
          - name: 'toInt32Scalar'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'number'
            body: |
              static Napi::Value toInt32Scalar(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toInt32Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                return Napi::Number::New(info.Env(), t->asScalar<int32_t>());
              }
          - name: 'toInt64Scalar'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'bigint'
            body: |
              static Napi::Value toInt64Scalar(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toInt64Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                return Napi::BigInt::New(info.Env(), t->asScalar<int64_t>());
              }
          - name: 'toUint8Scalar'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'number'
            body: |
              static Napi::Value toUint8Scalar(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toUint8Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                return Napi::Number::New(info.Env(), t->asScalar<uint8_t>());
              }
          - name: 'toUint16Scalar'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'number'
            body: |
              static Napi::Value toUint16Scalar(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toUint16Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                return Napi::Number::New(info.Env(), t->asScalar<uint16_t>());
              }
          - name: 'toUint32Scalar'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'number'
            body: |
              static Napi::Value toUint32Scalar(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toUint32Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                return Napi::Number::New(info.Env(), t->asScalar<uint32_t>());
              }
          - name: 'toUint64Scalar'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            ts_return_type: 'bigint'
            body: |
              static Napi::Value toUint64Scalar(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toUint64Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                return Napi::BigInt::New(info.Env(), t->asScalar<uint64_t>());
              }
          - name: 'eval'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            is_void: true
            body: |
              void eval(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toUint64Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                }
                fl::Tensor* t = static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                fl::eval(*(t));
              }
          - name: 'dispose'
            args:
              - name: 'tensor'
                ts_type: 'Tensor'
            is_void: true
            body: |
              void dispose(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsExternal()) {
                  Napi::TypeError::New(info.Env(),
                                      "`toUint64Scalar` expects args[0] to be "
                                      "`Napi::External<fl::Tensor>` `Tensor`")
                      .ThrowAsJavaScriptException();
                }
                fl::Tensor& t = *static_cast<fl::Tensor*>(info[0].As<Napi::External<fl::Tensor>>().Data());
                g_bytes_used -= t.bytes();
                fl::detail::releaseAdapterUnsafe(t);
              }
          - name: 'tensorFromFloat32Array'
            ts_return_type: 'any'
            args:
              - name: 'arr'
                ts_type: 'Float32Array'
            body: |
              static Napi::Value tensorFromFloat32Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsTypedArray()) {
                  Napi::TypeError::New(env,
                                      "`tensorFromFloat32Array` expects exactly 1 arg; "
                                      "(expected type `Float32Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArray underlying = info[0].As<Napi::TypedArray>();
                int64_t length = static_cast<int64_t>(underlying.ElementLength());
                napi_typedarray_type arrayType = underlying.TypedArrayType();
                if (arrayType != napi_float32_array) {
                  Napi::TypeError::New(env,
                                      "`tensorFromFloat32Array` expects exactly 1 arg; "
                                      "(expected type `Float32Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArrayOf<float> float_array =
                    underlying.As<Napi::TypedArrayOf<float>>();
                float* ptr = float_array.Data();
                auto* t = new fl::Tensor(
                    fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
                g_bytes_used += t->bytes();
                Napi::External<fl::Tensor> wrapped = ExternalizeTensor(env, t);
                return wrapped;
              }
          - name: 'tensorFromFloat64Array'
            ts_return_type: 'any'
            args:
              - name: 'arr'
                ts_type: 'Float64Array'
            body: |
              static Napi::Value tensorFromFloat64Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsTypedArray()) {
                  Napi::TypeError::New(env,
                                      "`tensorFromFloat64Array` expects exactly 1 arg; "
                                      "(expected type `Float64Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArray underlying = info[0].As<Napi::TypedArray>();
                int64_t length = static_cast<int64_t>(underlying.ElementLength());
                napi_typedarray_type arrayType = underlying.TypedArrayType();
                if (arrayType != napi_float64_array) {
                  Napi::TypeError::New(env,
                                      "`tensorFromFloat64Array` expects exactly 1 arg; "
                                      "(expected type `Float64Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArrayOf<double> double_array =
                    underlying.As<Napi::TypedArrayOf<double>>();
                double* ptr = double_array.Data();
                auto* t = new fl::Tensor(
                    fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
                g_bytes_used += t->bytes();
                Napi::External<fl::Tensor> wrapped = ExternalizeTensor(env, t);
                return wrapped;
              }
          - name: 'tensorFromBoolInt8Array'
            ts_return_type: 'any'
            args:
              - name: 'arr'
                ts_type: 'Int8Array'
            body: |
              static Napi::Value tensorFromBoolInt8Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsTypedArray()) {
                  Napi::TypeError::New(env,
                                      "`tensorFromBoolInt8Array` expects exactly 1 arg; "
                                      "(expected type `Int8Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArray underlying = info[0].As<Napi::TypedArray>();
                int64_t length = static_cast<int64_t>(underlying.ElementLength());
                napi_typedarray_type arrayType = underlying.TypedArrayType();
                if (arrayType != napi_int8_array) {
                  Napi::TypeError::New(env,
                                      "`tensorFromBoolInt8Array` expects exactly 1 arg; "
                                      "(expected type `Int8Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArrayOf<int8_t> int8_array =
                    underlying.As<Napi::TypedArrayOf<int8_t>>();
                char* ptr = reinterpret_cast<char*>(int8_array.Data());
                auto* t = new fl::Tensor(
                    fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
                g_bytes_used += t->bytes();
                Napi::External<fl::Tensor> wrapped = ExternalizeTensor(env, t);
                return wrapped;
              }
          - name: 'tensorFromInt16Array'
            ts_return_type: 'any'
            args:
              - name: 'arr'
                ts_type: 'Int16Array'
            body: |
              static Napi::Value tensorFromInt16Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsTypedArray()) {
                  Napi::TypeError::New(env,
                                      "`tensorFromInt16Array` expects exactly 1 arg; "
                                      "(expected type `Int16Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArray underlying = info[0].As<Napi::TypedArray>();
                int64_t length = static_cast<int64_t>(underlying.ElementLength());
                napi_typedarray_type arrayType = underlying.TypedArrayType();
                if (arrayType != napi_int16_array) {
                  Napi::TypeError::New(env,
                                      "`tensorFromInt16Array` expects exactly 1 arg; "
                                      "(expected type `Int16Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArrayOf<int16_t> int16_array =
                    underlying.As<Napi::TypedArrayOf<int16_t>>();
                int16_t* ptr = int16_array.Data();
                auto* t = new fl::Tensor(
                    fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
                g_bytes_used += t->bytes();
                Napi::External<fl::Tensor> wrapped = ExternalizeTensor(env, t);
                return wrapped;
              }
          - name: 'tensorFromInt32Array'
            ts_return_type: 'any'
            args:
              - name: 'arr'
                ts_type: 'Int32Array'
            body: |
              static Napi::Value tensorFromInt32Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsTypedArray()) {
                  Napi::TypeError::New(env,
                                      "`tensorFromInt32Array` expects exactly 1 arg; "
                                      "(expected type `Int32Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArray underlying = info[0].As<Napi::TypedArray>();
                int64_t length = static_cast<int64_t>(underlying.ElementLength());
                napi_typedarray_type arrayType = underlying.TypedArrayType();
                if (arrayType != napi_int32_array) {
                  Napi::TypeError::New(env,
                                      "`tensorFromInt32Array` expects exactly 1 arg; "
                                      "(expected type `Int32Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArrayOf<int32_t> int32_array =
                    underlying.As<Napi::TypedArrayOf<int32_t>>();
                int32_t* ptr = int32_array.Data();
                auto* t = new fl::Tensor(
                    fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
                g_bytes_used += t->bytes();
                Napi::External<fl::Tensor> wrapped = ExternalizeTensor(env, t);
                return wrapped;
              }
          - name: 'tensorFromInt64Array'
            ts_return_type: 'any'
            args:
              - name: 'arr'
                ts_type: 'BigInt64Array'
            body: |
              static Napi::Value tensorFromInt64Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsTypedArray()) {
                  Napi::TypeError::New(env,
                                      "`tensorFromInt64Array` expects exactly 1 arg; "
                                      "(expected type `BigInt64Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArray underlying = info[0].As<Napi::TypedArray>();
                int64_t length = static_cast<int64_t>(underlying.ElementLength());
                napi_typedarray_type arrayType = underlying.TypedArrayType();
                if (arrayType != napi_bigint64_array) {
                  Napi::TypeError::New(env,
                                      "`tensorFromInt64Array` expects exactly 1 arg; "
                                      "(expected type `BigInt64Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArrayOf<int64_t> int64_array =
                    underlying.As<Napi::TypedArrayOf<int64_t>>();
                int64_t* ptr = int64_array.Data();
                auto* t = new fl::Tensor(
                    fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
                g_bytes_used += t->bytes();
                Napi::External<fl::Tensor> wrapped = ExternalizeTensor(env, t);
                return wrapped;
              }
          - name: 'tensorFromUint8Array'
            ts_return_type: 'any'
            args:
              - name: 'arr'
                ts_type: 'Uint8Array'
            body: |
              static Napi::Value tensorFromUint8Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsTypedArray()) {
                  Napi::TypeError::New(env,
                                      "`tensorFromUint8Array` expects exactly 1 arg; "
                                      "(expected type `Uint8Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArray underlying = info[0].As<Napi::TypedArray>();
                int64_t length = static_cast<int64_t>(underlying.ElementLength());
                napi_typedarray_type arrayType = underlying.TypedArrayType();
                if (arrayType != napi_uint8_array) {
                  Napi::TypeError::New(env,
                                      "`tensorFromUint8Array` expects exactly 1 arg; "
                                      "(expected type `Uint8Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArrayOf<uint8_t> uint8_array =
                    underlying.As<Napi::TypedArrayOf<uint8_t>>();
                uint8_t* ptr = uint8_array.Data();
                auto* t = new fl::Tensor(
                    fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
                g_bytes_used += t->bytes();
                Napi::External<fl::Tensor> wrapped = ExternalizeTensor(env, t);
                return wrapped;
              }
          - name: 'tensorFromUint16Array'
            ts_return_type: 'any'
            args:
              - name: 'arr'
                ts_type: 'Uint16Array'
            body: |
              static Napi::Value tensorFromUint16Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsTypedArray()) {
                  Napi::TypeError::New(env,
                                      "`tensorFromUint16Array` expects exactly 1 arg; "
                                      "(expected type `Uint16Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArray underlying = info[0].As<Napi::TypedArray>();
                int64_t length = static_cast<int64_t>(underlying.ElementLength());
                napi_typedarray_type arrayType = underlying.TypedArrayType();
                if (arrayType != napi_int16_array) {
                  Napi::TypeError::New(env,
                                      "`tensorFromUint16Array` expects exactly 1 arg; "
                                      "(expected type `Uint16Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArrayOf<uint16_t> uint16_array =
                    underlying.As<Napi::TypedArrayOf<uint16_t>>();
                uint16_t* ptr = uint16_array.Data();
                auto* t = new fl::Tensor(
                    fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
                g_bytes_used += t->bytes();
                Napi::External<fl::Tensor> wrapped = ExternalizeTensor(env, t);
                return wrapped;
              }
          - name: 'tensorFromUint32Array'
            args:
              - name: 'arr'
                ts_type: 'Uint32Array'
            ts_return_type: 'any'
            body: |
              static Napi::Value tensorFromUint32Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsTypedArray()) {
                  Napi::TypeError::New(env,
                                      "`tensorFromUint32Array` expects exactly 1 arg; "
                                      "(expected type `Uint32Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArray underlying = info[0].As<Napi::TypedArray>();
                int64_t length = static_cast<int64_t>(underlying.ElementLength());
                napi_typedarray_type arrayType = underlying.TypedArrayType();
                if (arrayType != napi_uint32_array) {
                  Napi::TypeError::New(env,
                                      "`tensorFromUint32Array` expects exactly 1 arg; "
                                      "(expected type `Uint32Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArrayOf<uint32_t> uint32_array =
                    underlying.As<Napi::TypedArrayOf<uint32_t>>();
                uint32_t* ptr = uint32_array.Data();
                auto* t = new fl::Tensor(
                    fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
                g_bytes_used += t->bytes();
                Napi::External<fl::Tensor> wrapped = ExternalizeTensor(env, t);
                return wrapped;
              }
          - name: 'tensorFromUint64Array'
            args:
              - name: 'arr'
                ts_type: 'BigUint64Array'
            ts_return_type: 'any'
            body: |
              static Napi::Value tensorFromUint64Array(const Napi::CallbackInfo& info) {
                Napi::Env env = info.Env();
                if (!info[0].IsTypedArray()) {
                  Napi::TypeError::New(env,
                                      "`tensorFromUint64Array` expects exactly 1 arg; "
                                      "(expected type `BigUint64Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArray underlying = info[0].As<Napi::TypedArray>();
                int64_t length = static_cast<int64_t>(underlying.ElementLength());
                napi_typedarray_type arrayType = underlying.TypedArrayType();
                if (arrayType != napi_biguint64_array) {
                  Napi::TypeError::New(env,
                                      "`tensorFromUint64Array` expects exactly 1 arg; "
                                      "(expected type `BigUint64Array`)...")
                      .ThrowAsJavaScriptException();
                  return env.Null();
                }
                Napi::TypedArrayOf<uint64_t> int64_array =
                    underlying.As<Napi::TypedArrayOf<uint64_t>>();
                uint64_t* ptr = int64_array.Data();
                auto* t = new fl::Tensor(
                    fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
                g_bytes_used += t->bytes();
                Napi::External<fl::Tensor> wrapped = ExternalizeTensor(env, t);
                return wrapped;
              }
