lint_cmd: bun format
packages:
  - path: demo2/BasicLogic.h
    bindings_out_path: demo2/out
    js_wrapper_opts:
      addon_path: build/Release/test.node
      wrapper_out_path: demo2/ts/index.ts
  # - path: demo1/TensorBase.h
  - path: ../flashlight/flashlight/fl/tensor/TensorBase.h
    lib_root_dir: ../flashlight
    path_to_forced_logic: demo1/ForcedLogic.cc
    bindings_out_path: demo1/out
    track_external_memory: g_bytes_used
    indent: '  '
    type_mappings:
      fl::Shape:
        needs_wrapper: true
        native_type: std::vector<long long>
      fl::Dim:
        needs_wrapper: true
        native_type: long long
      T:
        native_type: float
    js_wrapper_opts:
      addon_path: build/Release/shumai_bindings.node
      wrapper_out_path: demo1/ts/index.ts
    ignored_methods:
      - scalar
      - device
      - host
      - fromScalar
      - releaseAdapter
      - releaseAdapterUnsafe
      - detail::releaseAdapter
      - detail::releaseAdapterUnsafe
      - topk
      - print
    grouped_method_transforms:
      - applies_to:
          - roll
          - cumsum
        arg_transforms:
          axis: |
            auto axis = axisArg(/arg/.As<Napi::Number>().Uint32Value(), g_row_major, /arg_0/->ndim());
      - applies_to:
          - full
          - iota
        arg_transforms:
          dims: |
            auto tmp_dims = /arg/.As<Napi::TypedArrayOf<int64_t>>();
            std::vector<long long> dims = arrayArg<long long>(tmp_dims.Data(), tmp_dims.ElementLength(), g_row_major, false);
      - applies_to:
          - reshape
          - tile
        arg_transforms:
          shape: |
            auto tmp_shape = /arg/.As<Napi::TypedArrayOf<int64_t>>();
            std::vector<long long> shape = arrayArg<long long>(tmp_shape.Data(), tmp_shape.ElementLength(), g_row_major, false);
      - applies_to:
          - transpose
        arg_transforms:
          axes: |
            auto tmp_axes = /arg/.As<Napi::TypedArrayOf<int64_t>>();
            auto axes = arrayArg<long long>(tmp_axes.Data(), tmp_axes.ElementLength(), g_row_major, /arg_0/->ndim());
      - applies_to:
          - amin
          - amax
          - sum
          - mean
          - median
          - var
          - std
          - norm
          - countNonzero
          - any
          - all
        arg_transforms:
          axes: |
            auto tmp_axes = /arg/.As<Napi::TypedArrayOf<int32_t>>();
            auto axes = arrayArg<int>(tmp_axes.Data(), tmp_axes.ElementLength(), g_row_major, /arg_0/->ndim());
      - applies_to:
          - argmin
          - argmax
        return_transforms: |
          auto axes_set = std::unordered_set<int>{static_cast<int>(/arg_1/)};
          auto base_shape = (/arg_0/)->shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
        arg_transforms:
          axis: auto axis = axisArg(/arg/.As<Napi::Number>().Uint32Value(), g_row_major, /arg_0/->ndim());
      - applies_to:
          - any
          - all
          - amin
          - amax
          - countNonzero
          - sum
          - mean
          - std
          - median
        return_transforms: |
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/)->shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
    method_transforms:
      var:
        return_transforms: |
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = /arg_0/->shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_3/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      norm:
        return_transforms: |
          if (p == std::numeric_limits<double>::infinity()) {
            /return/ = fl::abs(*/arg_0/);
            /return/ = fl::amax(*/arg_0/, /arg_1/, /arg_3/);
          }
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = /arg_0/->shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_3/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      concatenate:
        arg_transforms:
          axis: auto axis = axisArg(/arg/.As<Napi::Number>().Int32Value(), g_row_major, /arg_0/[0].ndim());
      iota:
        arg_transforms:
          tileDims: |
            auto tmp_tileDims = /arg/.As<Napi::TypedArrayOf<int64_t>>();
            auto tileDims = arrayArg<long long>(tmp_tileDims.Data(), tmp_tileDims.ElementLength(), g_row_major, false);
      tril:
        return_transforms: |
          fl::Tensor /return/;
          if (g_row_major) {
            /return/ = fl::triu(*/arg_0/);
          } else {
            /return/ = fl::tril(*/arg_0/);
          }
      triu:
        return_transforms: |
          fl::Tensor /return/;
          if (g_row_major) {
            /return/ = fl::tril(*/arg_0/);
          } else {
            /return/ = fl::triu(*/arg_0/);
          }
      matmul:
        return_transforms: |
          fl::Tensor /return/;
          if (g_row_major) {
            /return/ = fl::matmul(*/arg_1/, */arg_0/, /arg_3/, /arg_2/);
          } else {
            /return/ = fl::matmul(*/arg_0/, */arg_1/, /arg_2/, /arg_3/);
          }
    class_opts:
      Tensor:
        path_to_impl: demo1/ts/tensor.ts
        ignored_fields:
          - setContext
          - stream
          - getContext() const
          - releaseAdapter
          - releaseAdapterUnsafe
          - shallowCopy
          - location
          - operator()
          - operator<<
          - operator=
          - backend
          - flat
        bytes_used: bytes
        ext_finalizer_transform: |
          if (/this/->hasAdapter()) {
            auto bytes = -1 * /this/->bytes();
            g_bytes_used += bytes;
            Napi::MemoryManagement::AdjustExternalMemory(env, bytes);
          }
