packages:
  - path: 'test/TensorBase.h'
    bindings_out_path: 'test/out'
    indent: "\t"
    type_mappings:
      Shape:
        ts: 'number[]'
      Dim:
        ts: 'number'
      dtype:
        ts: 'number'
        napi: 'Number'
        casts_to: 'fl::dtype'
        cast_napi: 'Int32Value'
      T:
        ts: 'number'
        napi: 'Number'
    js_wrapper_opts:
      front_matter: |
        import { Tensor } from './tensor'
      addon_path: 'build/Release/shumai_bindings.node'
      wrapper_out_path: 'test/ts/index.ts'
    ignored_methods:
      - 'scalar'
      - 'pad'
      - 'argsort'
      - 'fromScalar'
    path_to_forced_logic: test/ForcedLogic.cc
    global_type_out_transforms:
      Tensor: |
        auto _out_byte_count = /return/.bytes();
        g_bytes_used += _out_byte_count;
        Napi::MemoryManagement::AdjustExternalMemory(env, _out_byte_count);
    method_transforms:
      arange:
        arg_count: 3
        arg_check_transforms: |
          if (!info[0].IsNumber()) {
             Napi::TypeError::New(env, "`arange` expects args[0] to be typeof `number`").ThrowAsJavaScriptException();
             return env.Null();
           }
           if (!info[1].IsNumber()) {
             Napi::TypeError::New(env, "`arange` expects args[1] to be typeof `number`").ThrowAsJavaScriptException();
             return env.Null();
           }
           if (!info[2].IsNumber()) {
             Napi::TypeError::New(env, "`arange` expects args[2] to be typeof `number`").ThrowAsJavaScriptException();
             return env.Null();
           }
        return_transforms: |
          /return/ = fl::arange(/arg_0/, /arg_1/, /arg_2/);
        arg_transforms:
          start: |
            float start = /arg/.As<Napi::Number>().FloatValue();
          end: |
            float end = /arg/.As<Napi::Number>().FloatValue();
          step: |
            float step = /arg/.As<Napi::Number>().FloatValue();
      any:
        arg_count: 3
        return_transforms: |
          /return/ = fl::any(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      all:
        arg_count: 3
        return_transforms: |
          /return/ = fl::all(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      amin:
        arg_count: 3
        return_transforms: |
          /return/ = fl::amin(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      amax:
        arg_count: 3
        return_transforms: |
          /return/ = fl::amax(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      argmin:
        arg_count: 3
        return_transforms: |
          /return/ = fl::argmin(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>{static_cast<int>(/arg_1/)};
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
        arg_transforms:
          axis: |
            auto axis = axisArg(/arg/.As<Napi::Number>().Uint32Value(), g_row_major, /arg_0/->ndim());
      argmax:
        arg_count: 3
        return_transforms: |
          /return/ = fl::argmax(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>{static_cast<int>(/arg_1/)};
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
        arg_transforms:
          axis: |
            auto axis = axisArg(/arg/.As<Napi::Number>().Uint32Value(), g_row_major, /arg_0/->ndim());
      countNonzero:
        arg_count: 3
        return_transforms: |
          /return/ = fl::countNonzero(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      sum:
        arg_count: 3
        return_transforms: |
          /return/ = fl::sum(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      mean:
        arg_count: 3
        return_transforms: |
          /return/ = fl::mean(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      median:
        arg_count: 3
        return_transforms: |
          /return/ = fl::median(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      var:
        arg_count: 4
        return_transforms: |
          /return/ = fl::var(/arg_0/, /arg_1/, /arg_2/, /arg_3/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_3/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      std:
        arg_count: 3
        return_transforms: |
          /return/ = fl::median(/arg_0/, /arg_1/, /arg_2/);
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_2/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      norm:
        arg_count: 4
        return_transforms: |
          /return/ = fl::norm(/arg_0/, /arg_1/, /arg_2/, /arg_3/);
          if (p == std::numeric_limits<double>::infinity()) {
            /return/ = fl::abs(/arg_0/);
            /return/ = fl::amax(/arg_0/, /arg_1/, /arg_3/);
          }
          auto axes_set = std::unordered_set<int>(/arg_1/.begin(), /arg_1/.end());
          auto base_shape = (/arg_0/).shape().get();
          std::vector<fl::Dim> new_shape;
          for (size_t idx = 0; idx < base_shape.size(); ++idx) {
            if (axes_set.count(idx) || (axes_set.size() == 0)) {
              if (/arg_3/) {
                new_shape.emplace_back(1);
              }
              continue;
            }
            new_shape.emplace_back(base_shape[idx]);
          }
          const auto& shape = fl::Shape(new_shape);
          /return/ = fl::reshape(/return/, shape);
      full:
        arg_count: 2
        return_transforms: |
          /return/ = fl::full(fl::Shape(/arg_0/), /arg_1/);
        arg_transforms:
          dims: |
            std::vector<long long> dims = jsArrayArg<long long>(/arg/.As<Napi::Array>(), g_row_major, false, env);
          val: |
            float val = /arg/.As<Napi::Number>().FloatValue();
      identity:
        arg_count: 1
        return_transforms: |
          /return/ = fl::identity(/arg_0/);
        arg_transforms:
          dim: |
            int64_t dim = /arg/.As<Napi::Number>().Int64Value();
      iota:
        arg_count: 2
        ts_return_type: 'Tensor'
        return_transforms: |
          /return/ = fl::iota(fl::Shape(/arg_0/), fl::Shape(/arg_1/));
        arg_transforms:
          dims: |
            auto dims = jsArrayArg<long long>(/arg/.As<Napi::Array>(), g_row_major, false, env);
          tileDims: |
            auto tileDims = jsArrayArg<long long>(/arg/.As<Napi::Array>(), g_row_major, false, env);
      concatenate:
        arg_count: 2
        arg_transforms:
          axis: |
            auto axis = axisArg(/arg/.As<Napi::Number>().Int32Value(), g_row_major, (&tensors[0])->ndim());
          tensors: |
            auto tensors = jsTensorArrayArg<fl::Tensor>(/arg/.As<Napi::Array>(), env);
      tril:
        arg_count: 1
        return_transforms: |
          if (g_row_major) {
            /return/ = fl::triu(/arg_0/);
          } else {
            /return/ = fl::tril(/arg_0/);
          }
      triu:
        arg_count: 1
        return_transforms: |
          if (g_row_major) {
            /return/ = fl::tril(/arg_0/);
          } else {
            /return/ = fl::triu(/arg_0/);
          }
      sort:
        arg_count: 2
        return_transforms: |
          /return/ = fl::sort(/arg_0/, /arg_1/);
        arg_transforms:
          axis: |
            auto axis = /arg/.As<Napi::Number>().Uint32Value();
      matmul:
        arg_count: 2
        return_transforms: |
          if (g_row_major) {
            /return/ = fl::matmul(/arg_1/, /arg_0/);
          } else {
            /return/ = fl::matmul(/arg_0/, /arg_1/);
          }
      tile:
        arg_count: 2
        arg_transforms:
          shape: |
            auto shape = jsArrayArg<long long>(/arg/.As<Napi::Array>(), g_row_major, false, env);
      transpose:
        arg_count: 2
        arg_transforms:
          axes: |
            auto axes = jsArrayArg<long long>(/arg/.As<Napi::Array>(), g_row_major, /arg_0/->ndim(), env);
      reshape:
        arg_count: 2
        arg_transforms:
          shape: |
            auto shape = jsArrayArg<long long>(/arg/.As<Napi::Array>(), g_row_major, false, env);
    type_handlers:
      dtype:
        out_type: 'Napi::Number'
        out_var: '_out'
        handler: |
          Napi::Number _out = Napi::Number::New(env, static_cast<int>(/val/));
      Shape:
        out_type: 'Napi::TypedArrayOf<int64_t>'
        out_var: '_out'
        handler: |
          const size_t length = static_cast<const size_t>(UnExternalize<fl::Tensor>(info[0])->ndim());
          Napi::TypedArrayOf<int64_t> _out =
              Napi::TypedArrayOf<int64_t>::New(env, length, napi_bigint64_array);
          const int out_len = static_cast<int>(length);
          for (auto i = 0; i < out_len; ++i) {
            const auto idx = g_row_major ? out_len - i - 1 : i;
            _out[i] = static_cast<long long>(/val/[idx]);
          }
    class_opts:
      Tensor:
        ext_finalizer_transform: |
          if (/this/->hasAdapter()) {
            auto byte_count = static_cast<int64_t>(/this/->bytes());
            g_bytes_used -= byte_count;
            Napi::MemoryManagement::AdjustExternalMemory(env, -byte_count);
          }
        fields:
          - name: 'copy'
          - name: 'shape'
          - name: 'elements'
          - name: 'ndim'
          - name: 'isEmpty'
          - name: 'bytes'
          - name: 'strides'
          - name: 'astype'
          - name: 'type'
          - name: 'isSparse'
          - name: 'flatten'
          - name: 'asContiguousTensor'
          - name: 'isContiguous'
