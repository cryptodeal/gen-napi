// Code generated by gen-napi. DO NOT EDIT.
#include <napi.h>
#include <atomic>
#include <string>

//////////
// source: BasicLogic.h

// non-exported helpers
template <typename T>
static inline std::vector<T> jsArrayToVector(Napi::Array arr,
                                             bool reverse,
                                             int invert) {
  std::vector<T> out;
  size_t len = arr.Length();
  out.reserve(len);
  for (size_t i = 0; i < len; ++i) {
    const auto idx = reverse ? len - i - 1 : i;
    Napi::Value val = arr[idx];
    auto v = static_cast<const T>(val.As<Napi::Number>().Int64Value());
    if (invert && v < 0) {
      v = -v - 1;
    } else if (invert) {
      v = invert - v - 1;
    }
    out.emplace_back(v);
  }
  return out;
}

template <typename T>
static inline void DeleteArrayBuffer(Napi::Env env,
                                     void* /*data*/,
                                     std::vector<T>* hint) {
  size_t bytes = hint->size() * sizeof(T);
  std::unique_ptr<std::vector<T>> vectorPtrToDelete(hint);
  Napi::MemoryManagement::AdjustExternalMemory(env, -bytes);
}

// exported functions

static Napi::Value _baz(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(env, "`baz` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Undefined();
  }
  if (!info[0].IsTypedArray()) {
    Napi::TypeError::New(env,
                         "`baz` expects args[0] to be typeof `Float32Array`)")
        .ThrowAsJavaScriptException();
    return env.Undefined();
  }
  float* a = info[0].As<Napi::TypedArrayOf<float>>().Data();
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(env, "`baz` expects args[1] to be typeof `number`)")
        .ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int b = static_cast<int>(info[1].As<Napi::Number>().Int64Value());
  float* _res;
  _res = demo2::baz(a, b);
  size_t _res_byte_len = sizeof(_res);
  size_t _res_elem_len = _res_byte_len / sizeof(*_res);
  std::unique_ptr<std::vector<float>> _res_native_array =
      std::make_unique<std::vector<float>>(_res, _res + _res_elem_len);
  Napi::ArrayBuffer _res_arraybuffer =
      Napi::ArrayBuffer::New(env, _res_native_array->data(), _res_byte_len,
                             DeleteArrayBuffer<float>, _res_native_array.get());
  _res_native_array.release();
  Napi::MemoryManagement::AdjustExternalMemory(env, _res_byte_len);
  return Napi::TypedArrayOf<float>::New(env, _res_elem_len, _res_arraybuffer, 0,
                                        napi_float32_array);
}

static Napi::Value _test(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(env, "`test` expects exactly 1 arg")
        .ThrowAsJavaScriptException();
    return env.Undefined();
  }
  if (!info[0].IsString()) {
    Napi::TypeError::New(env, "`test` expects args[0] to be typeof `string`)")
        .ThrowAsJavaScriptException();
    return env.Undefined();
  }
  std::string a = info[0].As<Napi::String>().Utf8Value();
  std::string _res;
  _res = demo2::test(a);
  return Napi::String::New(env, _res);
}

// NAPI exports

Napi::Object Init(Napi::Env env, Napi::Object exports) {
  exports.Set(Napi::String::New(env, "_baz"), Napi::Function::New(env, _baz));
  exports.Set(Napi::String::New(env, "_test"), Napi::Function::New(env, _test));
  return exports;
}

NODE_API_MODULE(addon, Init)
