// Code generated by gen-napi. DO NOT EDIT.
const {
	_Tensor,
	_full,
	_identity,
	_iota,
	_tile,
	_log,
	_log1p,
	_absolute,
	_amin,
	_mean,
	_var,
	_arange,
	_exp,
	_roll,
	_logicalNot,
	_tanh,
	_ceil,
	_sigmoid,
	_sign,
	_where,
	_matmul,
	_amax,
	_median,
	_std,
	_norm,
	_cos,
	_rint,
	_argmax,
	_floor,
	_clip,
	_transpose,
	_nonzero,
	_flip,
	_isnan,
	_isinf,
	_tril,
	_sort,
	_sum,
	_reshape,
	_concatenate,
	_negative,
	_sin,
	_triu,
	_minimum,
	_argmin,
	_countNonzero,
	_all,
	_sqrt,
	_erf,
	_maximum,
	_power,
	_cumsum,
	_any,
	_lShift,
	_sub,
	_bitwiseOr,
	_div,
	_neq,
	_mod,
	_greaterThanEqual,
	_bitwiseXor,
	_rShift,
	_add,
	_eq,
	_logicalOr,
	_greaterThan,
	_lessThan,
	_lessThanEqual,
	_logicalAnd,
	_bitwiseAnd,
	_mul
} = require('../../build/Release/flashlight_napi_bindings.node')

class Tensor {
	#_native_self	constructor(t) {
		this.#_native_self = new _Tensor(t);
	}
	log1p(...args) {
		return this.#_native_self.log1p(...args);
	}

	absolute(...args) {
		return this.#_native_self.absolute(...args);
	}

	amin(...args) {
		return this.#_native_self.amin(...args);
	}

	tile(...args) {
		return this.#_native_self.tile(...args);
	}

	log(...args) {
		return this.#_native_self.log(...args);
	}

	mean(...args) {
		return this.#_native_self.mean(...args);
	}

	var(...args) {
		return this.#_native_self.var(...args);
	}

	exp(...args) {
		return this.#_native_self.exp(...args);
	}

	roll(...args) {
		return this.#_native_self.roll(...args);
	}

	where(...args) {
		return this.#_native_self.where(...args);
	}

	matmul(...args) {
		return this.#_native_self.matmul(...args);
	}

	amax(...args) {
		return this.#_native_self.amax(...args);
	}

	logicalNot(...args) {
		return this.#_native_self.logicalNot(...args);
	}

	tanh(...args) {
		return this.#_native_self.tanh(...args);
	}

	ceil(...args) {
		return this.#_native_self.ceil(...args);
	}

	sigmoid(...args) {
		return this.#_native_self.sigmoid(...args);
	}

	sign(...args) {
		return this.#_native_self.sign(...args);
	}

	median(...args) {
		return this.#_native_self.median(...args);
	}

	std(...args) {
		return this.#_native_self.std(...args);
	}

	norm(...args) {
		return this.#_native_self.norm(...args);
	}

	cos(...args) {
		return this.#_native_self.cos(...args);
	}

	rint(...args) {
		return this.#_native_self.rint(...args);
	}

	floor(...args) {
		return this.#_native_self.floor(...args);
	}

	clip(...args) {
		return this.#_native_self.clip(...args);
	}

	tril(...args) {
		return this.#_native_self.tril(...args);
	}

	sort(...args) {
		return this.#_native_self.sort(...args);
	}

	sum(...args) {
		return this.#_native_self.sum(...args);
	}

	transpose(...args) {
		return this.#_native_self.transpose(...args);
	}

	nonzero(...args) {
		return this.#_native_self.nonzero(...args);
	}

	flip(...args) {
		return this.#_native_self.flip(...args);
	}

	isnan(...args) {
		return this.#_native_self.isnan(...args);
	}

	isinf(...args) {
		return this.#_native_self.isinf(...args);
	}

	argmin(...args) {
		return this.#_native_self.argmin(...args);
	}

	countNonzero(...args) {
		return this.#_native_self.countNonzero(...args);
	}

	reshape(...args) {
		return this.#_native_self.reshape(...args);
	}

	negative(...args) {
		return this.#_native_self.negative(...args);
	}

	sin(...args) {
		return this.#_native_self.sin(...args);
	}

	triu(...args) {
		return this.#_native_self.triu(...args);
	}

	all(...args) {
		return this.#_native_self.all(...args);
	}

	any(...args) {
		return this.#_native_self.any(...args);
	}

	sqrt(...args) {
		return this.#_native_self.sqrt(...args);
	}

	erf(...args) {
		return this.#_native_self.erf(...args);
	}

	maximum(...args) {
		return this.#_native_self.maximum(...args);
	}

	power(...args) {
		return this.#_native_self.power(...args);
	}

	cumsum(...args) {
		return this.#_native_self.cumsum(...args);
	}

}

