// Code generated by gen-napi. DO NOT EDIT.
const {
	_Tensor,
	_rint,
	_sigmoid,
	_amin,
	_countNonzero,
	_all,
	_transpose,
	_negative,
	_sqrt,
	_ceil,
	_matmul,
	_argmax,
	_mean,
	_var: __var,
	_tile,
	_nonzero,
	_erf,
	_roll,
	_sign,
	_sort,
	_exp,
	_tanh,
	_flip,
	_isinf,
	_amax,
	_sum,
	_std,
	_full,
	_identity,
	_reshape,
	_logicalNot,
	_log,
	_cos,
	_clip,
	_minimum,
	_arange,
	_iota,
	_cumsum,
	_median,
	_maximum,
	_power,
	_sin,
	_floor,
	_absolute,
	_norm,
	_concatenate,
	_log1p,
	_triu,
	_where,
	_argmin,
	_any,
	_isnan,
	_tril,
	_lShift,
	_bitwiseAnd,
	_greaterThanEqual,
	_div,
	_logicalAnd,
	_eq,
	_mod,
	_lessThan,
	_lessThanEqual,
	_logicalOr,
	_rShift,
	_mul,
	_bitwiseXor,
	_sub,
	_add,
	_neq,
	_bitwiseOr,
	_greaterThan,
	_initinit,
	_bytesUsedbytesUsed,
	_setRowMajorsetRowMajor,
	_setColMajorsetColMajor,
	_isRowMajorisRowMajor,
	_isColMajorisColMajor,
	_dtypeFloat32dtypeFloat32,
	_dtypeFloat64dtypeFloat64,
	_dtypeBoolInt8dtypeBoolInt8,
	_dtypeInt16dtypeInt16,
	_dtypeInt32dtypeInt32,
	_dtypeInt64dtypeInt64,
	_dtypeUint8dtypeUint8,
	_dtypeUint16dtypeUint16,
	_dtypeUint32dtypeUint32,
	_dtypeUint64dtypeUint64,
	_randrand,
	_randnrandn
} = require("../../build/Release/flashlight_napi_bindings.node")

class Tensor {
	#_native_self

	constructor(t) {
		this.#_native_self = new _Tensor(t);
	}

	mean(axes, keepDims) {
		return this.#_native_self.mean(this.#_native_self,axes, keepDims);
	}

	var(axes, bias, keepDims) {
		return this.#_native_self.var(this.#_native_self,axes, bias, keepDims);
	}

	tile(shape) {
		return this.#_native_self.tile(this.#_native_self,shape);
	}

	nonzero() {
		return this.#_native_self.nonzero(this.#_native_self,);
	}

	sqrt() {
		return this.#_native_self.sqrt(this.#_native_self,);
	}

	ceil() {
		return this.#_native_self.ceil(this.#_native_self,);
	}

	matmul(rhs, lhsProp, rhsProp) {
		return this.#_native_self.matmul(this.#_native_self,rhs, lhsProp, rhsProp);
	}

	exp() {
		return this.#_native_self.exp(this.#_native_self,);
	}

	tanh() {
		return this.#_native_self.tanh(this.#_native_self,);
	}

	erf() {
		return this.#_native_self.erf(this.#_native_self,);
	}

	roll(shift, axis) {
		return this.#_native_self.roll(this.#_native_self,shift, axis);
	}

	sign() {
		return this.#_native_self.sign(this.#_native_self,);
	}

	sort(axis, sortMode) {
		return this.#_native_self.sort(this.#_native_self,axis, sortMode);
	}

	std(axes, keepDims) {
		return this.#_native_self.std(this.#_native_self,axes, keepDims);
	}

	flip(dim) {
		return this.#_native_self.flip(this.#_native_self,dim);
	}

	isinf() {
		return this.#_native_self.isinf(this.#_native_self,);
	}

	amax(axes, keepDims) {
		return this.#_native_self.amax(this.#_native_self,axes, keepDims);
	}

	sum(axes, keepDims) {
		return this.#_native_self.sum(this.#_native_self,axes, keepDims);
	}

	clip(low, high) {
		return this.#_native_self.clip(this.#_native_self,low, high);
	}

	reshape(shape) {
		return this.#_native_self.reshape(this.#_native_self,shape);
	}

	logicalNot() {
		return this.#_native_self.logicalNot(this.#_native_self,);
	}

	log() {
		return this.#_native_self.log(this.#_native_self,);
	}

	cos() {
		return this.#_native_self.cos(this.#_native_self,);
	}

	maximum(rhs) {
		return this.#_native_self.maximum(this.#_native_self,rhs);
	}

	power(rhs) {
		return this.#_native_self.power(this.#_native_self,rhs);
	}

	cumsum(axis) {
		return this.#_native_self.cumsum(this.#_native_self,axis);
	}

	median(axes, keepDims) {
		return this.#_native_self.median(this.#_native_self,axes, keepDims);
	}

	sin() {
		return this.#_native_self.sin(this.#_native_self,);
	}

	log1p() {
		return this.#_native_self.log1p(this.#_native_self,);
	}

	floor() {
		return this.#_native_self.floor(this.#_native_self,);
	}

	absolute() {
		return this.#_native_self.absolute(this.#_native_self,);
	}

	norm(axes, p, keepDims) {
		return this.#_native_self.norm(this.#_native_self,axes, p, keepDims);
	}

	isnan() {
		return this.#_native_self.isnan(this.#_native_self,);
	}

	tril() {
		return this.#_native_self.tril(this.#_native_self,);
	}

	triu() {
		return this.#_native_self.triu(this.#_native_self,);
	}

	where(x, y) {
		return this.#_native_self.where(this.#_native_self,x, y);
	}

	argmin(axis, keepDims) {
		return this.#_native_self.argmin(this.#_native_self,axis, keepDims);
	}

	any(axes, keepDims) {
		return this.#_native_self.any(this.#_native_self,axes, keepDims);
	}

	all(axes, keepDims) {
		return this.#_native_self.all(this.#_native_self,axes, keepDims);
	}

	transpose(axes) {
		return this.#_native_self.transpose(this.#_native_self,axes);
	}

	negative() {
		return this.#_native_self.negative(this.#_native_self,);
	}

	rint() {
		return this.#_native_self.rint(this.#_native_self,);
	}

	sigmoid() {
		return this.#_native_self.sigmoid(this.#_native_self,);
	}

	amin(axes, keepDims) {
		return this.#_native_self.amin(this.#_native_self,axes, keepDims);
	}

	countNonzero(axes, keepDims) {
		return this.#_native_self.countNonzero(this.#_native_self,axes, keepDims);
	}

	neq(rhs) {
		return this.#_native_self.neq(this.#_native_self,rhs);
	}

	bitwiseOr(rhs) {
		return this.#_native_self.bitwiseOr(this.#_native_self,rhs);
	}

	greaterThan(rhs) {
		return this.#_native_self.greaterThan(this.#_native_self,rhs);
	}

	add(rhs) {
		return this.#_native_self.add(this.#_native_self,rhs);
	}

	bitwiseAnd(rhs) {
		return this.#_native_self.bitwiseAnd(this.#_native_self,rhs);
	}

	greaterThanEqual(rhs) {
		return this.#_native_self.greaterThanEqual(this.#_native_self,rhs);
	}

	div(rhs) {
		return this.#_native_self.div(this.#_native_self,rhs);
	}

	lShift(rhs) {
		return this.#_native_self.lShift(this.#_native_self,rhs);
	}

	logicalOr(rhs) {
		return this.#_native_self.logicalOr(this.#_native_self,rhs);
	}

	rShift(rhs) {
		return this.#_native_self.rShift(this.#_native_self,rhs);
	}

	mul(rhs) {
		return this.#_native_self.mul(this.#_native_self,rhs);
	}

	logicalAnd(rhs) {
		return this.#_native_self.logicalAnd(this.#_native_self,rhs);
	}

	eq(rhs) {
		return this.#_native_self.eq(this.#_native_self,rhs);
	}

	mod(rhs) {
		return this.#_native_self.mod(this.#_native_self,rhs);
	}

	lessThan(rhs) {
		return this.#_native_self.lessThan(this.#_native_self,rhs);
	}

	lessThanEqual(rhs) {
		return this.#_native_self.lessThanEqual(this.#_native_self,rhs);
	}

	bitwiseXor(rhs) {
		return this.#_native_self.bitwiseXor(this.#_native_self,rhs);
	}

	sub(rhs) {
		return this.#_native_self.sub(this.#_native_self,rhs);
	}

	copy() {
		return this.#_native_self.copy(this.#_native_self,);
	}

	shape() {
		return this.#_native_self.shape(this.#_native_self,);
	}

	elements() {
		return this.#_native_self.elements(this.#_native_self,);
	}

	ndim() {
		return this.#_native_self.ndim(this.#_native_self,);
	}

	isEmpty() {
		return this.#_native_self.isEmpty(this.#_native_self,);
	}

	bytes() {
		return this.#_native_self.bytes(this.#_native_self,);
	}

	type() {
		return this.#_native_self.type(this.#_native_self,);
	}

	isSparse() {
		return this.#_native_self.isSparse(this.#_native_self,);
	}

	strides() {
		return this.#_native_self.strides(this.#_native_self,);
	}

	astype() {
		return this.#_native_self.astype(this.#_native_self,);
	}

	flatten() {
		return this.#_native_self.flatten(this.#_native_self,);
	}

	asContiguousTensor() {
		return this.#_native_self.asContiguousTensor(this.#_native_self,);
	}

	isContiguous() {
		return this.#_native_self.isContiguous(this.#_native_self,);
	}

}

const argmin = (input, axis, keepDims) => {
	return _argmin(input, axis, keepDims);
}

const any = (input, axes, keepDims) => {
	return _any(input, axes, keepDims);
}

const isnan = (tensor) => {
	return _isnan(tensor);
}

const tril = (tensor) => {
	return _tril(tensor);
}

const triu = (tensor) => {
	return _triu(tensor);
}

const where = (condition, x, y) => {
	return _where(condition, x, y);
}

const amin = (input, axes, keepDims) => {
	return _amin(input, axes, keepDims);
}

const countNonzero = (input, axes, keepDims) => {
	return _countNonzero(input, axes, keepDims);
}

const all = (input, axes, keepDims) => {
	return _all(input, axes, keepDims);
}

const transpose = (tensor, axes) => {
	return _transpose(tensor, axes);
}

const negative = (tensor) => {
	return _negative(tensor);
}

const rint = (tensor) => {
	return _rint(tensor);
}

const sigmoid = (tensor) => {
	return _sigmoid(tensor);
}

const matmul = (lhs, rhs, lhsProp, rhsProp) => {
	return _matmul(lhs, rhs, lhsProp, rhsProp);
}

const argmax = (input, axis, keepDims) => {
	return _argmax(input, axis, keepDims);
}

const mean = (input, axes, keepDims) => {
	return _mean(input, axes, keepDims);
}

const _var = (input, axes, bias, keepDims) => {
	return __var(input, axes, bias, keepDims);
}

const tile = (tensor, shape) => {
	return _tile(tensor, shape);
}

const nonzero = (tensor) => {
	return _nonzero(tensor);
}

const sqrt = (tensor) => {
	return _sqrt(tensor);
}

const ceil = (tensor) => {
	return _ceil(tensor);
}

const sign = (tensor) => {
	return _sign(tensor);
}

const sort = (input, axis, sortMode) => {
	return _sort(input, axis, sortMode);
}

const exp = (tensor) => {
	return _exp(tensor);
}

const tanh = (tensor) => {
	return _tanh(tensor);
}

const erf = (tensor) => {
	return _erf(tensor);
}

const roll = (tensor, shift, axis) => {
	return _roll(tensor, shift, axis);
}

const amax = (input, axes, keepDims) => {
	return _amax(input, axes, keepDims);
}

const sum = (input, axes, keepDims) => {
	return _sum(input, axes, keepDims);
}

const std = (input, axes, keepDims) => {
	return _std(input, axes, keepDims);
}

const full = (dims, val, type) => {
	return _full(dims, val, type);
}

const identity = (dim, type) => {
	return _identity(dim, type);
}

const flip = (tensor, dim) => {
	return _flip(tensor, dim);
}

const isinf = (tensor) => {
	return _isinf(tensor);
}

const log = (tensor) => {
	return _log(tensor);
}

const cos = (tensor) => {
	return _cos(tensor);
}

const clip = (tensor, low, high) => {
	return _clip(tensor, low, high);
}

const minimum = (lhs, rhs) => {
	return _minimum(lhs, rhs);
}

const arange = (start, end, step, type) => {
	return _arange(start, end, step, type);
}

const iota = (dims, tileDims, type) => {
	return _iota(dims, tileDims, type);
}

const reshape = (tensor, shape) => {
	return _reshape(tensor, shape);
}

const logicalNot = (tensor) => {
	return _logicalNot(tensor);
}

const maximum = (lhs, rhs) => {
	return _maximum(lhs, rhs);
}

const power = (lhs, rhs) => {
	return _power(lhs, rhs);
}

const cumsum = (input, axis) => {
	return _cumsum(input, axis);
}

const median = (input, axes, keepDims) => {
	return _median(input, axes, keepDims);
}

const sin = (tensor) => {
	return _sin(tensor);
}

const norm = (input, axes, p, keepDims) => {
	return _norm(input, axes, p, keepDims);
}

const concatenate = (tensors, axis) => {
	return _concatenate(tensors, axis);
}

const log1p = (tensor) => {
	return _log1p(tensor);
}

const floor = (tensor) => {
	return _floor(tensor);
}

const absolute = (tensor) => {
	return _absolute(tensor);
}

const neq = (lhs, rhs) => {
	return _neq(lhs, rhs);
}

const bitwiseOr = (lhs, rhs) => {
	return _bitwiseOr(lhs, rhs);
}

const greaterThan = (lhs, rhs) => {
	return _greaterThan(lhs, rhs);
}

const add = (lhs, rhs) => {
	return _add(lhs, rhs);
}

const bitwiseAnd = (lhs, rhs) => {
	return _bitwiseAnd(lhs, rhs);
}

const greaterThanEqual = (lhs, rhs) => {
	return _greaterThanEqual(lhs, rhs);
}

const div = (lhs, rhs) => {
	return _div(lhs, rhs);
}

const lShift = (lhs, rhs) => {
	return _lShift(lhs, rhs);
}

const logicalOr = (lhs, rhs) => {
	return _logicalOr(lhs, rhs);
}

const rShift = (lhs, rhs) => {
	return _rShift(lhs, rhs);
}

const mul = (lhs, rhs) => {
	return _mul(lhs, rhs);
}

const logicalAnd = (lhs, rhs) => {
	return _logicalAnd(lhs, rhs);
}

const eq = (lhs, rhs) => {
	return _eq(lhs, rhs);
}

const mod = (lhs, rhs) => {
	return _mod(lhs, rhs);
}

const lessThan = (lhs, rhs) => {
	return _lessThan(lhs, rhs);
}

const lessThanEqual = (lhs, rhs) => {
	return _lessThanEqual(lhs, rhs);
}

const bitwiseXor = (lhs, rhs) => {
	return _bitwiseXor(lhs, rhs);
}

const sub = (lhs, rhs) => {
	return _sub(lhs, rhs);
}

const init = () => {
	return _init();
}

const bytesUsed = () => {
	return _bytesUsed();
}

const setRowMajor = () => {
	return _setRowMajor();
}

const setColMajor = () => {
	return _setColMajor();
}

const isRowMajor = () => {
	return _isRowMajor();
}

const isColMajor = () => {
	return _isColMajor();
}

const dtypeFloat32 = () => {
	return _dtypeFloat32();
}

const dtypeFloat64 = () => {
	return _dtypeFloat64();
}

const dtypeBoolInt8 = () => {
	return _dtypeBoolInt8();
}

const dtypeInt16 = () => {
	return _dtypeInt16();
}

const dtypeInt32 = () => {
	return _dtypeInt32();
}

const dtypeInt64 = () => {
	return _dtypeInt64();
}

const dtypeUint8 = () => {
	return _dtypeUint8();
}

const dtypeUint16 = () => {
	return _dtypeUint16();
}

const dtypeUint32 = () => {
	return _dtypeUint32();
}

const dtypeUint64 = () => {
	return _dtypeUint64();
}

const rand = (shape) => {
	return _rand(shape);
}

const randn = (shape) => {
	return _randn(shape);
}

module.exports = {
	Tensor,
	negative,
	rint,
	sigmoid,
	amin,
	countNonzero,
	all,
	transpose,
	nonzero,
	sqrt,
	ceil,
	matmul,
	argmax,
	mean,
	_var,
	tile,
	tanh,
	erf,
	roll,
	sign,
	sort,
	exp,
	identity,
	flip,
	isinf,
	amax,
	sum,
	std,
	full,
	iota,
	reshape,
	logicalNot,
	log,
	cos,
	clip,
	minimum,
	arange,
	power,
	cumsum,
	median,
	maximum,
	sin,
	log1p,
	floor,
	absolute,
	norm,
	concatenate,
	tril,
	triu,
	where,
	argmin,
	any,
	isnan,
	logicalOr,
	rShift,
	mul,
	logicalAnd,
	eq,
	mod,
	lessThan,
	lessThanEqual,
	bitwiseXor,
	sub,
	neq,
	bitwiseOr,
	greaterThan,
	add,
	bitwiseAnd,
	greaterThanEqual,
	div,
	lShift,
	init,
	bytesUsed,
	setRowMajor,
	setColMajor,
	isRowMajor,
	isColMajor,
	dtypeFloat32,
	dtypeFloat64,
	dtypeBoolInt8,
	dtypeInt16,
	dtypeInt32,
	dtypeInt64,
	dtypeUint8,
	dtypeUint16,
	dtypeUint32,
	dtypeUint64,
	rand,
	randn
}
