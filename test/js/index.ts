// Code generated by gen-napi. DO NOT EDIT.
const {
	_Tensor,
	_log,
	_cos,
	_floor,
	_ceil,
	_erf,
	_isinf,
	_sign,
	_tile,
	_triu,
	_concatenate,
	_amax,
	_argmax,
	_mean,
	_iota,
	_sin,
	_clip,
	_norm,
	_exp,
	_arange,
	_negative,
	_logicalNot,
	_tanh,
	_roll,
	_median,
	_identity,
	_reshape,
	_sqrt,
	_sigmoid,
	_tril,
	_where,
	_sort,
	_minimum,
	_full,
	_cumsum,
	_var: __var,
	_amin,
	_nonzero,
	_log1p,
	_flip,
	_isnan,
	_power,
	_sum,
	_std,
	_transpose,
	_maximum,
	_argmin,
	_any,
	_absolute,
	_matmul,
	_countNonzero,
	_all,
	_rint,
	_bitwiseAnd,
	_sub,
	_logicalOr,
	_mod,
	_add,
	_neq,
	_lessThan,
	_rShift,
	_greaterThan,
	_mul,
	_div,
	_lShift,
	_lessThanEqual,
	_bitwiseOr,
	_bitwiseXor,
	_greaterThanEqual,
	_logicalAnd,
	_eq,
	_init,
	_bytesUsed,
	_setRowMajor,
	_setColMajor,
	_isRowMajor,
	_isColMajor,
	_dtypeFloat32,
	_dtypeFloat64,
	_dtypeBoolInt8,
	_dtypeInt16,
	_dtypeInt32,
	_dtypeInt64,
	_dtypeUint8,
	_dtypeUint16,
	_dtypeUint32,
	_dtypeUint64,
	_rand,
	_randn
} = require("../../build/Release/flashlight_napi_bindings.node")

export class Tensor {
	private #_native_self: any;

	constructor(t) {
		this.#_native_self = new _Tensor(t);
	}

	get _native_self() {
		return this.#_native_self;
	}

	rint(): Tensor {
		return this.#_native_self.rint();
	}

	matmul(rhs: Tensor, lhsProp: MatrixProperty, rhsProp: MatrixProperty): Tensor {
		return this.#_native_self.matmul(rhs.#_native_self, lhsProp, rhsProp);
	}

	countNonzero(axes: number[], keepDims: boolean): Tensor {
		return this.#_native_self.countNonzero(axes, keepDims);
	}

	all(axes: number[], keepDims: boolean): Tensor {
		return this.#_native_self.all(axes, keepDims);
	}

	erf(): Tensor {
		return this.#_native_self.erf();
	}

	isinf(): Tensor {
		return this.#_native_self.isinf();
	}

	sign(): Tensor {
		return this.#_native_self.sign();
	}

	tile(shape: number[]): Tensor {
		return this.#_native_self.tile(shape);
	}

	log(): Tensor {
		return this.#_native_self.log();
	}

	cos(): Tensor {
		return this.#_native_self.cos();
	}

	floor(): Tensor {
		return this.#_native_self.floor();
	}

	ceil(): Tensor {
		return this.#_native_self.ceil();
	}

	triu(): Tensor {
		return this.#_native_self.triu();
	}

	amax(axes: number[], keepDims: boolean): Tensor {
		return this.#_native_self.amax(axes, keepDims);
	}

	mean(axes: number[], keepDims: boolean): Tensor {
		return this.#_native_self.mean(axes, keepDims);
	}

	exp(): Tensor {
		return this.#_native_self.exp();
	}

	sin(): Tensor {
		return this.#_native_self.sin();
	}

	clip(low: Tensor, high: Tensor): Tensor {
		return this.#_native_self.clip(low.#_native_self, high.#_native_self);
	}

	norm(axes: number[], p: number, keepDims: boolean): Tensor {
		return this.#_native_self.norm(axes, p, keepDims);
	}

	roll(shift: number, axis: number): Tensor {
		return this.#_native_self.roll(shift, axis);
	}

	median(axes: number[], keepDims: boolean): Tensor {
		return this.#_native_self.median(axes, keepDims);
	}

	negative(): Tensor {
		return this.#_native_self.negative();
	}

	logicalNot(): Tensor {
		return this.#_native_self.logicalNot();
	}

	tanh(): Tensor {
		return this.#_native_self.tanh();
	}

	where(x: Tensor, y: Tensor): Tensor {
		return this.#_native_self.where(x.#_native_self, y.#_native_self);
	}

	sort(axis: number, sortMode: SortMode): Tensor {
		return this.#_native_self.sort(axis, sortMode);
	}

	reshape(shape: number[]): Tensor {
		return this.#_native_self.reshape(shape);
	}

	sqrt(): Tensor {
		return this.#_native_self.sqrt();
	}

	sigmoid(): Tensor {
		return this.#_native_self.sigmoid();
	}

	tril(): Tensor {
		return this.#_native_self.tril();
	}

	amin(axes: number[], keepDims: boolean): Tensor {
		return this.#_native_self.amin(axes, keepDims);
	}

	cumsum(axis: number): Tensor {
		return this.#_native_self.cumsum(axis);
	}

	var(axes: number[], bias: boolean, keepDims: boolean): Tensor {
		return this.#_native_self.var(axes, bias, keepDims);
	}

	power(rhs: Tensor): Tensor {
		return this.#_native_self.power(rhs.#_native_self);
	}

	sum(axes: number[], keepDims: boolean): Tensor {
		return this.#_native_self.sum(axes, keepDims);
	}

	std(axes: number[], keepDims: boolean): Tensor {
		return this.#_native_self.std(axes, keepDims);
	}

	transpose(axes: number[]): Tensor {
		return this.#_native_self.transpose(axes);
	}

	nonzero(): Tensor {
		return this.#_native_self.nonzero();
	}

	log1p(): Tensor {
		return this.#_native_self.log1p();
	}

	flip(dim: number): Tensor {
		return this.#_native_self.flip(dim);
	}

	isnan(): Tensor {
		return this.#_native_self.isnan();
	}

	absolute(): Tensor {
		return this.#_native_self.absolute();
	}

	maximum(rhs: Tensor): Tensor {
		return this.#_native_self.maximum(rhs.#_native_self);
	}

	argmin(axis: number, keepDims: boolean): Tensor {
		return this.#_native_self.argmin(axis, keepDims);
	}

	any(axes: number[], keepDims: boolean): Tensor {
		return this.#_native_self.any(axes, keepDims);
	}

	neq(rhs: Tensor): Tensor {
		return this.#_native_self.neq(rhs.#_native_self);
	}

	lessThan(rhs: Tensor): Tensor {
		return this.#_native_self.lessThan(rhs.#_native_self);
	}

	rShift(rhs: Tensor): Tensor {
		return this.#_native_self.rShift(rhs.#_native_self);
	}

	mod(rhs: Tensor): Tensor {
		return this.#_native_self.mod(rhs.#_native_self);
	}

	add(rhs: Tensor): Tensor {
		return this.#_native_self.add(rhs.#_native_self);
	}

	lShift(rhs: Tensor): Tensor {
		return this.#_native_self.lShift(rhs.#_native_self);
	}

	lessThanEqual(rhs: Tensor): Tensor {
		return this.#_native_self.lessThanEqual(rhs.#_native_self);
	}

	bitwiseOr(rhs: Tensor): Tensor {
		return this.#_native_self.bitwiseOr(rhs.#_native_self);
	}

	greaterThan(rhs: Tensor): Tensor {
		return this.#_native_self.greaterThan(rhs.#_native_self);
	}

	mul(rhs: Tensor): Tensor {
		return this.#_native_self.mul(rhs.#_native_self);
	}

	div(rhs: Tensor): Tensor {
		return this.#_native_self.div(rhs.#_native_self);
	}

	greaterThanEqual(rhs: Tensor): Tensor {
		return this.#_native_self.greaterThanEqual(rhs.#_native_self);
	}

	logicalAnd(rhs: Tensor): Tensor {
		return this.#_native_self.logicalAnd(rhs.#_native_self);
	}

	eq(rhs: Tensor): Tensor {
		return this.#_native_self.eq(rhs.#_native_self);
	}

	bitwiseXor(rhs: Tensor): Tensor {
		return this.#_native_self.bitwiseXor(rhs.#_native_self);
	}

	bitwiseAnd(rhs: Tensor): Tensor {
		return this.#_native_self.bitwiseAnd(rhs.#_native_self);
	}

	sub(rhs: Tensor): Tensor {
		return this.#_native_self.sub(rhs.#_native_self);
	}

	logicalOr(rhs: Tensor): Tensor {
		return this.#_native_self.logicalOr(rhs.#_native_self);
	}

	copy(): void {
		return this.#_native_self.copy();
	}

	shape(): void {
		return this.#_native_self.shape();
	}

	elements(): void {
		return this.#_native_self.elements();
	}

	ndim(): void {
		return this.#_native_self.ndim();
	}

	isEmpty(): void {
		return this.#_native_self.isEmpty();
	}

	bytes(): void {
		return this.#_native_self.bytes();
	}

	type(): void {
		return this.#_native_self.type();
	}

	isSparse(): void {
		return this.#_native_self.isSparse();
	}

	strides(): void {
		return this.#_native_self.strides();
	}

	astype(): void {
		return this.#_native_self.astype();
	}

	flatten(): void {
		return this.#_native_self.flatten();
	}

	asContiguousTensor(): void {
		return this.#_native_self.asContiguousTensor();
	}

	isContiguous(): void {
		return this.#_native_self.isContiguous();
	}

	toFloat32Array(): Float32Array {
		return this.#_native_self.toFloat32Array();
	}

	toFloat64Array(): Float64Array {
		return this.#_native_self.toFloat64Array();
	}

	toBoolInt8Array(): Int8Array {
		return this.#_native_self.toBoolInt8Array();
	}

	toInt16Array(): Int16Array {
		return this.#_native_self.toInt16Array();
	}

	toInt32Array(): Int32Array {
		return this.#_native_self.toInt32Array();
	}

	toInt64Array(): BigInt64Array {
		return this.#_native_self.toInt64Array();
	}

	toUint8Array(): Uint8Array {
		return this.#_native_self.toUint8Array();
	}

	toUint16Array(): Uint16Array {
		return this.#_native_self.toUint16Array();
	}

	toUint32Array(): Uint32Array {
		return this.#_native_self.toUint32Array();
	}

	toUint64Array(): BigUint64Array {
		return this.#_native_self.toUint64Array();
	}

	toFloat32Scalar(): number {
		return this.#_native_self.toFloat32Scalar();
	}

	toFloat64Scalar(): number {
		return this.#_native_self.toFloat64Scalar();
	}

	toBoolInt8Scalar(): number {
		return this.#_native_self.toBoolInt8Scalar();
	}

	toInt16Scalar(): number {
		return this.#_native_self.toInt16Scalar();
	}

	toInt32Scalar(): number {
		return this.#_native_self.toInt32Scalar();
	}

	toInt64Scalar(): bigint {
		return this.#_native_self.toInt64Scalar();
	}

	toUint8Scalar(): number {
		return this.#_native_self.toUint8Scalar();
	}

	toUint16Scalar(): number {
		return this.#_native_self.toUint16Scalar();
	}

	toUint32Scalar(): number {
		return this.#_native_self.toUint32Scalar();
	}

	toUint64Scalar(): bigint {
		return this.#_native_self.toUint64Scalar();
	}

	eval(): void {
		return this.#_native_self.eval();
	}

	dispose(): void {
		return this.#_native_self.dispose();
	}

}

const sqrt = (tensor: Tensor) => {
	return _sqrt(tensor._native_self);
}

const sigmoid = (tensor: Tensor) => {
	return _sigmoid(tensor._native_self);
}

const tril = (tensor: Tensor) => {
	return _tril(tensor._native_self);
}

const where = (condition: Tensor, x: Tensor, y: Tensor) => {
	return _where(condition._native_self, x._native_self, y._native_self);
}

const sort = (input: Tensor, axis: number, sortMode: SortMode) => {
	return _sort(input._native_self, axis, sortMode);
}

const minimum = (lhs: Tensor, rhs: Tensor) => {
	return _minimum(lhs._native_self, rhs._native_self);
}

const full = (dims: number[], val: T, type: number) => {
	return _full(dims, val, type);
}

const reshape = (tensor: Tensor, shape: number[]) => {
	return _reshape(tensor._native_self, shape);
}

const _var = (input: Tensor, axes: number[], bias: boolean, keepDims: boolean) => {
	return __var(input._native_self, axes, bias, keepDims);
}

const amin = (input: Tensor, axes: number[], keepDims: boolean) => {
	return _amin(input._native_self, axes, keepDims);
}

const cumsum = (input: Tensor, axis: number) => {
	return _cumsum(input._native_self, axis);
}

const log1p = (tensor: Tensor) => {
	return _log1p(tensor._native_self);
}

const flip = (tensor: Tensor, dim: number) => {
	return _flip(tensor._native_self, dim);
}

const isnan = (tensor: Tensor) => {
	return _isnan(tensor._native_self);
}

const power = (lhs: Tensor, rhs: Tensor) => {
	return _power(lhs._native_self, rhs._native_self);
}

const sum = (input: Tensor, axes: number[], keepDims: boolean) => {
	return _sum(input._native_self, axes, keepDims);
}

const std = (input: Tensor, axes: number[], keepDims: boolean) => {
	return _std(input._native_self, axes, keepDims);
}

const transpose = (tensor: Tensor, axes: number[]) => {
	return _transpose(tensor._native_self, axes);
}

const nonzero = (tensor: Tensor) => {
	return _nonzero(tensor._native_self);
}

const argmin = (input: Tensor, axis: number, keepDims: boolean) => {
	return _argmin(input._native_self, axis, keepDims);
}

const any = (input: Tensor, axes: number[], keepDims: boolean) => {
	return _any(input._native_self, axes, keepDims);
}

const absolute = (tensor: Tensor) => {
	return _absolute(tensor._native_self);
}

const maximum = (lhs: Tensor, rhs: Tensor) => {
	return _maximum(lhs._native_self, rhs._native_self);
}

const countNonzero = (input: Tensor, axes: number[], keepDims: boolean) => {
	return _countNonzero(input._native_self, axes, keepDims);
}

const all = (input: Tensor, axes: number[], keepDims: boolean) => {
	return _all(input._native_self, axes, keepDims);
}

const rint = (tensor: Tensor) => {
	return _rint(tensor._native_self);
}

const matmul = (lhs: Tensor, rhs: Tensor, lhsProp: MatrixProperty, rhsProp: MatrixProperty) => {
	return _matmul(lhs._native_self, rhs._native_self, lhsProp, rhsProp);
}

const cos = (tensor: Tensor) => {
	return _cos(tensor._native_self);
}

const floor = (tensor: Tensor) => {
	return _floor(tensor._native_self);
}

const ceil = (tensor: Tensor) => {
	return _ceil(tensor._native_self);
}

const erf = (tensor: Tensor) => {
	return _erf(tensor._native_self);
}

const isinf = (tensor: Tensor) => {
	return _isinf(tensor._native_self);
}

const sign = (tensor: Tensor) => {
	return _sign(tensor._native_self);
}

const tile = (tensor: Tensor, shape: number[]) => {
	return _tile(tensor._native_self, shape);
}

const log = (tensor: Tensor) => {
	return _log(tensor._native_self);
}

const triu = (tensor: Tensor) => {
	return _triu(tensor._native_self);
}

const amax = (input: Tensor, axes: number[], keepDims: boolean) => {
	return _amax(input._native_self, axes, keepDims);
}

const argmax = (input: Tensor, axis: number, keepDims: boolean) => {
	return _argmax(input._native_self, axis, keepDims);
}

const mean = (input: Tensor, axes: number[], keepDims: boolean) => {
	return _mean(input._native_self, axes, keepDims);
}

const iota = (dims: number[], tileDims: number[], type: number) => {
	return _iota(dims, tileDims, type);
}

const concatenate = (tensors: Tensor[], axis: number) => {
	return _concatenate(tensors, axis);
}

const clip = (tensor: Tensor, low: Tensor, high: Tensor) => {
	return _clip(tensor._native_self, low._native_self, high._native_self);
}

const norm = (input: Tensor, axes: number[], p: number, keepDims: boolean) => {
	return _norm(input._native_self, axes, p, keepDims);
}

const exp = (tensor: Tensor) => {
	return _exp(tensor._native_self);
}

const sin = (tensor: Tensor) => {
	return _sin(tensor._native_self);
}

const negative = (tensor: Tensor) => {
	return _negative(tensor._native_self);
}

const logicalNot = (tensor: Tensor) => {
	return _logicalNot(tensor._native_self);
}

const tanh = (tensor: Tensor) => {
	return _tanh(tensor._native_self);
}

const roll = (tensor: Tensor, shift: number, axis: number) => {
	return _roll(tensor._native_self, shift, axis);
}

const median = (input: Tensor, axes: number[], keepDims: boolean) => {
	return _median(input._native_self, axes, keepDims);
}

const identity = (dim: number, type: number) => {
	return _identity(dim, type);
}

const arange = (start: T, end: T, step: T, type: number) => {
	return _arange(start, end, step, type);
}

const mod = (lhs: Tensor, rhs: Tensor) => {
	return _mod(lhs._native_self, rhs._native_self);
}

const add = (lhs: Tensor, rhs: Tensor) => {
	return _add(lhs._native_self, rhs._native_self);
}

const neq = (lhs: Tensor, rhs: Tensor) => {
	return _neq(lhs._native_self, rhs._native_self);
}

const lessThan = (lhs: Tensor, rhs: Tensor) => {
	return _lessThan(lhs._native_self, rhs._native_self);
}

const rShift = (lhs: Tensor, rhs: Tensor) => {
	return _rShift(lhs._native_self, rhs._native_self);
}

const greaterThan = (lhs: Tensor, rhs: Tensor) => {
	return _greaterThan(lhs._native_self, rhs._native_self);
}

const mul = (lhs: Tensor, rhs: Tensor) => {
	return _mul(lhs._native_self, rhs._native_self);
}

const div = (lhs: Tensor, rhs: Tensor) => {
	return _div(lhs._native_self, rhs._native_self);
}

const lShift = (lhs: Tensor, rhs: Tensor) => {
	return _lShift(lhs._native_self, rhs._native_self);
}

const lessThanEqual = (lhs: Tensor, rhs: Tensor) => {
	return _lessThanEqual(lhs._native_self, rhs._native_self);
}

const bitwiseOr = (lhs: Tensor, rhs: Tensor) => {
	return _bitwiseOr(lhs._native_self, rhs._native_self);
}

const bitwiseXor = (lhs: Tensor, rhs: Tensor) => {
	return _bitwiseXor(lhs._native_self, rhs._native_self);
}

const greaterThanEqual = (lhs: Tensor, rhs: Tensor) => {
	return _greaterThanEqual(lhs._native_self, rhs._native_self);
}

const logicalAnd = (lhs: Tensor, rhs: Tensor) => {
	return _logicalAnd(lhs._native_self, rhs._native_self);
}

const eq = (lhs: Tensor, rhs: Tensor) => {
	return _eq(lhs._native_self, rhs._native_self);
}

const bitwiseAnd = (lhs: Tensor, rhs: Tensor) => {
	return _bitwiseAnd(lhs._native_self, rhs._native_self);
}

const sub = (lhs: Tensor, rhs: Tensor) => {
	return _sub(lhs._native_self, rhs._native_self);
}

const logicalOr = (lhs: Tensor, rhs: Tensor) => {
	return _logicalOr(lhs._native_self, rhs._native_self);
}

const init = () => {
	return _init();
}

const bytesUsed = ():  => {
	return _bytesUsed();
}

const setRowMajor = () => {
	return _setRowMajor();
}

const setColMajor = () => {
	return _setColMajor();
}

const isRowMajor = (): boolean => {
	return _isRowMajor();
}

const isColMajor = (): boolean => {
	return _isColMajor();
}

const dtypeFloat32 = (): number => {
	return _dtypeFloat32();
}

const dtypeFloat64 = (): number => {
	return _dtypeFloat64();
}

const dtypeBoolInt8 = (): number => {
	return _dtypeBoolInt8();
}

const dtypeInt16 = (): number => {
	return _dtypeInt16();
}

const dtypeInt32 = (): number => {
	return _dtypeInt32();
}

const dtypeInt64 = (): number => {
	return _dtypeInt64();
}

const dtypeUint8 = (): number => {
	return _dtypeUint8();
}

const dtypeUint16 = (): number => {
	return _dtypeUint16();
}

const dtypeUint32 = (): number => {
	return _dtypeUint32();
}

const dtypeUint64 = (): number => {
	return _dtypeUint64();
}

const rand = (shape): Tensor {
): Tensor => {
	return _rand(shape);
}

const randn = (shape): Tensor {
): Tensor => {
	return _randn(shape);
}

