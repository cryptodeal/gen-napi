// Code generated by gen-napi. DO NOT EDIT.
const {
  _Tensor,
  _negative,
  _rint,
  _power,
  _flip,
  _roll,
  _isnan,
  _arange,
  _transpose,
  _exp,
  _ceil,
  _erf,
  _argmin,
  _norm,
  _log,
  _cos,
  _tanh,
  _absolute,
  _sigmoid,
  _full,
  _identity,
  _iota,
  _reshape,
  _maximum,
  _amax,
  _var: __var,
  _sin,
  _sqrt,
  _clip,
  _sign,
  _triu,
  _argmax,
  _mean,
  _all,
  _nonzero,
  _logicalNot,
  _isinf,
  _sort,
  _amin,
  _countNonzero,
  _tile,
  _minimum,
  _matmul,
  _sum,
  _cumsum,
  _median,
  _std,
  _any,
  _concatenate,
  _log1p,
  _floor,
  _tril,
  _where,
  _neq,
  _add,
  _div,
  _logicalAnd,
  _logicalOr,
  _lShift,
  _eq,
  _bitwiseXor,
  _mul,
  _lessThanEqual,
  _greaterThanEqual,
  _bitwiseAnd,
  _rShift,
  _mod,
  _bitwiseOr,
  _greaterThan,
  _sub,
  _lessThan,
  _init,
  _bytesUsed,
  _setRowMajor,
  _setColMajor,
  _isRowMajor,
  _isColMajor,
  _dtypeFloat32,
  _dtypeFloat64,
  _dtypeBoolInt8,
  _dtypeInt16,
  _dtypeInt32,
  _dtypeInt64,
  _dtypeUint8,
  _dtypeUint16,
  _dtypeUint32,
  _dtypeUint64,
  _rand,
  _randn
} = require('../../build/Release/flashlight_napi_bindings.node')

export class Tensor {
  private #_native_self: any

  constructor(t) {
    this.#_native_self = new _Tensor(t)
  }

  get _native_self() {
    return this.#_native_self
  }

  transpose(axes: number[]): Tensor {
    return this.#_native_self.transpose(axes)
  }

  exp(): Tensor {
    return this.#_native_self.exp()
  }

  ceil(): Tensor {
    return this.#_native_self.ceil()
  }

  erf(): Tensor {
    return this.#_native_self.erf()
  }

  flip(dim: number): Tensor {
    return this.#_native_self.flip(dim)
  }

  roll(shift: number, axis: number): Tensor {
    return this.#_native_self.roll(shift, axis)
  }

  isnan(): Tensor {
    return this.#_native_self.isnan()
  }

  argmin(axis: number, keepDims: boolean): Tensor {
    return this.#_native_self.argmin(axis, keepDims)
  }

  cos(): Tensor {
    return this.#_native_self.cos()
  }

  tanh(): Tensor {
    return this.#_native_self.tanh()
  }

  absolute(): Tensor {
    return this.#_native_self.absolute()
  }

  sigmoid(): Tensor {
    return this.#_native_self.sigmoid()
  }

  norm(axes: number[], p: number, keepDims: boolean): Tensor {
    return this.#_native_self.norm(axes, p, keepDims)
  }

  log(): Tensor {
    return this.#_native_self.log()
  }

  reshape(shape: number[]): Tensor {
    return this.#_native_self.reshape(shape)
  }

  sqrt(): Tensor {
    return this.#_native_self.sqrt()
  }

  clip(low: Tensor, high: Tensor): Tensor {
    return this.#_native_self.clip(low.#_native_self, high.#_native_self)
  }

  sign(): Tensor {
    return this.#_native_self.sign()
  }

  triu(): Tensor {
    return this.#_native_self.triu()
  }

  maximum(rhs: Tensor): Tensor {
    return this.#_native_self.maximum(rhs.#_native_self)
  }

  amax(axes: number[], keepDims: boolean): Tensor {
    return this.#_native_self.amax(axes, keepDims)
  }

  var(axes: number[], bias: boolean, keepDims: boolean): Tensor {
    return this.#_native_self.var(axes, bias, keepDims)
  }

  sin(): Tensor {
    return this.#_native_self.sin()
  }

  logicalNot(): Tensor {
    return this.#_native_self.logicalNot()
  }

  isinf(): Tensor {
    return this.#_native_self.isinf()
  }

  sort(axis: number, sortMode: SortMode): Tensor {
    return this.#_native_self.sort(axis, sortMode)
  }

  amin(axes: number[], keepDims: boolean): Tensor {
    return this.#_native_self.amin(axes, keepDims)
  }

  mean(axes: number[], keepDims: boolean): Tensor {
    return this.#_native_self.mean(axes, keepDims)
  }

  all(axes: number[], keepDims: boolean): Tensor {
    return this.#_native_self.all(axes, keepDims)
  }

  nonzero(): Tensor {
    return this.#_native_self.nonzero()
  }

  matmul(rhs: Tensor, lhsProp: MatrixProperty, rhsProp: MatrixProperty): Tensor {
    return this.#_native_self.matmul(rhs.#_native_self, lhsProp, rhsProp)
  }

  sum(axes: number[], keepDims: boolean): Tensor {
    return this.#_native_self.sum(axes, keepDims)
  }

  cumsum(axis: number): Tensor {
    return this.#_native_self.cumsum(axis)
  }

  countNonzero(axes: number[], keepDims: boolean): Tensor {
    return this.#_native_self.countNonzero(axes, keepDims)
  }

  tile(shape: number[]): Tensor {
    return this.#_native_self.tile(shape)
  }

  log1p(): Tensor {
    return this.#_native_self.log1p()
  }

  floor(): Tensor {
    return this.#_native_self.floor()
  }

  tril(): Tensor {
    return this.#_native_self.tril()
  }

  where(x: Tensor, y: Tensor): Tensor {
    return this.#_native_self.where(x.#_native_self, y.#_native_self)
  }

  median(axes: number[], keepDims: boolean): Tensor {
    return this.#_native_self.median(axes, keepDims)
  }

  std(axes: number[], keepDims: boolean): Tensor {
    return this.#_native_self.std(axes, keepDims)
  }

  any(axes: number[], keepDims: boolean): Tensor {
    return this.#_native_self.any(axes, keepDims)
  }

  rint(): Tensor {
    return this.#_native_self.rint()
  }

  power(rhs: Tensor): Tensor {
    return this.#_native_self.power(rhs.#_native_self)
  }

  negative(): Tensor {
    return this.#_native_self.negative()
  }

  bitwiseOr(rhs: Tensor): Tensor {
    return this.#_native_self.bitwiseOr(rhs.#_native_self)
  }

  greaterThan(rhs: Tensor): Tensor {
    return this.#_native_self.greaterThan(rhs.#_native_self)
  }

  sub(rhs: Tensor): Tensor {
    return this.#_native_self.sub(rhs.#_native_self)
  }

  lessThan(rhs: Tensor): Tensor {
    return this.#_native_self.lessThan(rhs.#_native_self)
  }

  neq(rhs: Tensor): Tensor {
    return this.#_native_self.neq(rhs.#_native_self)
  }

  add(rhs: Tensor): Tensor {
    return this.#_native_self.add(rhs.#_native_self)
  }

  div(rhs: Tensor): Tensor {
    return this.#_native_self.div(rhs.#_native_self)
  }

  logicalAnd(rhs: Tensor): Tensor {
    return this.#_native_self.logicalAnd(rhs.#_native_self)
  }

  logicalOr(rhs: Tensor): Tensor {
    return this.#_native_self.logicalOr(rhs.#_native_self)
  }

  lShift(rhs: Tensor): Tensor {
    return this.#_native_self.lShift(rhs.#_native_self)
  }

  eq(rhs: Tensor): Tensor {
    return this.#_native_self.eq(rhs.#_native_self)
  }

  bitwiseXor(rhs: Tensor): Tensor {
    return this.#_native_self.bitwiseXor(rhs.#_native_self)
  }

  mul(rhs: Tensor): Tensor {
    return this.#_native_self.mul(rhs.#_native_self)
  }

  lessThanEqual(rhs: Tensor): Tensor {
    return this.#_native_self.lessThanEqual(rhs.#_native_self)
  }

  greaterThanEqual(rhs: Tensor): Tensor {
    return this.#_native_self.greaterThanEqual(rhs.#_native_self)
  }

  bitwiseAnd(rhs: Tensor): Tensor {
    return this.#_native_self.bitwiseAnd(rhs.#_native_self)
  }

  rShift(rhs: Tensor): Tensor {
    return this.#_native_self.rShift(rhs.#_native_self)
  }

  mod(rhs: Tensor): Tensor {
    return this.#_native_self.mod(rhs.#_native_self)
  }

  copy(): void {
    return this.#_native_self.copy()
  }

  shape(): void {
    return this.#_native_self.shape()
  }

  elements(): void {
    return this.#_native_self.elements()
  }

  ndim(): void {
    return this.#_native_self.ndim()
  }

  isEmpty(): void {
    return this.#_native_self.isEmpty()
  }

  bytes(): void {
    return this.#_native_self.bytes()
  }

  type(): void {
    return this.#_native_self.type()
  }

  isSparse(): void {
    return this.#_native_self.isSparse()
  }

  strides(): void {
    return this.#_native_self.strides()
  }

  astype(): void {
    return this.#_native_self.astype()
  }

  flatten(): void {
    return this.#_native_self.flatten()
  }

  asContiguousTensor(): void {
    return this.#_native_self.asContiguousTensor()
  }

  isContiguous(): void {
    return this.#_native_self.isContiguous()
  }

  toFloat32Array(): Float32Array {
    return this.#_native_self.toFloat32Array()
  }

  toFloat64Array(): Float64Array {
    return this.#_native_self.toFloat64Array()
  }

  toBoolInt8Array(): Int8Array {
    return this.#_native_self.toBoolInt8Array()
  }

  toInt16Array(): Int16Array {
    return this.#_native_self.toInt16Array()
  }

  toInt32Array(): Int32Array {
    return this.#_native_self.toInt32Array()
  }

  toInt64Array(): BigInt64Array {
    return this.#_native_self.toInt64Array()
  }

  toUint8Array(): Uint8Array {
    return this.#_native_self.toUint8Array()
  }

  toUint16Array(): Uint16Array {
    return this.#_native_self.toUint16Array()
  }

  toUint32Array(): Uint32Array {
    return this.#_native_self.toUint32Array()
  }

  toUint64Array(): BigUint64Array {
    return this.#_native_self.toUint64Array()
  }

  toFloat32Scalar(): number {
    return this.#_native_self.toFloat32Scalar()
  }

  toFloat64Scalar(): number {
    return this.#_native_self.toFloat64Scalar()
  }

  toBoolInt8Scalar(): number {
    return this.#_native_self.toBoolInt8Scalar()
  }

  toInt16Scalar(): number {
    return this.#_native_self.toInt16Scalar()
  }

  toInt32Scalar(): number {
    return this.#_native_self.toInt32Scalar()
  }

  toInt64Scalar(): bigint {
    return this.#_native_self.toInt64Scalar()
  }

  toUint8Scalar(): number {
    return this.#_native_self.toUint8Scalar()
  }

  toUint16Scalar(): number {
    return this.#_native_self.toUint16Scalar()
  }

  toUint32Scalar(): number {
    return this.#_native_self.toUint32Scalar()
  }

  toUint64Scalar(): bigint {
    return this.#_native_self.toUint64Scalar()
  }

  eval(): void {
    return this.#_native_self.eval()
  }

  dispose(): void {
    return this.#_native_self.dispose()
  }
}

export const concatenate = (tensors: Tensor[], axis: number) => {
  return _concatenate(tensors, axis)
}

export const log1p = (tensor: Tensor) => {
  return _log1p(tensor._native_self)
}

export const floor = (tensor: Tensor) => {
  return _floor(tensor._native_self)
}

export const tril = (tensor: Tensor) => {
  return _tril(tensor._native_self)
}

export const where = (condition: Tensor, x: Tensor, y: Tensor) => {
  return _where(condition._native_self, x._native_self, y._native_self)
}

export const median = (input: Tensor, axes: number[], keepDims: boolean) => {
  return _median(input._native_self, axes, keepDims)
}

export const std = (input: Tensor, axes: number[], keepDims: boolean) => {
  return _std(input._native_self, axes, keepDims)
}

export const any = (input: Tensor, axes: number[], keepDims: boolean) => {
  return _any(input._native_self, axes, keepDims)
}

export const negative = (tensor: Tensor) => {
  return _negative(tensor._native_self)
}

export const rint = (tensor: Tensor) => {
  return _rint(tensor._native_self)
}

export const power = (lhs: Tensor, rhs: Tensor) => {
  return _power(lhs._native_self, rhs._native_self)
}

export const arange = (start: T, end: T, step: T, type: number) => {
  return _arange(start, end, step, type)
}

export const transpose = (tensor: Tensor, axes: number[]) => {
  return _transpose(tensor._native_self, axes)
}

export const exp = (tensor: Tensor) => {
  return _exp(tensor._native_self)
}

export const ceil = (tensor: Tensor) => {
  return _ceil(tensor._native_self)
}

export const erf = (tensor: Tensor) => {
  return _erf(tensor._native_self)
}

export const flip = (tensor: Tensor, dim: number) => {
  return _flip(tensor._native_self, dim)
}

export const roll = (tensor: Tensor, shift: number, axis: number) => {
  return _roll(tensor._native_self, shift, axis)
}

export const isnan = (tensor: Tensor) => {
  return _isnan(tensor._native_self)
}

export const argmin = (input: Tensor, axis: number, keepDims: boolean) => {
  return _argmin(input._native_self, axis, keepDims)
}

export const log = (tensor: Tensor) => {
  return _log(tensor._native_self)
}

export const cos = (tensor: Tensor) => {
  return _cos(tensor._native_self)
}

export const tanh = (tensor: Tensor) => {
  return _tanh(tensor._native_self)
}

export const absolute = (tensor: Tensor) => {
  return _absolute(tensor._native_self)
}

export const sigmoid = (tensor: Tensor) => {
  return _sigmoid(tensor._native_self)
}

export const norm = (input: Tensor, axes: number[], p: number, keepDims: boolean) => {
  return _norm(input._native_self, axes, p, keepDims)
}

export const full = (dims: number[], val: T, type: number) => {
  return _full(dims, val, type)
}

export const identity = (dim: number, type: number) => {
  return _identity(dim, type)
}

export const iota = (dims: number[], tileDims: number[], type: number) => {
  return _iota(dims, tileDims, type)
}

export const reshape = (tensor: Tensor, shape: number[]) => {
  return _reshape(tensor._native_self, shape)
}

export const sin = (tensor: Tensor) => {
  return _sin(tensor._native_self)
}

export const sqrt = (tensor: Tensor) => {
  return _sqrt(tensor._native_self)
}

export const clip = (tensor: Tensor, low: Tensor, high: Tensor) => {
  return _clip(tensor._native_self, low._native_self, high._native_self)
}

export const sign = (tensor: Tensor) => {
  return _sign(tensor._native_self)
}

export const triu = (tensor: Tensor) => {
  return _triu(tensor._native_self)
}

export const maximum = (lhs: Tensor, rhs: Tensor) => {
  return _maximum(lhs._native_self, rhs._native_self)
}

export const amax = (input: Tensor, axes: number[], keepDims: boolean) => {
  return _amax(input._native_self, axes, keepDims)
}

export const _var = (input: Tensor, axes: number[], bias: boolean, keepDims: boolean) => {
  return __var(input._native_self, axes, bias, keepDims)
}

export const nonzero = (tensor: Tensor) => {
  return _nonzero(tensor._native_self)
}

export const logicalNot = (tensor: Tensor) => {
  return _logicalNot(tensor._native_self)
}

export const isinf = (tensor: Tensor) => {
  return _isinf(tensor._native_self)
}

export const sort = (input: Tensor, axis: number, sortMode: SortMode) => {
  return _sort(input._native_self, axis, sortMode)
}

export const amin = (input: Tensor, axes: number[], keepDims: boolean) => {
  return _amin(input._native_self, axes, keepDims)
}

export const argmax = (input: Tensor, axis: number, keepDims: boolean) => {
  return _argmax(input._native_self, axis, keepDims)
}

export const mean = (input: Tensor, axes: number[], keepDims: boolean) => {
  return _mean(input._native_self, axes, keepDims)
}

export const all = (input: Tensor, axes: number[], keepDims: boolean) => {
  return _all(input._native_self, axes, keepDims)
}

export const tile = (tensor: Tensor, shape: number[]) => {
  return _tile(tensor._native_self, shape)
}

export const minimum = (lhs: Tensor, rhs: Tensor) => {
  return _minimum(lhs._native_self, rhs._native_self)
}

export const matmul = (
  lhs: Tensor,
  rhs: Tensor,
  lhsProp: MatrixProperty,
  rhsProp: MatrixProperty
) => {
  return _matmul(lhs._native_self, rhs._native_self, lhsProp, rhsProp)
}

export const sum = (input: Tensor, axes: number[], keepDims: boolean) => {
  return _sum(input._native_self, axes, keepDims)
}

export const cumsum = (input: Tensor, axis: number) => {
  return _cumsum(input._native_self, axis)
}

export const countNonzero = (input: Tensor, axes: number[], keepDims: boolean) => {
  return _countNonzero(input._native_self, axes, keepDims)
}

export const greaterThanEqual = (lhs: Tensor, rhs: Tensor) => {
  return _greaterThanEqual(lhs._native_self, rhs._native_self)
}

export const bitwiseAnd = (lhs: Tensor, rhs: Tensor) => {
  return _bitwiseAnd(lhs._native_self, rhs._native_self)
}

export const rShift = (lhs: Tensor, rhs: Tensor) => {
  return _rShift(lhs._native_self, rhs._native_self)
}

export const mod = (lhs: Tensor, rhs: Tensor) => {
  return _mod(lhs._native_self, rhs._native_self)
}

export const lessThanEqual = (lhs: Tensor, rhs: Tensor) => {
  return _lessThanEqual(lhs._native_self, rhs._native_self)
}

export const greaterThan = (lhs: Tensor, rhs: Tensor) => {
  return _greaterThan(lhs._native_self, rhs._native_self)
}

export const sub = (lhs: Tensor, rhs: Tensor) => {
  return _sub(lhs._native_self, rhs._native_self)
}

export const lessThan = (lhs: Tensor, rhs: Tensor) => {
  return _lessThan(lhs._native_self, rhs._native_self)
}

export const bitwiseOr = (lhs: Tensor, rhs: Tensor) => {
  return _bitwiseOr(lhs._native_self, rhs._native_self)
}

export const add = (lhs: Tensor, rhs: Tensor) => {
  return _add(lhs._native_self, rhs._native_self)
}

export const div = (lhs: Tensor, rhs: Tensor) => {
  return _div(lhs._native_self, rhs._native_self)
}

export const logicalAnd = (lhs: Tensor, rhs: Tensor) => {
  return _logicalAnd(lhs._native_self, rhs._native_self)
}

export const logicalOr = (lhs: Tensor, rhs: Tensor) => {
  return _logicalOr(lhs._native_self, rhs._native_self)
}

export const lShift = (lhs: Tensor, rhs: Tensor) => {
  return _lShift(lhs._native_self, rhs._native_self)
}

export const neq = (lhs: Tensor, rhs: Tensor) => {
  return _neq(lhs._native_self, rhs._native_self)
}

export const bitwiseXor = (lhs: Tensor, rhs: Tensor) => {
  return _bitwiseXor(lhs._native_self, rhs._native_self)
}

export const mul = (lhs: Tensor, rhs: Tensor) => {
  return _mul(lhs._native_self, rhs._native_self)
}

export const eq = (lhs: Tensor, rhs: Tensor) => {
  return _eq(lhs._native_self, rhs._native_self)
}

export const init = () => {
  return _init()
}

export const bytesUsed = (): bigint => {
  return _bytesUsed()
}

export const setRowMajor = () => {
  return _setRowMajor()
}

export const setColMajor = () => {
  return _setColMajor()
}

export const isRowMajor = (): boolean => {
  return _isRowMajor()
}

export const isColMajor = (): boolean => {
  return _isColMajor()
}

export const dtypeFloat32 = (): number => {
  return _dtypeFloat32()
}

export const dtypeFloat64 = (): number => {
  return _dtypeFloat64()
}

export const dtypeBoolInt8 = (): number => {
  return _dtypeBoolInt8()
}

export const dtypeInt16 = (): number => {
  return _dtypeInt16()
}

export const dtypeInt32 = (): number => {
  return _dtypeInt32()
}

export const dtypeInt64 = (): number => {
  return _dtypeInt64()
}

export const dtypeUint8 = (): number => {
  return _dtypeUint8()
}

export const dtypeUint16 = (): number => {
  return _dtypeUint16()
}

export const dtypeUint32 = (): number => {
  return _dtypeUint32()
}

export const dtypeUint64 = (): number => {
  return _dtypeUint64()
}

export const rand = (shape: number[]): Tensor => {
  return _rand(shape)
}

export const randn = (shape: number[]): Tensor => {
  return _randn(shape)
}
