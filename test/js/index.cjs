// Code generated by gen-napi. DO NOT EDIT.
const {
  _Tensor,
  _sqrt,
  _sigmoid,
  _power,
  _mean,
  _sort,
  _matmul,
  _var: __var,
  _all,
  _transpose,
  _floor,
  _sign,
  _triu,
  _where,
  _maximum,
  _argmax,
  _full,
  _tile,
  _nonzero,
  _log1p,
  _negative,
  _log,
  _erf,
  _cumsum,
  _flip,
  _clip,
  _amin,
  _amax,
  _iota,
  _exp,
  _ceil,
  _rint,
  _countNonzero,
  _std,
  _norm,
  _arange,
  _reshape,
  _roll,
  _sum,
  _isnan,
  _median,
  _any,
  _identity,
  _logicalNot,
  _sin,
  _tanh,
  _tril,
  _minimum,
  _argmin,
  _concatenate,
  _cos,
  _absolute,
  _isinf,
  _div,
  _neq,
  _greaterThanEqual,
  _rShift,
  _add,
  _logicalAnd,
  _greaterThan,
  _bitwiseAnd,
  _lessThanEqual,
  _bitwiseXor,
  _mul,
  _lessThan,
  _logicalOr,
  _mod,
  _sub,
  _eq,
  _lShift,
  _bitwiseOr,
  _init,
  _bytesUsed,
  _setRowMajor,
  _setColMajor,
  _isRowMajor,
  _isColMajor,
  _dtypeFloat32,
  _dtypeFloat64,
  _dtypeBoolInt8,
  _dtypeInt16,
  _dtypeInt32,
  _dtypeInt64,
  _dtypeUint8,
  _dtypeUint16,
  _dtypeUint32,
  _dtypeUint64,
  _rand,
  _randn
} = require('../../build/Release/flashlight_napi_bindings.node')

class Tensor {
  #_native_self

  constructor(t) {
    this.#_native_self = new _Tensor(t)
  }

  exp() {
    return this.#_native_self.exp(this.#_native_self)
  }

  ceil() {
    return this.#_native_self.ceil(this.#_native_self)
  }

  rint() {
    return this.#_native_self.rint(this.#_native_self)
  }

  flip(dim) {
    return this.#_native_self.flip(this.#_native_self, dim)
  }

  clip(low, high) {
    return this.#_native_self.clip(this.#_native_self, low, high)
  }

  amin(axes, keepDims) {
    return this.#_native_self.amin(this.#_native_self, axes, keepDims)
  }

  amax(axes, keepDims) {
    return this.#_native_self.amax(this.#_native_self, axes, keepDims)
  }

  countNonzero(axes, keepDims) {
    return this.#_native_self.countNonzero(this.#_native_self, axes, keepDims)
  }

  reshape(shape) {
    return this.#_native_self.reshape(this.#_native_self, shape)
  }

  roll(shift, axis) {
    return this.#_native_self.roll(this.#_native_self, shift, axis)
  }

  sum(axes, keepDims) {
    return this.#_native_self.sum(this.#_native_self, axes, keepDims)
  }

  std(axes, keepDims) {
    return this.#_native_self.std(this.#_native_self, axes, keepDims)
  }

  norm(axes, p, keepDims) {
    return this.#_native_self.norm(this.#_native_self, axes, p, keepDims)
  }

  logicalNot() {
    return this.#_native_self.logicalNot(this.#_native_self)
  }

  sin() {
    return this.#_native_self.sin(this.#_native_self)
  }

  tanh() {
    return this.#_native_self.tanh(this.#_native_self)
  }

  isnan() {
    return this.#_native_self.isnan(this.#_native_self)
  }

  median(axes, keepDims) {
    return this.#_native_self.median(this.#_native_self, axes, keepDims)
  }

  any(axes, keepDims) {
    return this.#_native_self.any(this.#_native_self, axes, keepDims)
  }

  cos() {
    return this.#_native_self.cos(this.#_native_self)
  }

  absolute() {
    return this.#_native_self.absolute(this.#_native_self)
  }

  isinf() {
    return this.#_native_self.isinf(this.#_native_self)
  }

  tril() {
    return this.#_native_self.tril(this.#_native_self)
  }

  argmin(axis, keepDims) {
    return this.#_native_self.argmin(this.#_native_self, axis, keepDims)
  }

  sqrt() {
    return this.#_native_self.sqrt(this.#_native_self)
  }

  sigmoid() {
    return this.#_native_self.sigmoid(this.#_native_self)
  }

  power(rhs) {
    return this.#_native_self.power(this.#_native_self, rhs)
  }

  mean(axes, keepDims) {
    return this.#_native_self.mean(this.#_native_self, axes, keepDims)
  }

  transpose(axes) {
    return this.#_native_self.transpose(this.#_native_self, axes)
  }

  floor() {
    return this.#_native_self.floor(this.#_native_self)
  }

  sign() {
    return this.#_native_self.sign(this.#_native_self)
  }

  triu() {
    return this.#_native_self.triu(this.#_native_self)
  }

  sort(axis, sortMode) {
    return this.#_native_self.sort(this.#_native_self, axis, sortMode)
  }

  matmul(rhs, lhsProp, rhsProp) {
    return this.#_native_self.matmul(this.#_native_self, rhs, lhsProp, rhsProp)
  }

  var(axes, bias, keepDims) {
    return this.#_native_self.var(this.#_native_self, axes, bias, keepDims)
  }

  all(axes, keepDims) {
    return this.#_native_self.all(this.#_native_self, axes, keepDims)
  }

  tile(shape) {
    return this.#_native_self.tile(this.#_native_self, shape)
  }

  nonzero() {
    return this.#_native_self.nonzero(this.#_native_self)
  }

  log1p() {
    return this.#_native_self.log1p(this.#_native_self)
  }

  where(x, y) {
    return this.#_native_self.where(this.#_native_self, x, y)
  }

  maximum(rhs) {
    return this.#_native_self.maximum(this.#_native_self, rhs)
  }

  negative() {
    return this.#_native_self.negative(this.#_native_self)
  }

  log() {
    return this.#_native_self.log(this.#_native_self)
  }

  erf() {
    return this.#_native_self.erf(this.#_native_self)
  }

  cumsum(axis) {
    return this.#_native_self.cumsum(this.#_native_self, axis)
  }

  bitwiseOr(rhs) {
    return this.#_native_self.bitwiseOr(this.#_native_self, rhs)
  }

  rShift(rhs) {
    return this.#_native_self.rShift(this.#_native_self, rhs)
  }

  add(rhs) {
    return this.#_native_self.add(this.#_native_self, rhs)
  }

  logicalAnd(rhs) {
    return this.#_native_self.logicalAnd(this.#_native_self, rhs)
  }

  div(rhs) {
    return this.#_native_self.div(this.#_native_self, rhs)
  }

  neq(rhs) {
    return this.#_native_self.neq(this.#_native_self, rhs)
  }

  greaterThanEqual(rhs) {
    return this.#_native_self.greaterThanEqual(this.#_native_self, rhs)
  }

  bitwiseXor(rhs) {
    return this.#_native_self.bitwiseXor(this.#_native_self, rhs)
  }

  greaterThan(rhs) {
    return this.#_native_self.greaterThan(this.#_native_self, rhs)
  }

  bitwiseAnd(rhs) {
    return this.#_native_self.bitwiseAnd(this.#_native_self, rhs)
  }

  lessThanEqual(rhs) {
    return this.#_native_self.lessThanEqual(this.#_native_self, rhs)
  }

  mod(rhs) {
    return this.#_native_self.mod(this.#_native_self, rhs)
  }

  sub(rhs) {
    return this.#_native_self.sub(this.#_native_self, rhs)
  }

  eq(rhs) {
    return this.#_native_self.eq(this.#_native_self, rhs)
  }

  lShift(rhs) {
    return this.#_native_self.lShift(this.#_native_self, rhs)
  }

  mul(rhs) {
    return this.#_native_self.mul(this.#_native_self, rhs)
  }

  lessThan(rhs) {
    return this.#_native_self.lessThan(this.#_native_self, rhs)
  }

  logicalOr(rhs) {
    return this.#_native_self.logicalOr(this.#_native_self, rhs)
  }

  copy() {
    return this.#_native_self.copy(this.#_native_self)
  }

  shape() {
    return this.#_native_self.shape(this.#_native_self)
  }

  elements() {
    return this.#_native_self.elements(this.#_native_self)
  }

  ndim() {
    return this.#_native_self.ndim(this.#_native_self)
  }

  isEmpty() {
    return this.#_native_self.isEmpty(this.#_native_self)
  }

  bytes() {
    return this.#_native_self.bytes(this.#_native_self)
  }

  type() {
    return this.#_native_self.type(this.#_native_self)
  }

  isSparse() {
    return this.#_native_self.isSparse(this.#_native_self)
  }

  strides() {
    return this.#_native_self.strides(this.#_native_self)
  }

  astype() {
    return this.#_native_self.astype(this.#_native_self)
  }

  flatten() {
    return this.#_native_self.flatten(this.#_native_self)
  }

  asContiguousTensor() {
    return this.#_native_self.asContiguousTensor(this.#_native_self)
  }

  isContiguous() {
    return this.#_native_self.isContiguous(this.#_native_self)
  }

  toFloat32Array() {
    this.#_native_self.toFloat32Array()
  }

  toFloat64Array() {
    this.#_native_self.toFloat64Array()
  }

  toBoolInt8Array() {
    this.#_native_self.toBoolInt8Array()
  }

  toInt16Array() {
    this.#_native_self.toInt16Array()
  }

  toInt32Array() {
    this.#_native_self.toInt32Array()
  }

  toInt64Array() {
    this.#_native_self.toInt64Array()
  }

  toUint8Array() {
    this.#_native_self.toUint8Array()
  }

  toUint16Array() {
    this.#_native_self.toUint16Array()
  }

  toUint32Array() {
    this.#_native_self.toUint32Array()
  }

  toUint64Array() {
    this.#_native_self.toUint64Array()
  }

  toFloat32Scalar() {
    this.#_native_self.toFloat32Scalar()
  }

  toFloat64Scalar() {
    this.#_native_self.toFloat64Scalar()
  }

  toBoolInt8Scalar() {
    this.#_native_self.toBoolInt8Scalar()
  }

  toInt16Scalar() {
    this.#_native_self.toInt16Scalar()
  }

  toInt32Scalar() {
    this.#_native_self.toInt32Scalar()
  }

  toInt64Scalar() {
    this.#_native_self.toInt64Scalar()
  }

  toUint8Scalar() {
    this.#_native_self.toUint8Scalar()
  }

  toUint16Scalar() {
    this.#_native_self.toUint16Scalar()
  }

  toUint32Scalar() {
    this.#_native_self.toUint32Scalar()
  }

  toUint64Scalar() {
    this.#_native_self.toUint64Scalar()
  }

  eval() {
    this.#_native_self.eval()
  }

  dispose() {
    this.#_native_self.dispose()
  }
}

const tril = (tensor) => {
  return _tril(tensor)
}

const minimum = (lhs, rhs) => {
  return _minimum(lhs, rhs)
}

const argmin = (input, axis, keepDims) => {
  return _argmin(input, axis, keepDims)
}

const concatenate = (tensors, axis) => {
  return _concatenate(tensors, axis)
}

const cos = (tensor) => {
  return _cos(tensor)
}

const absolute = (tensor) => {
  return _absolute(tensor)
}

const isinf = (tensor) => {
  return _isinf(tensor)
}

const sqrt = (tensor) => {
  return _sqrt(tensor)
}

const sigmoid = (tensor) => {
  return _sigmoid(tensor)
}

const power = (lhs, rhs) => {
  return _power(lhs, rhs)
}

const mean = (input, axes, keepDims) => {
  return _mean(input, axes, keepDims)
}

const sort = (input, axis, sortMode) => {
  return _sort(input, axis, sortMode)
}

const matmul = (lhs, rhs, lhsProp, rhsProp) => {
  return _matmul(lhs, rhs, lhsProp, rhsProp)
}

const _var = (input, axes, bias, keepDims) => {
  return __var(input, axes, bias, keepDims)
}

const all = (input, axes, keepDims) => {
  return _all(input, axes, keepDims)
}

const transpose = (tensor, axes) => {
  return _transpose(tensor, axes)
}

const floor = (tensor) => {
  return _floor(tensor)
}

const sign = (tensor) => {
  return _sign(tensor)
}

const triu = (tensor) => {
  return _triu(tensor)
}

const where = (condition, x, y) => {
  return _where(condition, x, y)
}

const maximum = (lhs, rhs) => {
  return _maximum(lhs, rhs)
}

const argmax = (input, axis, keepDims) => {
  return _argmax(input, axis, keepDims)
}

const full = (dims, val, type) => {
  return _full(dims, val, type)
}

const tile = (tensor, shape) => {
  return _tile(tensor, shape)
}

const nonzero = (tensor) => {
  return _nonzero(tensor)
}

const log1p = (tensor) => {
  return _log1p(tensor)
}

const negative = (tensor) => {
  return _negative(tensor)
}

const log = (tensor) => {
  return _log(tensor)
}

const erf = (tensor) => {
  return _erf(tensor)
}

const cumsum = (input, axis) => {
  return _cumsum(input, axis)
}

const flip = (tensor, dim) => {
  return _flip(tensor, dim)
}

const clip = (tensor, low, high) => {
  return _clip(tensor, low, high)
}

const amin = (input, axes, keepDims) => {
  return _amin(input, axes, keepDims)
}

const amax = (input, axes, keepDims) => {
  return _amax(input, axes, keepDims)
}

const iota = (dims, tileDims, type) => {
  return _iota(dims, tileDims, type)
}

const exp = (tensor) => {
  return _exp(tensor)
}

const ceil = (tensor) => {
  return _ceil(tensor)
}

const rint = (tensor) => {
  return _rint(tensor)
}

const countNonzero = (input, axes, keepDims) => {
  return _countNonzero(input, axes, keepDims)
}

const std = (input, axes, keepDims) => {
  return _std(input, axes, keepDims)
}

const norm = (input, axes, p, keepDims) => {
  return _norm(input, axes, p, keepDims)
}

const arange = (start, end, step, type) => {
  return _arange(start, end, step, type)
}

const reshape = (tensor, shape) => {
  return _reshape(tensor, shape)
}

const roll = (tensor, shift, axis) => {
  return _roll(tensor, shift, axis)
}

const sum = (input, axes, keepDims) => {
  return _sum(input, axes, keepDims)
}

const isnan = (tensor) => {
  return _isnan(tensor)
}

const median = (input, axes, keepDims) => {
  return _median(input, axes, keepDims)
}

const any = (input, axes, keepDims) => {
  return _any(input, axes, keepDims)
}

const identity = (dim, type) => {
  return _identity(dim, type)
}

const logicalNot = (tensor) => {
  return _logicalNot(tensor)
}

const sin = (tensor) => {
  return _sin(tensor)
}

const tanh = (tensor) => {
  return _tanh(tensor)
}

const neq = (lhs, rhs) => {
  return _neq(lhs, rhs)
}

const greaterThanEqual = (lhs, rhs) => {
  return _greaterThanEqual(lhs, rhs)
}

const rShift = (lhs, rhs) => {
  return _rShift(lhs, rhs)
}

const add = (lhs, rhs) => {
  return _add(lhs, rhs)
}

const logicalAnd = (lhs, rhs) => {
  return _logicalAnd(lhs, rhs)
}

const div = (lhs, rhs) => {
  return _div(lhs, rhs)
}

const bitwiseAnd = (lhs, rhs) => {
  return _bitwiseAnd(lhs, rhs)
}

const lessThanEqual = (lhs, rhs) => {
  return _lessThanEqual(lhs, rhs)
}

const bitwiseXor = (lhs, rhs) => {
  return _bitwiseXor(lhs, rhs)
}

const greaterThan = (lhs, rhs) => {
  return _greaterThan(lhs, rhs)
}

const lessThan = (lhs, rhs) => {
  return _lessThan(lhs, rhs)
}

const logicalOr = (lhs, rhs) => {
  return _logicalOr(lhs, rhs)
}

const mod = (lhs, rhs) => {
  return _mod(lhs, rhs)
}

const sub = (lhs, rhs) => {
  return _sub(lhs, rhs)
}

const eq = (lhs, rhs) => {
  return _eq(lhs, rhs)
}

const lShift = (lhs, rhs) => {
  return _lShift(lhs, rhs)
}

const mul = (lhs, rhs) => {
  return _mul(lhs, rhs)
}

const bitwiseOr = (lhs, rhs) => {
  return _bitwiseOr(lhs, rhs)
}

const init = () => {
  return _init()
}

const bytesUsed = () => {
  return _bytesUsed()
}

const setRowMajor = () => {
  return _setRowMajor()
}

const setColMajor = () => {
  return _setColMajor()
}

const isRowMajor = () => {
  return _isRowMajor()
}

const isColMajor = () => {
  return _isColMajor()
}

const dtypeFloat32 = () => {
  return _dtypeFloat32()
}

const dtypeFloat64 = () => {
  return _dtypeFloat64()
}

const dtypeBoolInt8 = () => {
  return _dtypeBoolInt8()
}

const dtypeInt16 = () => {
  return _dtypeInt16()
}

const dtypeInt32 = () => {
  return _dtypeInt32()
}

const dtypeInt64 = () => {
  return _dtypeInt64()
}

const dtypeUint8 = () => {
  return _dtypeUint8()
}

const dtypeUint16 = () => {
  return _dtypeUint16()
}

const dtypeUint32 = () => {
  return _dtypeUint32()
}

const dtypeUint64 = () => {
  return _dtypeUint64()
}

const rand = (shape) => {
  return _rand(shape)
}

const randn = (shape) => {
  return _randn(shape)
}

module.exports = {
  Tensor,
  roll,
  sum,
  std,
  norm,
  arange,
  reshape,
  sin,
  tanh,
  isnan,
  median,
  any,
  identity,
  logicalNot,
  absolute,
  isinf,
  tril,
  minimum,
  argmin,
  concatenate,
  cos,
  power,
  mean,
  sqrt,
  sigmoid,
  sign,
  triu,
  sort,
  matmul,
  _var,
  all,
  transpose,
  floor,
  nonzero,
  log1p,
  where,
  maximum,
  argmax,
  full,
  tile,
  erf,
  cumsum,
  negative,
  log,
  ceil,
  rint,
  flip,
  clip,
  amin,
  amax,
  iota,
  exp,
  countNonzero,
  sub,
  eq,
  lShift,
  mul,
  lessThan,
  logicalOr,
  mod,
  bitwiseOr,
  add,
  logicalAnd,
  div,
  neq,
  greaterThanEqual,
  rShift,
  bitwiseXor,
  greaterThan,
  bitwiseAnd,
  lessThanEqual,
  init,
  bytesUsed,
  setRowMajor,
  setColMajor,
  isRowMajor,
  isColMajor,
  dtypeFloat32,
  dtypeFloat64,
  dtypeBoolInt8,
  dtypeInt16,
  dtypeInt32,
  dtypeInt64,
  dtypeUint8,
  dtypeUint16,
  dtypeUint32,
  dtypeUint64,
  rand,
  randn
}
