// Code generated by gen-napi. DO NOT EDIT.
const {
,
	_sign,
	_power,
	_matmul,
	_var: __var,
	_tile,
	_exp,
	_flip,
	_maximum,
	_argmin,
	_norm,
	_all,
	_iota,
	_reshape,
	_sort,
	_clip,
	_logicalNot,
	_ceil,
	_absolute,
	_erf,
	_triu,
	_where,
	_amax,
	_concatenate,
	_nonzero,
	_floor,
	_roll,
	_argmax,
	_transpose,
	_log1p,
	_tanh,
	_cumsum,
	_identity,
	_sigmoid,
	_isinf,
	_tril,
	_sum,
	_mean,
	_std,
	_full,
	_arange,
	_cos,
	_sqrt,
	_rint,
	_isnan,
	_minimum,
	_amin,
	_negative,
	_log,
	_sin,
	_median,
	_countNonzero,
	_any,
	_bitwiseOr,
	_mul,
	_eq,
	_lessThanEqual,
	_bitwiseAnd,
	_bitwiseXor,
	_sub,
	_neq,
	_mod,
	_lShift,
	_greaterThanEqual,
	_logicalAnd,
	_add,
	_lessThan,
	_logicalOr,
	_rShift,
	_greaterThan,
	_div,
	_init,
	_bytesUsed,
	_setRowMajor,
	_setColMajor,
	_isRowMajor,
	_isColMajor,
	_dtypeFloat32,
	_dtypeFloat64,
	_dtypeBoolInt8,
	_dtypeInt16,
	_dtypeInt32,
	_dtypeInt64,
	_dtypeUint8,
	_dtypeUint16,
	_dtypeUint32,
	_dtypeUint64,
	_rand,
	_randn
} = require("../../build/Release/shumai_bindings.node")

const tanh = (tensor) => {
	return new Tensor(_tanh(tensor._native_self));
}

const roll = (tensor, shift, axis) => {
	return new Tensor(_roll(tensor._native_self, shift, axis));
}

const argmax = (input, axis, keepDims) => {
	return new Tensor(_argmax(input._native_self, axis, keepDims));
}

const transpose = (tensor, axes) => {
	return new Tensor(_transpose(tensor._native_self, axes));
}

const log1p = (tensor) => {
	return new Tensor(_log1p(tensor._native_self));
}

const isinf = (tensor) => {
	return new Tensor(_isinf(tensor._native_self));
}

const cumsum = (input, axis) => {
	return new Tensor(_cumsum(input._native_self, axis));
}

const identity = (dim) => {
	return new Tensor(_identity(dim));
}

const sigmoid = (tensor) => {
	return new Tensor(_sigmoid(tensor._native_self));
}

const cos = (tensor) => {
	return new Tensor(_cos(tensor._native_self));
}

const tril = (tensor) => {
	return new Tensor(_tril(tensor._native_self));
}

const sum = (input, axes, keepDims) => {
	return new Tensor(_sum(input._native_self, axes, keepDims));
}

const mean = (input, axes, keepDims) => {
	return new Tensor(_mean(input._native_self, axes, keepDims));
}

const std = (input, axes, keepDims) => {
	return new Tensor(_std(input._native_self, axes, keepDims));
}

const full = (dims, val) => {
	return new Tensor(_full(dims, val));
}

const arange = (start, end, step) => {
	return new Tensor(_arange(start, end, step));
}

const sin = (tensor) => {
	return new Tensor(_sin(tensor._native_self));
}

const sqrt = (tensor) => {
	return new Tensor(_sqrt(tensor._native_self));
}

const rint = (tensor) => {
	return new Tensor(_rint(tensor._native_self));
}

const isnan = (tensor) => {
	return new Tensor(_isnan(tensor._native_self));
}

const minimum = (lhs, rhs) => {
	return new Tensor(_minimum(lhs._native_self, rhs._native_self));
}

const amin = (input, axes, keepDims) => {
	return new Tensor(_amin(input._native_self, axes, keepDims));
}

const negative = (tensor) => {
	return new Tensor(_negative(tensor._native_self));
}

const log = (tensor) => {
	return new Tensor(_log(tensor._native_self));
}

const any = (input, axes, keepDims) => {
	return new Tensor(_any(input._native_self, axes, keepDims));
}

const median = (input, axes, keepDims) => {
	return new Tensor(_median(input._native_self, axes, keepDims));
}

const countNonzero = (input, axes, keepDims) => {
	return new Tensor(_countNonzero(input._native_self, axes, keepDims));
}

const flip = (tensor, dim) => {
	return new Tensor(_flip(tensor._native_self, dim));
}

const sign = (tensor) => {
	return new Tensor(_sign(tensor._native_self));
}

const power = (lhs, rhs) => {
	return new Tensor(_power(lhs._native_self, rhs._native_self));
}

const matmul = (lhs, rhs) => {
	return new Tensor(_matmul(lhs._native_self, rhs._native_self));
}

const _var = (input, axes, bias, keepDims) => {
	return new Tensor(__var(input._native_self, axes, bias, keepDims));
}

const tile = (tensor, shape) => {
	return new Tensor(_tile(tensor._native_self, shape));
}

const exp = (tensor) => {
	return new Tensor(_exp(tensor._native_self));
}

const sort = (input, axis) => {
	return new Tensor(_sort(input._native_self, axis));
}

const maximum = (lhs, rhs) => {
	return new Tensor(_maximum(lhs._native_self, rhs._native_self));
}

const argmin = (input, axis, keepDims) => {
	return new Tensor(_argmin(input._native_self, axis, keepDims));
}

const norm = (input, axes, p, keepDims) => {
	return new Tensor(_norm(input._native_self, axes, p, keepDims));
}

const all = (input, axes, keepDims) => {
	return new Tensor(_all(input._native_self, axes, keepDims));
}

const iota = (dims, tileDims) => {
	return new Tensor(_iota(dims, tileDims));
}

const reshape = (tensor, shape) => {
	return new Tensor(_reshape(tensor._native_self, shape));
}

const absolute = (tensor) => {
	return new Tensor(_absolute(tensor._native_self));
}

const clip = (tensor, low, high) => {
	return new Tensor(_clip(tensor._native_self, low._native_self, high._native_self));
}

const logicalNot = (tensor) => {
	return new Tensor(_logicalNot(tensor._native_self));
}

const ceil = (tensor) => {
	return new Tensor(_ceil(tensor._native_self));
}

const floor = (tensor) => {
	return new Tensor(_floor(tensor._native_self));
}

const erf = (tensor) => {
	return new Tensor(_erf(tensor._native_self));
}

const triu = (tensor) => {
	return new Tensor(_triu(tensor._native_self));
}

const where = (condition, x, y) => {
	return new Tensor(_where(condition._native_self, x._native_self, y._native_self));
}

const amax = (input, axes, keepDims) => {
	return new Tensor(_amax(input._native_self, axes, keepDims));
}

const concatenate = (tensors, axis) => {
	return new Tensor(_concatenate(tensors, axis));
}

const nonzero = (tensor) => {
	return new Tensor(_nonzero(tensor._native_self));
}

const mod = (lhs, rhs) => {
	return new Tensor(_mod(lhs._native_self, rhs._native_self));
}

const neq = (lhs, rhs) => {
	return new Tensor(_neq(lhs._native_self, rhs._native_self));
}

const greaterThan = (lhs, rhs) => {
	return new Tensor(_greaterThan(lhs._native_self, rhs._native_self));
}

const lShift = (lhs, rhs) => {
	return new Tensor(_lShift(lhs._native_self, rhs._native_self));
}

const greaterThanEqual = (lhs, rhs) => {
	return new Tensor(_greaterThanEqual(lhs._native_self, rhs._native_self));
}

const logicalAnd = (lhs, rhs) => {
	return new Tensor(_logicalAnd(lhs._native_self, rhs._native_self));
}

const add = (lhs, rhs) => {
	return new Tensor(_add(lhs._native_self, rhs._native_self));
}

const lessThan = (lhs, rhs) => {
	return new Tensor(_lessThan(lhs._native_self, rhs._native_self));
}

const logicalOr = (lhs, rhs) => {
	return new Tensor(_logicalOr(lhs._native_self, rhs._native_self));
}

const rShift = (lhs, rhs) => {
	return new Tensor(_rShift(lhs._native_self, rhs._native_self));
}

const div = (lhs, rhs) => {
	return new Tensor(_div(lhs._native_self, rhs._native_self));
}

const sub = (lhs, rhs) => {
	return new Tensor(_sub(lhs._native_self, rhs._native_self));
}

const bitwiseOr = (lhs, rhs) => {
	return new Tensor(_bitwiseOr(lhs._native_self, rhs._native_self));
}

const mul = (lhs, rhs) => {
	return new Tensor(_mul(lhs._native_self, rhs._native_self));
}

const eq = (lhs, rhs) => {
	return new Tensor(_eq(lhs._native_self, rhs._native_self));
}

const lessThanEqual = (lhs, rhs) => {
	return new Tensor(_lessThanEqual(lhs._native_self, rhs._native_self));
}

const bitwiseAnd = (lhs, rhs) => {
	return new Tensor(_bitwiseAnd(lhs._native_self, rhs._native_self));
}

const bitwiseXor = (lhs, rhs) => {
	return new Tensor(_bitwiseXor(lhs._native_self, rhs._native_self));
}

const init = () => {
	return _init();
}

const bytesUsed = () => {
	return _bytesUsed();
}

const setRowMajor = () => {
	return _setRowMajor();
}

const setColMajor = () => {
	return _setColMajor();
}

const isRowMajor = () => {
	return _isRowMajor();
}

const isColMajor = () => {
	return _isColMajor();
}

const dtypeFloat32 = () => {
	return _dtypeFloat32();
}

const dtypeFloat64 = () => {
	return _dtypeFloat64();
}

const dtypeBoolInt8 = () => {
	return _dtypeBoolInt8();
}

const dtypeInt16 = () => {
	return _dtypeInt16();
}

const dtypeInt32 = () => {
	return _dtypeInt32();
}

const dtypeInt64 = () => {
	return _dtypeInt64();
}

const dtypeUint8 = () => {
	return _dtypeUint8();
}

const dtypeUint16 = () => {
	return _dtypeUint16();
}

const dtypeUint32 = () => {
	return _dtypeUint32();
}

const dtypeUint64 = () => {
	return _dtypeUint64();
}

const rand = (shape) => {
	return new Tensor(_rand(shape));
}

const randn = (shape) => {
	return new Tensor(_randn(shape));
}

module.exports = {
,
	transpose,
	log1p,
	tanh,
	roll,
	argmax,
	identity,
	sigmoid,
	isinf,
	cumsum,
	mean,
	std,
	full,
	arange,
	cos,
	tril,
	sum,
	isnan,
	minimum,
	amin,
	negative,
	log,
	sin,
	sqrt,
	rint,
	median,
	countNonzero,
	any,
	matmul,
	_var,
	tile,
	exp,
	flip,
	sign,
	power,
	norm,
	all,
	iota,
	reshape,
	sort,
	maximum,
	argmin,
	logicalNot,
	ceil,
	absolute,
	clip,
	where,
	amax,
	concatenate,
	nonzero,
	floor,
	erf,
	triu,
	bitwiseOr,
	mul,
	eq,
	lessThanEqual,
	bitwiseAnd,
	bitwiseXor,
	sub,
	neq,
	mod,
	lShift,
	greaterThanEqual,
	logicalAnd,
	add,
	lessThan,
	logicalOr,
	rShift,
	greaterThan,
	div,
	init,
	bytesUsed,
	setRowMajor,
	setColMajor,
	isRowMajor,
	isColMajor,
	dtypeFloat32,
	dtypeFloat64,
	dtypeBoolInt8,
	dtypeInt16,
	dtypeInt32,
	dtypeInt64,
	dtypeUint8,
	dtypeUint16,
	dtypeUint32,
	dtypeUint64,
	rand,
	randn
}
