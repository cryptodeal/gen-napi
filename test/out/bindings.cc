// Code generated by gen-napi. DO NOT EDIT.
#include "bindings.h"
#include <atomic>
#include <iostream>
#include <string>
using namespace Napi;

//////////
// source: TensorBase.h

// globally scoped variables
static std::atomic<size_t> g_bytes_used = 0;
static std::atomic<bool> g_row_major = true;

// non-exported helpers
template <typename T>
std::vector<T> ptrArrayArg(const void* ptr, int len) {
  std::vector<T> out;
  out.reserve(len);
  for (auto i = 0; i < len; ++i) {
    auto ptrAsInt = reinterpret_cast<const int64_t*>(ptr)[i];
    auto ptr = reinterpret_cast<T*>(ptrAsInt);
    out.emplace_back(*ptr);
  }
  return out;
}

fl::Tensor* load(std::string filename, Napi::Env env) {
  try {
    fl::Tensor tensor;
    fl::load(filename, tensor);
    auto* t = new fl::Tensor(tensor);
    g_bytes_used += t->bytes();
    return t;
  } catch (std::exception const& e) {
    Napi::TypeError::New(env, e.what()).ThrowAsJavaScriptException();
  }
}

template <typename T>
std::vector<T> arrayArg(const void* ptr, int len, bool reverse, int invert) {
  std::vector<T> out;
  out.reserve(len);
  for (auto i = 0; i < len; ++i) {
    const auto idx = reverse ? len - i - 1 : i;
    auto v = reinterpret_cast<const int64_t*>(ptr)[idx];
    if (invert && v < 0) {
      v = -v - 1;
    } else if (invert) {
      v = invert - v - 1;
    }
    out.emplace_back(v);
  }
  return out;
}

template <typename T>
std::vector<T> jsArrayArg(Napi::Array arr, bool reverse, int invert, Napi::Env env) {
  std::vector<T> out;
  const size_t len = static_cast<size_t>(arr.Length());
  out.reserve(len);
  for (size_t i = 0; i < len; ++i) {
    const auto idx = reverse ? len - i - 1 : i;
    Napi::Value val = arr[idx];
    if (!val.IsNumber()) {
      Napi::TypeError::New(env, "jsArrayArg requires `number[]`")
          .ThrowAsJavaScriptException();
      return out;
    } else {
      int64_t v = val.As<Napi::Number>().Int64Value();
      if (invert && v < 0) {
        v = -v - 1;
      } else if (invert) {
        v = invert - v - 1;
      }
      out.emplace_back(v);
    }
  }
  return out;
}

template <typename T>
std::vector<T> jsTensorArrayArg(Napi::Array arr, Napi::Env env) {
  std::vector<T> out;
  const size_t len = static_cast<size_t>(arr.Length());
  out.reserve(len);
  for (size_t i = 0; i < len; ++i) {
    Napi::Value temp = arr[i];
    if (temp.IsObject()) {
      Napi::Object tensor_obj = temp.As<Napi::Object>();
      if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
        Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
        out.emplace_back(*(tensor->_tensor));
      } else {
        Napi::TypeError::New(env, "jsTensorArrayArg requires `Tensor[]`")
            .ThrowAsJavaScriptException();
        return out;
      }
    } else {
      Napi::TypeError::New(env, "jsTensorArrayArg requires `Tensor[]`")
          .ThrowAsJavaScriptException();
      return out;
    }
  }
  return out;
}

uint32_t axisArg(int32_t axis, bool reverse, int ndim) {
  if (!reverse) {
    return static_cast<uint32_t>(axis);
  }
  if (axis >= 0) {
    return static_cast<uint32_t>(ndim - axis - 1);
  } else {
    return static_cast<uint32_t>(-axis - 1);
  }
}

// exported functions
static Napi::Value _sigmoid(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`sigmoid` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`sigmoid` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::sigmoid(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _amin(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`amin` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`amin` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`amin` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int len_axes = info[1].As<Napi::Array>().Length();
	for (auto i = 0; i < len_axes; ++i) {
		if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
			Napi::TypeError::New(info.Env(), ("`amin` expects args[1][" + std::to_string(i) + "] to be typeof `number`")).ThrowAsJavaScriptException();
			return env.Null();
		}
	}
	if (!info[2].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`amin` expects args[2] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[2].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major, input->_tensor->ndim(), env);
		fl::Tensor _res;
		_res = fl::amin(*(input->_tensor), axes, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _argmin(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`argmin` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`argmin` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsNumber()) {
		Napi::TypeError::New(info.Env(), "`argmin` expects args[1] to be typeof `number`").ThrowAsJavaScriptException();
		return env.Null();
	}
	unsigned axis = static_cast<unsigned>(info[1].As<Napi::Number>().Uint32Value());
	if (!info[2].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`argmin` expects args[2] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[2].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		fl::Tensor _res;
		_res = fl::argmin(*(input->_tensor), axis, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _median(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`median` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`median` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`median` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int len_axes = info[1].As<Napi::Array>().Length();
	for (auto i = 0; i < len_axes; ++i) {
		if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
			Napi::TypeError::New(info.Env(), ("`median` expects args[1][" + std::to_string(i) + "] to be typeof `number`")).ThrowAsJavaScriptException();
			return env.Null();
		}
	}
	if (!info[2].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`median` expects args[2] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[2].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major, input->_tensor->ndim(), env);
		fl::Tensor _res;
		_res = fl::median(*(input->_tensor), axes, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _log(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`log` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`log` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::log(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _rint(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`rint` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`rint` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::rint(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _erf(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`erf` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`erf` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::erf(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _sort(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`sort` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`sort` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsNumber()) {
		Napi::TypeError::New(info.Env(), "`sort` expects args[1] to be typeof `number`").ThrowAsJavaScriptException();
		return env.Null();
	}
	auto axis = info[1].As<Napi::Number>().Uint32Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		fl::Tensor _res;
		_res = fl::sort(*(input->_tensor), axis);
				g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _var(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 4) {
		Napi::TypeError::New(info.Env(), "`var` expects exactly 4 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`var` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`var` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int len_axes = info[1].As<Napi::Array>().Length();
	for (auto i = 0; i < len_axes; ++i) {
		if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
			Napi::TypeError::New(info.Env(), ("`var` expects args[1][" + std::to_string(i) + "] to be typeof `number`")).ThrowAsJavaScriptException();
			return env.Null();
		}
	}
	if (!info[2].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`var` expects args[2] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool bias = info[2].As<Napi::Boolean>().Value();
	if (!info[3].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`var` expects args[3] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[3].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major, input->_tensor->ndim(), env);
		fl::Tensor _res;
		_res = fl::var(*(input->_tensor), axes, bias, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _norm(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 4) {
		Napi::TypeError::New(info.Env(), "`norm` expects exactly 4 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`norm` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`norm` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int len_axes = info[1].As<Napi::Array>().Length();
	for (auto i = 0; i < len_axes; ++i) {
		if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
			Napi::TypeError::New(info.Env(), ("`norm` expects args[1][" + std::to_string(i) + "] to be typeof `number`")).ThrowAsJavaScriptException();
			return env.Null();
		}
	}
	if (!info[2].IsNumber()) {
		Napi::TypeError::New(info.Env(), "`norm` expects args[2] to be typeof `number`").ThrowAsJavaScriptException();
		return env.Null();
	}
	double p = info[2].As<Napi::Number>().DoubleValue();
	if (!info[3].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`norm` expects args[3] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[3].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major, input->_tensor->ndim(), env);
		fl::Tensor _res;
		_res = fl::norm(*(input->_tensor), axes, p, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _nonzero(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`nonzero` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`nonzero` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::nonzero(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _exp(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`exp` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`exp` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::exp(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _sin(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`sin` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`sin` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::sin(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _roll(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`roll` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`roll` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (!info[1].IsNumber()) {
		Napi::TypeError::New(info.Env(), "`roll` expects args[1] to be typeof `number`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int shift = static_cast<int>(info[1].As<Napi::Number>().Int64Value());
	if (!info[2].IsNumber()) {
		Napi::TypeError::New(info.Env(), "`roll` expects args[2] to be typeof `number`").ThrowAsJavaScriptException();
		return env.Null();
	}
	unsigned axis = static_cast<unsigned>(info[2].As<Napi::Number>().Uint32Value());
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::roll(*(tensor->_tensor), shift, axis);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _minimum(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

static Napi::Value _std(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`std` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`std` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`std` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int len_axes = info[1].As<Napi::Array>().Length();
	for (auto i = 0; i < len_axes; ++i) {
		if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
			Napi::TypeError::New(info.Env(), ("`std` expects args[1][" + std::to_string(i) + "] to be typeof `number`")).ThrowAsJavaScriptException();
			return env.Null();
		}
	}
	if (!info[2].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`std` expects args[2] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[2].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major, input->_tensor->ndim(), env);
		fl::Tensor _res;
		_res = fl::std(*(input->_tensor), axes, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _countNonzero(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`countNonzero` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`countNonzero` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`countNonzero` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int len_axes = info[1].As<Napi::Array>().Length();
	for (auto i = 0; i < len_axes; ++i) {
		if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
			Napi::TypeError::New(info.Env(), ("`countNonzero` expects args[1][" + std::to_string(i) + "] to be typeof `number`")).ThrowAsJavaScriptException();
			return env.Null();
		}
	}
	if (!info[2].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`countNonzero` expects args[2] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[2].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major, input->_tensor->ndim(), env);
		fl::Tensor _res;
		_res = fl::countNonzero(*(input->_tensor), axes, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _tile(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 2) {
		Napi::TypeError::New(info.Env(), "`tile` expects exactly 2 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`tile` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`tile` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	auto shape = jsArrayArg<long long>(info[1].As<Napi::Array>(), g_row_major, false, env);
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::tile(*(tensor->_tensor), fl::Shape(shape));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _logicalNot(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`logicalNot` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`logicalNot` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::logicalNot(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _ceil(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`ceil` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`ceil` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::ceil(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _absolute(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`absolute` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`absolute` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::absolute(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _sum(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`sum` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`sum` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`sum` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int len_axes = info[1].As<Napi::Array>().Length();
	for (auto i = 0; i < len_axes; ++i) {
		if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
			Napi::TypeError::New(info.Env(), ("`sum` expects args[1][" + std::to_string(i) + "] to be typeof `number`")).ThrowAsJavaScriptException();
			return env.Null();
		}
	}
	if (!info[2].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`sum` expects args[2] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[2].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major, input->_tensor->ndim(), env);
		fl::Tensor _res;
		_res = fl::sum(*(input->_tensor), axes, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _all(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`all` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`all` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`all` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int len_axes = info[1].As<Napi::Array>().Length();
	for (auto i = 0; i < len_axes; ++i) {
		if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
			Napi::TypeError::New(info.Env(), ("`all` expects args[1][" + std::to_string(i) + "] to be typeof `number`")).ThrowAsJavaScriptException();
			return env.Null();
		}
	}
	if (!info[2].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`all` expects args[2] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[2].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major, input->_tensor->ndim(), env);
		fl::Tensor _res;
		_res = fl::all(*(input->_tensor), axes, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _arange(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

static Napi::Value _sqrt(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`sqrt` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`sqrt` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::sqrt(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _flip(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 2) {
		Napi::TypeError::New(info.Env(), "`flip` expects exactly 2 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`flip` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (!info[1].IsNumber()) {
		Napi::TypeError::New(info.Env(), "`flip` expects args[1] to be typeof `number`").ThrowAsJavaScriptException();
		return env.Null();
	}
	unsigned dim = static_cast<unsigned>(info[1].As<Napi::Number>().Uint32Value());
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::flip(*(tensor->_tensor), dim);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _isinf(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`isinf` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`isinf` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::isinf(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _reshape(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 2) {
		Napi::TypeError::New(info.Env(), "`reshape` expects exactly 2 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`reshape` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`reshape` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	auto shape = jsArrayArg<long long>(info[1].As<Napi::Array>(), g_row_major, false, env);
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::reshape(*(tensor->_tensor), fl::Shape(shape));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _floor(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`floor` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`floor` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::floor(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _clip(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

static Napi::Value _isnan(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`isnan` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`isnan` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::isnan(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _tril(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`tril` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`tril` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		if (g_row_major) {
		  _res = fl::triu(*(tensor->_tensor));
		} else {
		  _res = fl::tril(*(tensor->_tensor));
		}
				g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _triu(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`triu` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`triu` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		if (g_row_major) {
		  _res = fl::tril(*(tensor->_tensor));
		} else {
		  _res = fl::triu(*(tensor->_tensor));
		}
				g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _maximum(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

static Napi::Value _cumsum(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 2) {
		Napi::TypeError::New(info.Env(), "`cumsum` expects exactly 2 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`cumsum` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsNumber()) {
		Napi::TypeError::New(info.Env(), "`cumsum` expects args[1] to be typeof `number`").ThrowAsJavaScriptException();
		return env.Null();
	}
	unsigned axis = static_cast<unsigned>(info[1].As<Napi::Number>().Uint32Value());
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		fl::Tensor _res;
		_res = fl::cumsum(*(input->_tensor), axis);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _negative(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`negative` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`negative` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::negative(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _transpose(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 2) {
		Napi::TypeError::New(info.Env(), "`transpose` expects exactly 2 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`transpose` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`transpose` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		auto axes = jsArrayArg<long long>(info[1].As<Napi::Array>(), g_row_major, tensor->_tensor->ndim(), env);
		fl::Tensor _res;
		_res = fl::transpose(*(tensor->_tensor), fl::Shape(axes));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _log1p(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`log1p` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`log1p` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::log1p(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _sign(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`sign` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`sign` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::sign(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _where(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

static Napi::Value _amax(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`amax` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`amax` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`amax` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int len_axes = info[1].As<Napi::Array>().Length();
	for (auto i = 0; i < len_axes; ++i) {
		if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
			Napi::TypeError::New(info.Env(), ("`amax` expects args[1][" + std::to_string(i) + "] to be typeof `number`")).ThrowAsJavaScriptException();
			return env.Null();
		}
	}
	if (!info[2].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`amax` expects args[2] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[2].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major, input->_tensor->ndim(), env);
		fl::Tensor _res;
		_res = fl::amax(*(input->_tensor), axes, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _argmax(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`argmax` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`argmax` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsNumber()) {
		Napi::TypeError::New(info.Env(), "`argmax` expects args[1] to be typeof `number`").ThrowAsJavaScriptException();
		return env.Null();
	}
	unsigned axis = static_cast<unsigned>(info[1].As<Napi::Number>().Uint32Value());
	if (!info[2].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`argmax` expects args[2] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[2].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		fl::Tensor _res;
		_res = fl::argmax(*(input->_tensor), axis, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _any(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`any` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`any` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`any` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int len_axes = info[1].As<Napi::Array>().Length();
	for (auto i = 0; i < len_axes; ++i) {
		if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
			Napi::TypeError::New(info.Env(), ("`any` expects args[1][" + std::to_string(i) + "] to be typeof `number`")).ThrowAsJavaScriptException();
			return env.Null();
		}
	}
	if (!info[2].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`any` expects args[2] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[2].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major, input->_tensor->ndim(), env);
		fl::Tensor _res;
		_res = fl::any(*(input->_tensor), axes, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _full(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`full` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsArray()) {
		Napi::TypeError::New(info.Env(), "`full` expects args[0] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
}

static Napi::Value _iota(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`iota` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsArray()) {
		Napi::TypeError::New(info.Env(), "`iota` expects args[0] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`iota` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
}

static Napi::Value _concatenate(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 2) {
		Napi::TypeError::New(info.Env(), "`concatenate` expects exactly 2 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsArray()) {
		Napi::TypeError::New(info.Env(), "`concatenate` expects args[0] to be typeof `Tensor[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int len_tensors = info[0].As<Napi::Array>().Length();
	for (auto i = 0; i < len_tensors; ++i) {
		if (!info[0].As<Napi::Array>().Get(i).IsObject()) {
			Napi::TypeError::New(info.Env(), ("`concatenate` expects args[0][" + std::to_string(i) + "] to be typeof `Tensor`")).ThrowAsJavaScriptException();
			return env.Null();
		}
	}
	auto tensors = jsTensorArrayArg<fl::Tensor>(info[0].As<Napi::Array>(), env);
	if (!info[1].IsNumber()) {
		Napi::TypeError::New(info.Env(), "`concatenate` expects args[1] to be typeof `number`").ThrowAsJavaScriptException();
		return env.Null();
	}
	unsigned axis = static_cast<unsigned>(info[1].As<Napi::Number>().Uint32Value());
	auto axis = axisArg(info[1].As<Napi::Number>().Int32Value(), g_row_major, (&tensors[0])->ndim());
}

static Napi::Value _cos(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`cos` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`cos` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::cos(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _tanh(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 1) {
		Napi::TypeError::New(info.Env(), "`tanh` expects exactly 1 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`tanh` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object tensor_obj = info[0].As<Napi::Object>();
	if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
		fl::Tensor _res;
		_res = fl::tanh(*(tensor->_tensor));
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _power(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

static Napi::Value _matmul(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 4) {
		Napi::TypeError::New(info.Env(), "`matmul` expects exactly 4 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`matmul` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object lhs_obj = info[0].As<Napi::Object>();
	if (!info[1].IsObject()) {
		Napi::TypeError::New(info.Env(), "`matmul` expects args[1] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object rhs_obj = info[0].As<Napi::Object>();
	if (lhs_obj.InstanceOf(Tensor::constructor->Value()) && rhs_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
		Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
		fl::Tensor _res;
		if (g_row_major) {
		  _res = fl::matmul(*(rhs->_tensor), *(lhs->_tensor));
		} else {
		  _res = fl::matmul(*(lhs->_tensor), *(rhs->_tensor));
		}
				g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _mean(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 3) {
		Napi::TypeError::New(info.Env(), "`mean` expects exactly 3 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsObject()) {
		Napi::TypeError::New(info.Env(), "`mean` expects args[0] to be instanceof `Tensor`").ThrowAsJavaScriptException();
		return env.Null();
	}
	Napi::Object input_obj = info[0].As<Napi::Object>();
	if (!info[1].IsArray()) {
		Napi::TypeError::New(info.Env(), "`mean` expects args[1] to be typeof `number[]`").ThrowAsJavaScriptException();
		return env.Null();
	}
	int len_axes = info[1].As<Napi::Array>().Length();
	for (auto i = 0; i < len_axes; ++i) {
		if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
			Napi::TypeError::New(info.Env(), ("`mean` expects args[1][" + std::to_string(i) + "] to be typeof `number`")).ThrowAsJavaScriptException();
			return env.Null();
		}
	}
	if (!info[2].IsBoolean()) {
		Napi::TypeError::New(info.Env(), "`mean` expects args[2] to be typeof `boolean`").ThrowAsJavaScriptException();
		return env.Null();
	}
	bool keepDims = info[2].As<Napi::Boolean>().Value();
	if (input_obj.InstanceOf(Tensor::constructor->Value())) {
		Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
		auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major, input->_tensor->ndim(), env);
		fl::Tensor _res;
		_res = fl::mean(*(input->_tensor), axes, keepDims);
		g_bytes_used += _res.bytes();
		auto* out = new fl::Tensor(_res);
		auto wrapped = Napi::External<fl::Tensor>::New(env, out);
		Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
		return wrapped_out;
	}
	return env.Null();
}

static Napi::Value _identity(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if (info.Length() != 2) {
		Napi::TypeError::New(info.Env(), "`identity` expects exactly 2 args").ThrowAsJavaScriptException();
		return env.Null();
	}
	if (!info[0].IsNumber()) {
		Napi::TypeError::New(info.Env(), "`identity` expects args[0] to be typeof `number`").ThrowAsJavaScriptException();
		return env.Null();
	}
}

Napi::Value Tensor::tril(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::triu(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::maximum(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::cumsum(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::negative(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::floor(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::clip(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::isnan(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::where(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::amax(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::any(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::transpose(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::log1p(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::sign(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::tanh(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::power(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::matmul(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::mean(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::cos(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::median(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::log(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::sigmoid(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::amin(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::argmin(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::var(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::norm(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::nonzero(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::rint(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::erf(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::sort(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::std(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::countNonzero(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::tile(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::exp(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::sin(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::roll(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::sum(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::all(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::logicalNot(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::ceil(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::absolute(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::reshape(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::sqrt(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::flip(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::Value Tensor::isinf(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	return env.Null();
}

Napi::FunctionReference* Tensor::constructor;
Napi::Function Tensor::GetClass(Napi::Env env) {
	Napi::Function func = DefineClass(env, "Tensor", {
		Tensor::InstanceMethod("matmul", &Tensor::matmul),
		Tensor::InstanceMethod("mean", &Tensor::mean),
		Tensor::InstanceMethod("cos", &Tensor::cos),
		Tensor::InstanceMethod("tanh", &Tensor::tanh),
		Tensor::InstanceMethod("power", &Tensor::power),
		Tensor::InstanceMethod("log", &Tensor::log),
		Tensor::InstanceMethod("sigmoid", &Tensor::sigmoid),
		Tensor::InstanceMethod("amin", &Tensor::amin),
		Tensor::InstanceMethod("argmin", &Tensor::argmin),
		Tensor::InstanceMethod("median", &Tensor::median),
		Tensor::InstanceMethod("nonzero", &Tensor::nonzero),
		Tensor::InstanceMethod("rint", &Tensor::rint),
		Tensor::InstanceMethod("erf", &Tensor::erf),
		Tensor::InstanceMethod("sort", &Tensor::sort),
		Tensor::InstanceMethod("var", &Tensor::var),
		Tensor::InstanceMethod("norm", &Tensor::norm),
		Tensor::InstanceMethod("countNonzero", &Tensor::countNonzero),
		Tensor::InstanceMethod("tile", &Tensor::tile),
		Tensor::InstanceMethod("exp", &Tensor::exp),
		Tensor::InstanceMethod("sin", &Tensor::sin),
		Tensor::InstanceMethod("roll", &Tensor::roll),
		Tensor::InstanceMethod("std", &Tensor::std),
		Tensor::InstanceMethod("logicalNot", &Tensor::logicalNot),
		Tensor::InstanceMethod("ceil", &Tensor::ceil),
		Tensor::InstanceMethod("absolute", &Tensor::absolute),
		Tensor::InstanceMethod("sum", &Tensor::sum),
		Tensor::InstanceMethod("all", &Tensor::all),
		Tensor::InstanceMethod("reshape", &Tensor::reshape),
		Tensor::InstanceMethod("sqrt", &Tensor::sqrt),
		Tensor::InstanceMethod("flip", &Tensor::flip),
		Tensor::InstanceMethod("isinf", &Tensor::isinf),
		Tensor::InstanceMethod("maximum", &Tensor::maximum),
		Tensor::InstanceMethod("cumsum", &Tensor::cumsum),
		Tensor::InstanceMethod("negative", &Tensor::negative),
		Tensor::InstanceMethod("floor", &Tensor::floor),
		Tensor::InstanceMethod("clip", &Tensor::clip),
		Tensor::InstanceMethod("isnan", &Tensor::isnan),
		Tensor::InstanceMethod("tril", &Tensor::tril),
		Tensor::InstanceMethod("triu", &Tensor::triu),
		Tensor::InstanceMethod("any", &Tensor::any),
		Tensor::InstanceMethod("transpose", &Tensor::transpose),
		Tensor::InstanceMethod("log1p", &Tensor::log1p),
		Tensor::InstanceMethod("sign", &Tensor::sign),
		Tensor::InstanceMethod("where", &Tensor::where),
		Tensor::InstanceMethod("amax", &Tensor::amax),
	});
	constructor = new Napi::FunctionReference();
	*constructor = Napi::Persistent(func);
	return func;
}

// NAPI exports
Napi::Object Init(Napi::Env env, Napi::Object exports) {
	exports.Set(Napi::String::New(env, "_sum"), Napi::Function::New(env, _sum));
	exports.Set(Napi::String::New(env, "_all"), Napi::Function::New(env, _all));
	exports.Set(Napi::String::New(env, "_arange"), Napi::Function::New(env, _arange));
	exports.Set(Napi::String::New(env, "_logicalNot"), Napi::Function::New(env, _logicalNot));
	exports.Set(Napi::String::New(env, "_ceil"), Napi::Function::New(env, _ceil));
	exports.Set(Napi::String::New(env, "_absolute"), Napi::Function::New(env, _absolute));
	exports.Set(Napi::String::New(env, "_reshape"), Napi::Function::New(env, _reshape));
	exports.Set(Napi::String::New(env, "_sqrt"), Napi::Function::New(env, _sqrt));
	exports.Set(Napi::String::New(env, "_flip"), Napi::Function::New(env, _flip));
	exports.Set(Napi::String::New(env, "_isinf"), Napi::Function::New(env, _isinf));
	exports.Set(Napi::String::New(env, "_tril"), Napi::Function::New(env, _tril));
	exports.Set(Napi::String::New(env, "_triu"), Napi::Function::New(env, _triu));
	exports.Set(Napi::String::New(env, "_maximum"), Napi::Function::New(env, _maximum));
	exports.Set(Napi::String::New(env, "_cumsum"), Napi::Function::New(env, _cumsum));
	exports.Set(Napi::String::New(env, "_negative"), Napi::Function::New(env, _negative));
	exports.Set(Napi::String::New(env, "_floor"), Napi::Function::New(env, _floor));
	exports.Set(Napi::String::New(env, "_clip"), Napi::Function::New(env, _clip));
	exports.Set(Napi::String::New(env, "_isnan"), Napi::Function::New(env, _isnan));
	exports.Set(Napi::String::New(env, "_where"), Napi::Function::New(env, _where));
	exports.Set(Napi::String::New(env, "_amax"), Napi::Function::New(env, _amax));
	exports.Set(Napi::String::New(env, "_argmax"), Napi::Function::New(env, _argmax));
	exports.Set(Napi::String::New(env, "_any"), Napi::Function::New(env, _any));
	exports.Set(Napi::String::New(env, "_full"), Napi::Function::New(env, _full));
	exports.Set(Napi::String::New(env, "_transpose"), Napi::Function::New(env, _transpose));
	exports.Set(Napi::String::New(env, "_log1p"), Napi::Function::New(env, _log1p));
	exports.Set(Napi::String::New(env, "_sign"), Napi::Function::New(env, _sign));
	exports.Set(Napi::String::New(env, "_tanh"), Napi::Function::New(env, _tanh));
	exports.Set(Napi::String::New(env, "_power"), Napi::Function::New(env, _power));
	exports.Set(Napi::String::New(env, "_matmul"), Napi::Function::New(env, _matmul));
	exports.Set(Napi::String::New(env, "_mean"), Napi::Function::New(env, _mean));
	exports.Set(Napi::String::New(env, "_identity"), Napi::Function::New(env, _identity));
	exports.Set(Napi::String::New(env, "_iota"), Napi::Function::New(env, _iota));
	exports.Set(Napi::String::New(env, "_concatenate"), Napi::Function::New(env, _concatenate));
	exports.Set(Napi::String::New(env, "_cos"), Napi::Function::New(env, _cos));
	exports.Set(Napi::String::New(env, "_median"), Napi::Function::New(env, _median));
	exports.Set(Napi::String::New(env, "_log"), Napi::Function::New(env, _log));
	exports.Set(Napi::String::New(env, "_sigmoid"), Napi::Function::New(env, _sigmoid));
	exports.Set(Napi::String::New(env, "_amin"), Napi::Function::New(env, _amin));
	exports.Set(Napi::String::New(env, "_argmin"), Napi::Function::New(env, _argmin));
	exports.Set(Napi::String::New(env, "_var"), Napi::Function::New(env, _var));
	exports.Set(Napi::String::New(env, "_norm"), Napi::Function::New(env, _norm));
	exports.Set(Napi::String::New(env, "_nonzero"), Napi::Function::New(env, _nonzero));
	exports.Set(Napi::String::New(env, "_rint"), Napi::Function::New(env, _rint));
	exports.Set(Napi::String::New(env, "_erf"), Napi::Function::New(env, _erf));
	exports.Set(Napi::String::New(env, "_sort"), Napi::Function::New(env, _sort));
	exports.Set(Napi::String::New(env, "_minimum"), Napi::Function::New(env, _minimum));
	exports.Set(Napi::String::New(env, "_std"), Napi::Function::New(env, _std));
	exports.Set(Napi::String::New(env, "_countNonzero"), Napi::Function::New(env, _countNonzero));
	exports.Set(Napi::String::New(env, "_tile"), Napi::Function::New(env, _tile));
	exports.Set(Napi::String::New(env, "_exp"), Napi::Function::New(env, _exp));
	exports.Set(Napi::String::New(env, "_sin"), Napi::Function::New(env, _sin));
	exports.Set(Napi::String::New(env, "_roll"), Napi::Function::New(env, _roll));
}

NODE_API_MODULE(addon, Init)
