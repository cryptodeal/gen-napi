// Code generated by gen-napi. DO NOT EDIT.
#include "bindings.h"
#include <atomic>
#include <iostream>
#include <string>
using namespace Napi;

//////////
// source: TensorBase.h

// globally scoped variables
static std::atomic<size_t> g_bytes_used = 0;
static std::atomic<bool> g_row_major = true;

// non-exported helpers
fl::Tensor* load(std::string filename, Napi::Env env) {
  try {
    fl::Tensor tensor;
    fl::load(filename, tensor);
    auto* t = new fl::Tensor(tensor);
    g_bytes_used += t->bytes();
    return t;
  } catch (std::exception const& e) {
    Napi::TypeError::New(env, e.what()).ThrowAsJavaScriptException();
  }
}

template <typename T>
std::vector<T> arrayArg(const void* ptr, int len, bool reverse, int invert) {
  std::vector<T> out;
  out.reserve(len);
  for (auto i = 0; i < len; ++i) {
    const auto idx = reverse ? len - i - 1 : i;
    auto v = reinterpret_cast<const int64_t*>(ptr)[idx];
    if (invert && v < 0) {
      v = -v - 1;
    } else if (invert) {
      v = invert - v - 1;
    }
    out.emplace_back(v);
  }
  return out;
}

template <typename T>
std::vector<T> jsArrayArg(Napi::Array arr,
                          bool reverse,
                          int invert,
                          Napi::Env env) {
  std::vector<T> out;
  const size_t len = static_cast<size_t>(arr.Length());
  out.reserve(len);
  for (size_t i = 0; i < len; ++i) {
    const auto idx = reverse ? len - i - 1 : i;
    Napi::Value val = arr[idx];
    if (!val.IsNumber()) {
      Napi::TypeError::New(env, "jsArrayArg requires `number[]`")
          .ThrowAsJavaScriptException();
      return out;
    } else {
      int64_t v = val.As<Napi::Number>().Int64Value();
      if (invert && v < 0) {
        v = -v - 1;
      } else if (invert) {
        v = invert - v - 1;
      }
      out.emplace_back(v);
    }
  }
  return out;
}

template <typename T>
std::vector<T> jsTensorArrayArg(Napi::Array arr, Napi::Env env) {
  std::vector<T> out;
  const size_t len = static_cast<size_t>(arr.Length());
  out.reserve(len);
  for (size_t i = 0; i < len; ++i) {
    Napi::Value temp = arr[i];
    if (temp.External()) {
      Napi::Object tensor_obj = temp.As<Napi::External>();
      fl::Tensor* tensor =
          static_cast<fl::Tensor>(temp.As<Napi::External>().Data());
      out.emplace_back(*(tensor));
    } else {
      Napi::TypeError::New(env, "jsTensorArrayArg requires `Tensor[]`")
          .ThrowAsJavaScriptException();
      return out;
    }
  }
  return out;
}

uint32_t axisArg(int32_t axis, bool reverse, int ndim) {
  if (!reverse) {
    return static_cast<uint32_t>(axis);
  }
  if (axis >= 0) {
    return static_cast<uint32_t>(ndim - axis - 1);
  } else {
    return static_cast<uint32_t>(-axis - 1);
  }
}

template <typename T>
std::vector<T> ptrArrayArg(const void* ptr, int len) {
  std::vector<T> out;
  out.reserve(len);
  for (auto i = 0; i < len; ++i) {
    auto ptrAsInt = reinterpret_cast<const int64_t*>(ptr)[i];
    auto ptr = reinterpret_cast<T*>(ptrAsInt);
    out.emplace_back(*ptr);
  }
  return out;
}

static inline void DeleteTensor(Napi::Env env, void* ptr) {
  auto* val = static_cast<fl::Tensor*>(ptr);
  if (val->hasAdapter()) {
    g_bytes_used -= val->bytes();
  }
  delete val;
}

static inline Napi::External<fl::Tensor> ExternalizeTensor(Napi::Env env,
                                                           fl::Tensor* ptr) {
  return Napi::External<fl::Tensor>::New(env, ptr, DeleteTensor);
}

Napi::Value _copy(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`copy` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`copy` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  auto _res = _tmp_external->_tensor->copy();
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

Napi::Value _shape(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`shape` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`shape` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  auto _res = _tmp_external->_tensor->shape();
  const size_t length = static_cast<const size_t>(this->ndim());
  Napi::TypedArrayOf<int64_t> _out =
      Napi::TypedArrayOf<int64_t>::New(env, length, napi_bigint64_array);
  const int out_len = static_cast<int>(length);
  for (auto i = 0; i < out_len; ++i) {
    const auto idx = g_row_major ? out_len - i - 1 : i;
    _out[i] = static_cast<long long>(_res[idx]);
  }
  return _out;
}

Napi::Value _elements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`elements` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`elements` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  auto _res = _tmp_external->_tensor->elements();
  return Napi::Number::New(env, _res);
}

Napi::Value _ndim(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`ndim` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`ndim` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  auto _res = _tmp_external->_tensor->ndim();
  return Napi::Number::New(env, _res);
}

Napi::Value _isEmpty(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`isEmpty` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`isEmpty` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  auto _res = _tmp_external->_tensor->isEmpty();
  return Napi::Boolean::New(env, _res);
}

Napi::Value _bytes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`bytes` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`bytes` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  auto _res = _tmp_external->_tensor->bytes();
  return Napi::Number::New(env, _res);
}

Napi::Value _type(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`type` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`type` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  auto _res = _tmp_external->_tensor->type();
  Napi::Number _out = Napi::Number::New(env, static_cast<int>(_res));
  return _out;
}

Napi::Value _isSparse(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`isSparse` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`isSparse` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  auto _res = _tmp_external->_tensor->isSparse();
  return Napi::Boolean::New(env, _res);
}

Napi::Value _strides(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`strides` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`strides` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  auto _res = _tmp_external->_tensor->strides();
  const size_t length = static_cast<const size_t>(this->ndim());
  Napi::TypedArrayOf<int64_t> _out =
      Napi::TypedArrayOf<int64_t>::New(env, length, napi_bigint64_array);
  const int out_len = static_cast<int>(length);
  for (auto i = 0; i < out_len; ++i) {
    const auto idx = g_row_major ? out_len - i - 1 : i;
    _out[i] = static_cast<long long>(_res[idx]);
  }
  return _out;
}

Napi::Value _astype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`astype` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`astype` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`astype` expects args[1] to be typeof `dtype`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto type = static_cast<fl::dtype>(info[0].As<Napi::Number>().Int32Value());
  auto _res = _tmp_external->_tensor->astype(fl::dtype(type));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

Napi::Value _flatten(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`flatten` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`flatten` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  auto _res = _tmp_external->_tensor->flatten();
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

Napi::Value _asContiguousTensor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(),
                         "`asContiguousTensor` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`asContiguousTensor` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  auto _res = _tmp_external->_tensor->asContiguousTensor();
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

Napi::Value _isContiguous(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`isContiguous` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`isContiguous` expects args[0] to be typeof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* _tmp_external =
      static_cast<fl::Tensor*>(info[0].As<Napi::External>().Data());
  auto _res = _tmp_external->_tensor->isContiguous();
  return Napi::Boolean::New(env, _res);
}

// exported functions
static Napi::Value _roll(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`roll` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`roll` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`roll` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int shift = static_cast<int>(info[1].As<Napi::Number>().Int64Value());
  if (!info[2].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`roll` expects args[2] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  unsigned axis =
      static_cast<unsigned>(info[2].As<Napi::Number>().Uint32Value());
  fl::Tensor _res;
  _res = fl::roll(*(tensor), shift, axis);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _triu(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`triu` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`triu` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  if (g_row_major) {
    _res = fl::tril(*(tensor));
  } else {
    _res = fl::triu(*(tensor));
  }
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _sum(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`sum` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`sum` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`sum` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`sum` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`sum` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                              input->ndim(), env);
  fl::Tensor _res;
  _res = fl::sum(*(input), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _cumsum(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`cumsum` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`cumsum` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`cumsum` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  unsigned axis =
      static_cast<unsigned>(info[1].As<Napi::Number>().Uint32Value());
  fl::Tensor _res;
  _res = fl::cumsum(*(input), axis);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _countNonzero(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`countNonzero` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`countNonzero` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(
        info.Env(), "`countNonzero` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(
          info.Env(), ("`countNonzero` expects args[1][" + std::to_string(i) +
                       "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(
        info.Env(), "`countNonzero` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                              input->ndim(), env);
  fl::Tensor _res;
  _res = fl::countNonzero(*(input), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _floor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`floor` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`floor` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::floor(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _log(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`log` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`log` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::log(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _sigmoid(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`sigmoid` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`sigmoid` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::sigmoid(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _nonzero(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`nonzero` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`nonzero` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::nonzero(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _iota(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`iota` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`iota` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto dims =
      jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major, false, env);
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`iota` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto tileDims =
      jsArrayArg<long long>(info[1].As<Napi::Array>(), g_row_major, false, env);
  if (!info[2].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`iota` expects args[2] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::_res;
  _res = fl::iota(fl::Shape(dims), fl::Shape(tileDims));
  g_bytes_used += _res.bytes();
  auto* out = new fl::(_res);
  Napi::External<fl::> _external_out = Externalize(env, out);
  return _external_out;
}

static Napi::Value _exp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`exp` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`exp` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::exp(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _tanh(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`tanh` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`tanh` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::tanh(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _ceil(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`ceil` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`ceil` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::ceil(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _isnan(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`isnan` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`isnan` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::isnan(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _argmax(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`argmax` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`argmax` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`argmax` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`argmax` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  auto axis = axisArg(info[1].As<Napi::Number>().Uint32Value(), g_row_major,
                      input->ndim());
  fl::Tensor _res;
  _res = fl::argmax(*(input), axis, keepDims);
  auto axes_set = std::unordered_set<int>{static_cast<int>(axis)};
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _identity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`identity` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`identity` expects args[0] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int64_t dim = info[0].As<Napi::Number>().Int64Value();
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`identity` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::_res;
  _res = fl::identity(dim);
  g_bytes_used += _res.bytes();
  auto* out = new fl::(_res);
  Napi::External<fl::> _external_out = Externalize(env, out);
  return _external_out;
}

static Napi::Value _reshape(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`reshape` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`reshape` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`reshape` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto shape =
      jsArrayArg<long long>(info[1].As<Napi::Array>(), g_row_major, false, env);
  fl::Tensor _res;
  _res = fl::reshape(*(tensor), fl::Shape(shape));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _transpose(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`transpose` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`transpose` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`transpose` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto axes = jsArrayArg<long long>(info[1].As<Napi::Array>(), g_row_major,
                                    tensor->ndim(), env);
  fl::Tensor _res;
  _res = fl::transpose(*(tensor), fl::Shape(axes));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _tile(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`tile` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`tile` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`tile` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto shape =
      jsArrayArg<long long>(info[1].As<Napi::Array>(), g_row_major, false, env);
  fl::Tensor _res;
  _res = fl::tile(*(tensor), fl::Shape(shape));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _concatenate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`concatenate` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(
        info.Env(), "`concatenate` expects args[0] to be typeof `Tensor[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_tensors = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_tensors; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsExternal()) {
      Napi::TypeError::New(
          info.Env(), ("`concatenate` expects args[0][" + std::to_string(i) +
                       "] to be typeof `Tensor`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto tensors = jsTensorArrayArg<fl::Tensor>(info[0].As<Napi::Array>(), env);
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`concatenate` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto axis = axisArg(info[1].As<Napi::Number>().Int32Value(), g_row_major,
                      (&tensors[0])->ndim());
  auto axes =
      jsArrayArg<Tensor>(info[0].As<Napi::Array>(), g_row_major, ->ndim(), env);
  fl::_res;
  _res = fl::concatenate(tensors, axis);
  g_bytes_used += _res.bytes();
  auto* out = new fl::(_res);
  Napi::External<fl::> _external_out = Externalize(env, out);
  return _external_out;
}

static Napi::Value _log1p(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`log1p` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`log1p` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::log1p(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _isinf(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`isinf` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`isinf` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::isinf(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _sign(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`sign` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`sign` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::sign(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _full(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`full` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`full` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  std::vector<long long> dims =
      jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major, false, env);
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`full` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  float val = info[1].As<Napi::Number>().FloatValue();
  if (!info[2].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`full` expects args[2] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::_res;
  _res = fl::full(fl::Shape(dims), val);
  g_bytes_used += _res.bytes();
  auto* out = new fl::(_res);
  Napi::External<fl::> _external_out = Externalize(env, out);
  return _external_out;
}

static Napi::Value _maximum(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`maximum` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`maximum` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`maximum` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::maximum(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _mean(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`mean` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`mean` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`mean` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`mean` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`mean` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                              input->ndim(), env);
  fl::Tensor _res;
  _res = fl::mean(*(input), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _var(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 4) {
    Napi::TypeError::New(info.Env(), "`var` expects exactly 4 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`var` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`var` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`var` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`var` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool bias = info[2].As<Napi::Boolean>().Value();
  if (!info[3].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`var` expects args[3] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[3].As<Napi::Boolean>().Value();
  auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                              input->ndim(), env);
  fl::Tensor _res;
  _res = fl::var(*(input), axes, bias, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _where(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`where` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`where` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* condition =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`where` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* x = static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  if (!info[2].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`where` expects args[2] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* y = static_cast<fl::Tensor>(info[2].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::where(*(condition), *(x), *(y));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _negative(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`negative` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`negative` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::negative(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _cos(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`cos` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`cos` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::cos(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _absolute(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`absolute` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`absolute` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::absolute(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _clip(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`clip` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`clip` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`clip` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* low =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  if (!info[2].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`clip` expects args[2] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* high =
      static_cast<fl::Tensor>(info[2].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::clip(*(tensor), *(low), *(high));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _tril(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`tril` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`tril` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  if (g_row_major) {
    _res = fl::triu(*(tensor));
  } else {
    _res = fl::tril(*(tensor));
  }
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _amax(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`amax` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`amax` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`amax` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`amax` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`amax` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                              input->ndim(), env);
  fl::Tensor _res;
  _res = fl::amax(*(input), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _norm(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 4) {
    Napi::TypeError::New(info.Env(), "`norm` expects exactly 4 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`norm` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`norm` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`norm` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`norm` expects args[2] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  double p = info[2].As<Napi::Number>().DoubleValue();
  if (!info[3].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`norm` expects args[3] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[3].As<Napi::Boolean>().Value();
  auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                              input->ndim(), env);
  fl::Tensor _res;
  _res = fl::norm(*(input), axes, p, keepDims);
  if (p == std::numeric_limits<double>::infinity()) {
    _res = fl::abs(*(input));
    _res = fl::amax(*(input), axes, keepDims);
  }
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _arange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`arange` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`arange` expects args[0] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`arange` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[2].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`arange` expects args[2] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }

  float start = info[0].As<Napi::Number>().FloatValue();
  float end = info[1].As<Napi::Number>().FloatValue();
  float step = info[2].As<Napi::Number>().FloatValue();
  fl::_res;
  _res = fl::arange(start, end, step);
  g_bytes_used += _res.bytes();
  auto* out = new fl::(_res);
  Napi::External<fl::> _external_out = Externalize(env, out);
  return _external_out;
}

static Napi::Value _std(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`std` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`std` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`std` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`std` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`std` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                              input->ndim(), env);
  fl::Tensor _res;
  _res = fl::median(*(input), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _any(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`any` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`any` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`any` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`any` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`any` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                              input->ndim(), env);
  fl::Tensor _res;
  _res = fl::any(*(input), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _all(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`all` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`all` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`all` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`all` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`all` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                              input->ndim(), env);
  fl::Tensor _res;
  _res = fl::all(*(input), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _erf(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`erf` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`erf` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::erf(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _flip(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`flip` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`flip` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`flip` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  unsigned dim =
      static_cast<unsigned>(info[1].As<Napi::Number>().Uint32Value());
  fl::Tensor _res;
  _res = fl::flip(*(tensor), dim);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _power(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`power` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`power` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`power` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::power(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _matmul(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`matmul` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`matmul` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`matmul` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  if (g_row_major) {
    _res = fl::matmul(*(rhs), *(lhs));
  } else {
    _res = fl::matmul(*(lhs), *(rhs));
  }
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _sqrt(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`sqrt` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`sqrt` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::sqrt(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _sin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`sin` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`sin` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::sin(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _rint(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`rint` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`rint` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::rint(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _sort(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`sort` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`sort` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`sort` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto axis = info[1].As<Napi::Number>().Uint32Value();
  fl::Tensor _res;
  _res = fl::sort(*(input), axis);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _minimum(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`minimum` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`minimum` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`minimum` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::minimum(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _amin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`amin` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`amin` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`amin` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`amin` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`amin` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                              input->ndim(), env);
  fl::Tensor _res;
  _res = fl::amin(*(input), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _argmin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`argmin` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`argmin` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`argmin` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`argmin` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  auto axis = axisArg(info[1].As<Napi::Number>().Uint32Value(), g_row_major,
                      input->ndim());
  fl::Tensor _res;
  _res = fl::argmin(*(input), axis, keepDims);
  auto axes_set = std::unordered_set<int>{static_cast<int>(axis)};
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _median(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`median` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`median` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* input =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`median` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`median` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`median` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                              input->ndim(), env);
  fl::Tensor _res;
  _res = fl::median(*(input), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(input)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _logicalNot(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`logicalNot` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`logicalNot` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* tensor =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::logicalNot(*(tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _div(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`div` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`div` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`div` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::div(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _lShift(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`lShift` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`lShift` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`lShift` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::lShift(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _eq(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`eq` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`eq` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`eq` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::eq(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _bitwiseOr(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`bitwiseOr` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`bitwiseOr` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`bitwiseOr` expects args[1] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::bitwiseOr(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _sub(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`sub` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`sub` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`sub` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::sub(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _neq(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`neq` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`neq` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`neq` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::neq(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _mod(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`mod` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`mod` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`mod` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::mod(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _greaterThan(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`greaterThan` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`greaterThan` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`greaterThan` expects args[1] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::greaterThan(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _logicalOr(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`logicalOr` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`logicalOr` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`logicalOr` expects args[1] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::logicalOr(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _lessThan(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`lessThan` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`lessThan` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`lessThan` expects args[1] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::lessThan(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _bitwiseAnd(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`bitwiseAnd` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`bitwiseAnd` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`bitwiseAnd` expects args[1] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::bitwiseAnd(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _rShift(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`rShift` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`rShift` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`rShift` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::rShift(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _bitwiseXor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`bitwiseXor` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`bitwiseXor` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`bitwiseXor` expects args[1] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::bitwiseXor(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _greaterThanEqual(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(),
                         "`greaterThanEqual` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`greaterThanEqual` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`greaterThanEqual` expects args[1] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::greaterThanEqual(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _logicalAnd(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`logicalAnd` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`logicalAnd` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`logicalAnd` expects args[1] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::logicalAnd(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _add(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`add` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`add` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`add` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::add(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _mul(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`mul` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`mul` expects args[0] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(
        info.Env(),
        "`mul` expects args[1] to be `Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::mul(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static Napi::Value _lessThanEqual(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`lessThanEqual` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`lessThanEqual` expects args[0] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* lhs =
      static_cast<fl::Tensor>(info[0].As<Napi::External>().Data());
  if (!info[1].IsExternal()) {
    Napi::TypeError::New(info.Env(),
                         "`lessThanEqual` expects args[1] to be "
                         "`Napi::External<fl::Tensor>` `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor* rhs =
      static_cast<fl::Tensor>(info[1].As<Napi::External>().Data());
  fl::Tensor _res;
  _res = fl::lessThanEqual(*(lhs), *(rhs));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  Napi::External<fl::Tensor> _external_out = ExternalizeTensor(env, out);
  return _external_out;
}

static void _init(const Napi::CallbackInfo& info) {
  fl::init();
}

static Napi::Value _bytesUsed(const Napi::CallbackInfo& info) {
  return Napi::BigInt::New(info.Env(), static_cast<int64_t>(g_bytes_used));
}

static void _setRowMajor(const Napi::CallbackInfo& info) {
  g_row_major = true;
}

static void _setColMajor(const Napi::CallbackInfo& info) {
  g_row_major = true;
}

static Napi::Value _isRowMajor(const Napi::CallbackInfo& info) {
  return Napi::Boolean::New(info.Env(), g_row_major);
}

static Napi::Value _isColMajor(const Napi::CallbackInfo& info) {
  return Napi::Boolean::New(info.Env(), !g_row_major);
}

static Napi::Value _dtypeFloat32(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::f32));
}

static Napi::Value _dtypeFloat64(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::f64));
}

static Napi::Value _dtypeBoolInt8(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::b8));
}

static Napi::Value _dtypeInt16(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::s16));
}

static Napi::Value _dtypeInt32(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::s32));
}

static Napi::Value _dtypeInt64(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::s64));
}

static Napi::Value _dtypeUint8(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::u8));
}

static Napi::Value _dtypeUint16(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::u16));
}

static Napi::Value _dtypeUint32(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::u32));
}

static Napi::Value _dtypeUint64(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::u64));
}

static Napi::Value _rand(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1 || !info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`rand` expects exactly 1 arg; "
                         "(expected type `number[]`)...")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  std::vector<long long> shape =
      jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major, false, env);
  fl::Tensor t;
  t = fl::rand(fl::Shape(shape));
  g_bytes_used += t.bytes();
  auto* tensor = new fl::Tensor(t);
  Napi::External<fl::Tensor> wrapped =
      ExternalizeTensor<fl::Tensor>(env, tensor);
  Napi::Value wrappedTensor = Tensor::constructor->New({wrapped});
  return wrappedTensor;
}

static Napi::Value _randn(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1 || !info[0].IsArray()) {
    Napi::TypeError::New(
        env, "`randn` expects exactly 1 arg; (expected type `number[]`)...")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  std::vector<long long> shape =
      jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major, false, env);
  fl::Tensor t;
  t = fl::randn(fl::Shape(shape));
  g_bytes_used += t.bytes();
  auto* tensor = new fl::Tensor(t);
  Napi::External<fl::Tensor> wrapped =
      ExternalizeTensor<fl::Tensor>(env, tensor);
  Napi::Value wrappedTensor = Tensor::constructor->New({wrapped});
  return wrappedTensor;
}

// NAPI exports
Napi::Object Init(Napi::Env env, Napi::Object exports) {
  static inline void DeleteTensor(Napi::Env env, void* ptr) {
    auto* val = static_cast<fl::Tensor*>(ptr);
    if (val->hasAdapter()) {
      g_bytes_used -= val->bytes();
    }
    delete val;
  }

  static inline Napi::External<fl::Tensor> ExternalizeTensor(Napi::Env env,
                                                             fl::Tensor * ptr) {
    return Napi::External<fl::Tensor>::New(env, ptr, DeleteTensor);
  }

  exports.Set(Napi::String::New(env, "_copy"), Napi::Function::New(env, _copy));
  exports.Set(Napi::String::New(env, "_shape"),
              Napi::Function::New(env, _shape));
  exports.Set(Napi::String::New(env, "_elements"),
              Napi::Function::New(env, _elements));
  exports.Set(Napi::String::New(env, "_ndim"), Napi::Function::New(env, _ndim));
  exports.Set(Napi::String::New(env, "_isEmpty"),
              Napi::Function::New(env, _isEmpty));
  exports.Set(Napi::String::New(env, "_bytes"),
              Napi::Function::New(env, _bytes));
  exports.Set(Napi::String::New(env, "_type"), Napi::Function::New(env, _type));
  exports.Set(Napi::String::New(env, "_isSparse"),
              Napi::Function::New(env, _isSparse));
  exports.Set(Napi::String::New(env, "_strides"),
              Napi::Function::New(env, _strides));
  exports.Set(Napi::String::New(env, "_astype"),
              Napi::Function::New(env, _astype));
  exports.Set(Napi::String::New(env, "_flatten"),
              Napi::Function::New(env, _flatten));
  exports.Set(Napi::String::New(env, "_asContiguousTensor"),
              Napi::Function::New(env, _asContiguousTensor));
  exports.Set(Napi::String::New(env, "_isContiguous"),
              Napi::Function::New(env, _isContiguous));
  exports.Set(Napi::String::New(env, "_sign"), Napi::Function::New(env, _sign));
  exports.Set(Napi::String::New(env, "_full"), Napi::Function::New(env, _full));
  exports.Set(Napi::String::New(env, "_reshape"),
              Napi::Function::New(env, _reshape));
  exports.Set(Napi::String::New(env, "_transpose"),
              Napi::Function::New(env, _transpose));
  exports.Set(Napi::String::New(env, "_tile"), Napi::Function::New(env, _tile));
  exports.Set(Napi::String::New(env, "_concatenate"),
              Napi::Function::New(env, _concatenate));
  exports.Set(Napi::String::New(env, "_log1p"),
              Napi::Function::New(env, _log1p));
  exports.Set(Napi::String::New(env, "_isinf"),
              Napi::Function::New(env, _isinf));
  exports.Set(Napi::String::New(env, "_where"),
              Napi::Function::New(env, _where));
  exports.Set(Napi::String::New(env, "_maximum"),
              Napi::Function::New(env, _maximum));
  exports.Set(Napi::String::New(env, "_mean"), Napi::Function::New(env, _mean));
  exports.Set(Napi::String::New(env, "_var"), Napi::Function::New(env, _var));
  exports.Set(Napi::String::New(env, "_norm"), Napi::Function::New(env, _norm));
  exports.Set(Napi::String::New(env, "_arange"),
              Napi::Function::New(env, _arange));
  exports.Set(Napi::String::New(env, "_negative"),
              Napi::Function::New(env, _negative));
  exports.Set(Napi::String::New(env, "_cos"), Napi::Function::New(env, _cos));
  exports.Set(Napi::String::New(env, "_absolute"),
              Napi::Function::New(env, _absolute));
  exports.Set(Napi::String::New(env, "_clip"), Napi::Function::New(env, _clip));
  exports.Set(Napi::String::New(env, "_tril"), Napi::Function::New(env, _tril));
  exports.Set(Napi::String::New(env, "_amax"), Napi::Function::New(env, _amax));
  exports.Set(Napi::String::New(env, "_erf"), Napi::Function::New(env, _erf));
  exports.Set(Napi::String::New(env, "_std"), Napi::Function::New(env, _std));
  exports.Set(Napi::String::New(env, "_any"), Napi::Function::New(env, _any));
  exports.Set(Napi::String::New(env, "_all"), Napi::Function::New(env, _all));
  exports.Set(Napi::String::New(env, "_sqrt"), Napi::Function::New(env, _sqrt));
  exports.Set(Napi::String::New(env, "_flip"), Napi::Function::New(env, _flip));
  exports.Set(Napi::String::New(env, "_power"),
              Napi::Function::New(env, _power));
  exports.Set(Napi::String::New(env, "_matmul"),
              Napi::Function::New(env, _matmul));
  exports.Set(Napi::String::New(env, "_median"),
              Napi::Function::New(env, _median));
  exports.Set(Napi::String::New(env, "_logicalNot"),
              Napi::Function::New(env, _logicalNot));
  exports.Set(Napi::String::New(env, "_sin"), Napi::Function::New(env, _sin));
  exports.Set(Napi::String::New(env, "_rint"), Napi::Function::New(env, _rint));
  exports.Set(Napi::String::New(env, "_sort"), Napi::Function::New(env, _sort));
  exports.Set(Napi::String::New(env, "_minimum"),
              Napi::Function::New(env, _minimum));
  exports.Set(Napi::String::New(env, "_amin"), Napi::Function::New(env, _amin));
  exports.Set(Napi::String::New(env, "_argmin"),
              Napi::Function::New(env, _argmin));
  exports.Set(Napi::String::New(env, "_floor"),
              Napi::Function::New(env, _floor));
  exports.Set(Napi::String::New(env, "_roll"), Napi::Function::New(env, _roll));
  exports.Set(Napi::String::New(env, "_triu"), Napi::Function::New(env, _triu));
  exports.Set(Napi::String::New(env, "_sum"), Napi::Function::New(env, _sum));
  exports.Set(Napi::String::New(env, "_cumsum"),
              Napi::Function::New(env, _cumsum));
  exports.Set(Napi::String::New(env, "_countNonzero"),
              Napi::Function::New(env, _countNonzero));
  exports.Set(Napi::String::New(env, "_nonzero"),
              Napi::Function::New(env, _nonzero));
  exports.Set(Napi::String::New(env, "_log"), Napi::Function::New(env, _log));
  exports.Set(Napi::String::New(env, "_sigmoid"),
              Napi::Function::New(env, _sigmoid));
  exports.Set(Napi::String::New(env, "_identity"),
              Napi::Function::New(env, _identity));
  exports.Set(Napi::String::New(env, "_iota"), Napi::Function::New(env, _iota));
  exports.Set(Napi::String::New(env, "_exp"), Napi::Function::New(env, _exp));
  exports.Set(Napi::String::New(env, "_tanh"), Napi::Function::New(env, _tanh));
  exports.Set(Napi::String::New(env, "_ceil"), Napi::Function::New(env, _ceil));
  exports.Set(Napi::String::New(env, "_isnan"),
              Napi::Function::New(env, _isnan));
  exports.Set(Napi::String::New(env, "_argmax"),
              Napi::Function::New(env, _argmax));
  exports.Set(Napi::String::New(env, "_mul"), Napi::Function::New(env, _mul));
  exports.Set(Napi::String::New(env, "_lessThanEqual"),
              Napi::Function::New(env, _lessThanEqual));
  exports.Set(Napi::String::New(env, "_div"), Napi::Function::New(env, _div));
  exports.Set(Napi::String::New(env, "_lShift"),
              Napi::Function::New(env, _lShift));
  exports.Set(Napi::String::New(env, "_eq"), Napi::Function::New(env, _eq));
  exports.Set(Napi::String::New(env, "_bitwiseOr"),
              Napi::Function::New(env, _bitwiseOr));
  exports.Set(Napi::String::New(env, "_sub"), Napi::Function::New(env, _sub));
  exports.Set(Napi::String::New(env, "_rShift"),
              Napi::Function::New(env, _rShift));
  exports.Set(Napi::String::New(env, "_neq"), Napi::Function::New(env, _neq));
  exports.Set(Napi::String::New(env, "_mod"), Napi::Function::New(env, _mod));
  exports.Set(Napi::String::New(env, "_greaterThan"),
              Napi::Function::New(env, _greaterThan));
  exports.Set(Napi::String::New(env, "_logicalOr"),
              Napi::Function::New(env, _logicalOr));
  exports.Set(Napi::String::New(env, "_lessThan"),
              Napi::Function::New(env, _lessThan));
  exports.Set(Napi::String::New(env, "_bitwiseAnd"),
              Napi::Function::New(env, _bitwiseAnd));
  exports.Set(Napi::String::New(env, "_bitwiseXor"),
              Napi::Function::New(env, _bitwiseXor));
  exports.Set(Napi::String::New(env, "_greaterThanEqual"),
              Napi::Function::New(env, _greaterThanEqual));
  exports.Set(Napi::String::New(env, "_logicalAnd"),
              Napi::Function::New(env, _logicalAnd));
  exports.Set(Napi::String::New(env, "_add"), Napi::Function::New(env, _add));
  exports.Set(Napi::String::New(env, "_init"), Napi::Function::New(env, _init));
  exports.Set(Napi::String::New(env, "_bytesUsed"),
              Napi::Function::New(env, _bytesUsed));
  exports.Set(Napi::String::New(env, "_setRowMajor"),
              Napi::Function::New(env, _setRowMajor));
  exports.Set(Napi::String::New(env, "_setColMajor"),
              Napi::Function::New(env, _setColMajor));
  exports.Set(Napi::String::New(env, "_isRowMajor"),
              Napi::Function::New(env, _isRowMajor));
  exports.Set(Napi::String::New(env, "_isColMajor"),
              Napi::Function::New(env, _isColMajor));
  exports.Set(Napi::String::New(env, "_dtypeFloat32"),
              Napi::Function::New(env, _dtypeFloat32));
  exports.Set(Napi::String::New(env, "_dtypeFloat64"),
              Napi::Function::New(env, _dtypeFloat64));
  exports.Set(Napi::String::New(env, "_dtypeBoolInt8"),
              Napi::Function::New(env, _dtypeBoolInt8));
  exports.Set(Napi::String::New(env, "_dtypeInt16"),
              Napi::Function::New(env, _dtypeInt16));
  exports.Set(Napi::String::New(env, "_dtypeInt32"),
              Napi::Function::New(env, _dtypeInt32));
  exports.Set(Napi::String::New(env, "_dtypeInt64"),
              Napi::Function::New(env, _dtypeInt64));
  exports.Set(Napi::String::New(env, "_dtypeUint8"),
              Napi::Function::New(env, _dtypeUint8));
  exports.Set(Napi::String::New(env, "_dtypeUint16"),
              Napi::Function::New(env, _dtypeUint16));
  exports.Set(Napi::String::New(env, "_dtypeUint32"),
              Napi::Function::New(env, _dtypeUint32));
  exports.Set(Napi::String::New(env, "_dtypeUint64"),
              Napi::Function::New(env, _dtypeUint64));
  exports.Set(Napi::String::New(env, "_rand"), Napi::Function::New(env, _rand));
  exports.Set(Napi::String::New(env, "_randn"),
              Napi::Function::New(env, _randn));
  return exports;
}

NODE_API_MODULE(addon, Init)
