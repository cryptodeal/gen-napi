// Code generated by gen-napi. DO NOT EDIT.
#include "bindings.h"
#include <atomic>
#include <iostream>
#include <string>
using namespace Napi;

//////////
// source: TensorBase.h

// globally scoped variables
static std::atomic<size_t> g_bytes_used = 0;
static std::atomic<bool> g_row_major = true;

// non-exported helpers
template <typename T>
std::vector<T> ptrArrayArg(const void* ptr, int len) {
  std::vector<T> out;
  out.reserve(len);
  for (auto i = 0; i < len; ++i) {
    auto ptrAsInt = reinterpret_cast<const int64_t*>(ptr)[i];
    auto ptr = reinterpret_cast<T*>(ptrAsInt);
    out.emplace_back(*ptr);
  }
  return out;
}

fl::Tensor* load(std::string filename, Napi::Env env) {
  try {
    fl::Tensor tensor;
    fl::load(filename, tensor);
    auto* t = new fl::Tensor(tensor);
    g_bytes_used += t->bytes();
    return t;
  } catch (std::exception const& e) {
    Napi::TypeError::New(env, e.what()).ThrowAsJavaScriptException();
  }
}

template <typename T>
std::vector<T> arrayArg(const void* ptr, int len, bool reverse, int invert) {
  std::vector<T> out;
  out.reserve(len);
  for (auto i = 0; i < len; ++i) {
    const auto idx = reverse ? len - i - 1 : i;
    auto v = reinterpret_cast<const int64_t*>(ptr)[idx];
    if (invert && v < 0) {
      v = -v - 1;
    } else if (invert) {
      v = invert - v - 1;
    }
    out.emplace_back(v);
  }
  return out;
}

template <typename T>
std::vector<T> jsArrayArg(Napi::Array arr,
                          bool reverse,
                          int invert,
                          Napi::Env env) {
  std::vector<T> out;
  const size_t len = static_cast<size_t>(arr.Length());
  out.reserve(len);
  for (size_t i = 0; i < len; ++i) {
    const auto idx = reverse ? len - i - 1 : i;
    Napi::Value val = arr[idx];
    if (!val.IsNumber()) {
      Napi::TypeError::New(env, "jsArrayArg requires `number[]`")
          .ThrowAsJavaScriptException();
      return out;
    } else {
      int64_t v = val.As<Napi::Number>().Int64Value();
      if (invert && v < 0) {
        v = -v - 1;
      } else if (invert) {
        v = invert - v - 1;
      }
      out.emplace_back(v);
    }
  }
  return out;
}

template <typename T>
std::vector<T> jsTensorArrayArg(Napi::Array arr, Napi::Env env) {
  std::vector<T> out;
  const size_t len = static_cast<size_t>(arr.Length());
  out.reserve(len);
  for (size_t i = 0; i < len; ++i) {
    Napi::Value temp = arr[i];
    if (temp.IsObject()) {
      Napi::Object tensor_obj = temp.As<Napi::Object>();
      if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
        Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
        out.emplace_back(*(tensor->_tensor));
      } else {
        Napi::TypeError::New(env, "jsTensorArrayArg requires `Tensor[]`")
            .ThrowAsJavaScriptException();
        return out;
      }
    } else {
      Napi::TypeError::New(env, "jsTensorArrayArg requires `Tensor[]`")
          .ThrowAsJavaScriptException();
      return out;
    }
  }
  return out;
}

uint32_t axisArg(int32_t axis, bool reverse, int ndim) {
  if (!reverse) {
    return static_cast<uint32_t>(axis);
  }
  if (axis >= 0) {
    return static_cast<uint32_t>(ndim - axis - 1);
  } else {
    return static_cast<uint32_t>(-axis - 1);
  }
}

// exported functions
static Napi::Value _full(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`full` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`full` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  std::vector<long long> dims =
      jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major, false, env);
  float val = info[1].As<Napi::Number>().FloatValue();
  if (!info[2].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`full` expects args[2] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor _res;
  _res = fl::full(fl::Shape(dims), val);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

static Napi::Value _absolute(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`absolute` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`absolute` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::absolute(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _clip(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`clip` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`clip` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`clip` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object low_obj = info[1].As<Napi::Object>();
  if (!info[2].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`clip` expects args[2] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object high_obj = info[2].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value()) &&
      low_obj.InstanceOf(Tensor::constructor->Value()) &&
      high_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    Tensor* low = Napi::ObjectWrap<Tensor>::Unwrap(low_obj);
    Tensor* high = Napi::ObjectWrap<Tensor>::Unwrap(high_obj);
    fl::Tensor _res;
    _res = fl::clip(*(tensor->_tensor), *(low->_tensor), *(high->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _minimum(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`minimum` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`minimum` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`minimum` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::minimum(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _cumsum(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`cumsum` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`cumsum` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`cumsum` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  unsigned axis =
      static_cast<unsigned>(info[1].As<Napi::Number>().Uint32Value());
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    fl::Tensor _res;
    _res = fl::cumsum(*(input->_tensor), axis);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _countNonzero(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`countNonzero` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`countNonzero` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(
        info.Env(), "`countNonzero` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(
          info.Env(), ("`countNonzero` expects args[1][" + std::to_string(i) +
                       "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(
        info.Env(), "`countNonzero` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                                input->_tensor->ndim(), env);
    fl::Tensor _res;
    _res = fl::countNonzero(*(input->_tensor), axes, keepDims);
    auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _reshape(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`reshape` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`reshape` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`reshape` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto shape =
      jsArrayArg<long long>(info[1].As<Napi::Array>(), g_row_major, false, env);
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::reshape(*(tensor->_tensor), fl::Shape(shape));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _logicalNot(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`logicalNot` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`logicalNot` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::logicalNot(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _log(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`log` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`log` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::log(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _isinf(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`isinf` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`isinf` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::isinf(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _tril(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`tril` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`tril` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    if (g_row_major) {
      _res = fl::triu(*(tensor->_tensor));
    } else {
      _res = fl::tril(*(tensor->_tensor));
    }
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _sum(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`sum` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`sum` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`sum` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`sum` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`sum` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                                input->_tensor->ndim(), env);
    fl::Tensor _res;
    _res = fl::sum(*(input->_tensor), axes, keepDims);
    auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _var(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 4) {
    Napi::TypeError::New(info.Env(), "`var` expects exactly 4 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`var` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`var` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`var` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`var` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool bias = info[2].As<Napi::Boolean>().Value();
  if (!info[3].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`var` expects args[3] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[3].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                                input->_tensor->ndim(), env);
    fl::Tensor _res;
    _res = fl::var(*(input->_tensor), axes, bias, keepDims);
    auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _identity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`identity` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`identity` expects args[0] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int64_t dim = info[0].As<Napi::Number>().Int64Value();
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`identity` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor _res;
  _res = fl::identity(dim);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

static Napi::Value _exp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`exp` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`exp` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::exp(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _sin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`sin` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`sin` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::sin(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _cos(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`cos` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`cos` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::cos(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _tanh(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`tanh` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`tanh` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::tanh(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _where(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`where` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`where` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object condition_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`where` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object x_obj = info[1].As<Napi::Object>();
  if (!info[2].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`where` expects args[2] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object y_obj = info[2].As<Napi::Object>();
  if (condition_obj.InstanceOf(Tensor::constructor->Value()) &&
      x_obj.InstanceOf(Tensor::constructor->Value()) &&
      y_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* condition = Napi::ObjectWrap<Tensor>::Unwrap(condition_obj);
    Tensor* x = Napi::ObjectWrap<Tensor>::Unwrap(x_obj);
    Tensor* y = Napi::ObjectWrap<Tensor>::Unwrap(y_obj);
    fl::Tensor _res;
    _res = fl::where(*(condition->_tensor), *(x->_tensor), *(y->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _argmin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`argmin` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`argmin` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`argmin` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`argmin` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axis = axisArg(info[1].As<Napi::Number>().Uint32Value(), g_row_major,
                        input->_tensor->ndim());
    fl::Tensor _res;
    _res = fl::argmin(*(input->_tensor), axis, keepDims);
    auto axes_set = std::unordered_set<int>{static_cast<int>(axis)};
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _norm(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 4) {
    Napi::TypeError::New(info.Env(), "`norm` expects exactly 4 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`norm` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`norm` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`norm` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`norm` expects args[2] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  double p = info[2].As<Napi::Number>().DoubleValue();
  if (!info[3].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`norm` expects args[3] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[3].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                                input->_tensor->ndim(), env);
    fl::Tensor _res;
    _res = fl::norm(*(input->_tensor), axes, p, keepDims);
    if (p == std::numeric_limits<double>::infinity()) {
      _res = fl::abs(*(input->_tensor));
      _res = fl::amax(*(input->_tensor), axes, keepDims);
    }
    auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _concatenate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`concatenate` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(
        info.Env(), "`concatenate` expects args[0] to be typeof `Tensor[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_tensors = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_tensors; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsObject()) {
      Napi::TypeError::New(
          info.Env(), ("`concatenate` expects args[0][" + std::to_string(i) +
                       "] to be typeof `Tensor`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto tensors = jsTensorArrayArg<fl::Tensor>(info[0].As<Napi::Array>(), env);
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`concatenate` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto axis = axisArg(info[1].As<Napi::Number>().Int32Value(), g_row_major,
                      (&tensors[0])->ndim());
  fl::Tensor _res;
  _res = fl::concatenate(tensors, axis);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

static Napi::Value _ceil(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`ceil` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`ceil` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::ceil(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _rint(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`rint` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`rint` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::rint(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _sigmoid(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`sigmoid` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`sigmoid` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::sigmoid(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _sign(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`sign` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`sign` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::sign(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _amin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`amin` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`amin` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`amin` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`amin` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`amin` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                                input->_tensor->ndim(), env);
    fl::Tensor _res;
    _res = fl::amin(*(input->_tensor), axes, keepDims);
    auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _any(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`any` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`any` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`any` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`any` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`any` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                                input->_tensor->ndim(), env);
    fl::Tensor _res;
    _res = fl::any(*(input->_tensor), axes, keepDims);
    auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _transpose(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`transpose` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`transpose` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`transpose` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    auto axes = jsArrayArg<long long>(info[1].As<Napi::Array>(), g_row_major,
                                      tensor->_tensor->ndim(), env);
    fl::Tensor _res;
    _res = fl::transpose(*(tensor->_tensor), fl::Shape(axes));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _floor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`floor` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`floor` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::floor(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _flip(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`flip` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`flip` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`flip` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  unsigned dim =
      static_cast<unsigned>(info[1].As<Napi::Number>().Uint32Value());
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::flip(*(tensor->_tensor), dim);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _isnan(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`isnan` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`isnan` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::isnan(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _all(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`all` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`all` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`all` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`all` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`all` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                                input->_tensor->ndim(), env);
    fl::Tensor _res;
    _res = fl::all(*(input->_tensor), axes, keepDims);
    auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _arange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`arange` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`arange` expects args[0] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`arange` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[2].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`arange` expects args[2] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }

  float start = info[0].As<Napi::Number>().FloatValue();
  float end = info[1].As<Napi::Number>().FloatValue();
  float step = info[2].As<Napi::Number>().FloatValue();
  fl::Tensor _res;
  _res = fl::arange(start, end, step);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

static Napi::Value _log1p(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`log1p` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`log1p` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::log1p(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _triu(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`triu` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`triu` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    if (g_row_major) {
      _res = fl::tril(*(tensor->_tensor));
    } else {
      _res = fl::triu(*(tensor->_tensor));
    }
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _maximum(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`maximum` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`maximum` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`maximum` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::maximum(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _power(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`power` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`power` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`power` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::power(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _matmul(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`matmul` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`matmul` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`matmul` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    if (g_row_major) {
      _res = fl::matmul(*(rhs->_tensor), *(lhs->_tensor));
    } else {
      _res = fl::matmul(*(lhs->_tensor), *(rhs->_tensor));
    }
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _median(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`median` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`median` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`median` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`median` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`median` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                                input->_tensor->ndim(), env);
    fl::Tensor _res;
    _res = fl::median(*(input->_tensor), axes, keepDims);
    auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _iota(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`iota` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`iota` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto dims =
      jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major, false, env);
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`iota` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto tileDims =
      jsArrayArg<long long>(info[1].As<Napi::Array>(), g_row_major, false, env);
  if (!info[2].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`iota` expects args[2] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  fl::Tensor _res;
  _res = fl::iota(fl::Shape(dims), fl::Shape(tileDims));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

static Napi::Value _nonzero(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`nonzero` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`nonzero` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::nonzero(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _negative(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`negative` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`negative` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::negative(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _sort(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`sort` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`sort` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`sort` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto axis = info[1].As<Napi::Number>().Uint32Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    fl::Tensor _res;
    _res = fl::sort(*(input->_tensor), axis);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _amax(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`amax` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`amax` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`amax` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`amax` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`amax` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                                input->_tensor->ndim(), env);
    fl::Tensor _res;
    _res = fl::amax(*(input->_tensor), axes, keepDims);
    auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _mean(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`mean` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`mean` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`mean` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`mean` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`mean` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                                input->_tensor->ndim(), env);
    fl::Tensor _res;
    _res = fl::mean(*(input->_tensor), axes, keepDims);
    auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _tile(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`tile` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`tile` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`tile` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto shape =
      jsArrayArg<long long>(info[1].As<Napi::Array>(), g_row_major, false, env);
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::tile(*(tensor->_tensor), fl::Shape(shape));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _sqrt(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`sqrt` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`sqrt` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::sqrt(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _erf(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`erf` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`erf` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::erf(*(tensor->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _roll(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`roll` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`roll` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object tensor_obj = info[0].As<Napi::Object>();
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`roll` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int shift = static_cast<int>(info[1].As<Napi::Number>().Int64Value());
  if (!info[2].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`roll` expects args[2] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  unsigned axis =
      static_cast<unsigned>(info[2].As<Napi::Number>().Uint32Value());
  if (tensor_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* tensor = Napi::ObjectWrap<Tensor>::Unwrap(tensor_obj);
    fl::Tensor _res;
    _res = fl::roll(*(tensor->_tensor), shift, axis);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _argmax(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`argmax` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`argmax` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`argmax` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`argmax` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axis = axisArg(info[1].As<Napi::Number>().Uint32Value(), g_row_major,
                        input->_tensor->ndim());
    fl::Tensor _res;
    _res = fl::argmax(*(input->_tensor), axis, keepDims);
    auto axes_set = std::unordered_set<int>{static_cast<int>(axis)};
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _std(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`std` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`std` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object input_obj = info[0].As<Napi::Object>();
  if (!info[1].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`std` expects args[1] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[1].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[1].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`std` expects args[1][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`std` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  if (input_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* input = Napi::ObjectWrap<Tensor>::Unwrap(input_obj);
    auto axes = jsArrayArg<int>(info[1].As<Napi::Array>(), g_row_major,
                                input->_tensor->ndim(), env);
    fl::Tensor _res;
    _res = fl::median(*(input->_tensor), axes, keepDims);
    auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
    auto base_shape = (*(input->_tensor)).shape().get();
    std::vector<fl::Dim> new_shape;
    for (size_t idx = 0; idx < base_shape.size(); ++idx) {
      if (axes_set.count(idx) || (axes_set.size() == 0)) {
        if (keepDims) {
          new_shape.emplace_back(1);
        }
        continue;
      }
      new_shape.emplace_back(base_shape[idx]);
    }
    const auto& shape = fl::Shape(new_shape);
    _res = fl::reshape(_res, shape);
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _rShift(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`rShift` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`rShift` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`rShift` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::rShift(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _mul(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`mul` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`mul` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`mul` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::mul(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _div(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`div` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`div` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`div` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::div(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _logicalAnd(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`logicalAnd` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`logicalAnd` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`logicalAnd` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::logicalAnd(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _eq(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`eq` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`eq` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`eq` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::eq(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _bitwiseAnd(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`bitwiseAnd` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`bitwiseAnd` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`bitwiseAnd` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::bitwiseAnd(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _greaterThanEqual(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(),
                         "`greaterThanEqual` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(),
        "`greaterThanEqual` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(
        info.Env(),
        "`greaterThanEqual` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::greaterThanEqual(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _lShift(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`lShift` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`lShift` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`lShift` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::lShift(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _sub(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`sub` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`sub` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`sub` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::sub(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _lessThan(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`lessThan` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`lessThan` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`lessThan` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::lessThan(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _greaterThan(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`greaterThan` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`greaterThan` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`greaterThan` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::greaterThan(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _mod(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`mod` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`mod` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`mod` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::mod(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _bitwiseOr(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`bitwiseOr` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`bitwiseOr` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`bitwiseOr` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::bitwiseOr(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _logicalOr(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`logicalOr` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`logicalOr` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`logicalOr` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::logicalOr(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _add(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`add` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`add` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`add` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::add(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _neq(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`neq` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`neq` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`neq` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::neq(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _lessThanEqual(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`lessThanEqual` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`lessThanEqual` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`lessThanEqual` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::lessThanEqual(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

static Napi::Value _bitwiseXor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`bitwiseXor` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`bitwiseXor` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object lhs_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`bitwiseXor` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[1].As<Napi::Object>();
  if (lhs_obj.InstanceOf(Tensor::constructor->Value()) &&
      rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* lhs = Napi::ObjectWrap<Tensor>::Unwrap(lhs_obj);
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::bitwiseXor(*(lhs->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

// "Tensor" class constructor
Tensor::Tensor(const Napi::CallbackInfo& info) : ObjectWrap(info) {
  Napi::Env env = info.Env();
  // throw error if number of args passed to constructor is not 1
  if (info.Length() != 1) {
    Napi::TypeError::New(env,
                         "Invalid arg count when constructing Tensor "
                         "(constructor expects exactly 1 arg)...")
        .ThrowAsJavaScriptException();
    return;
  }
  if (info[0].IsExternal()) {
    auto tensor = info[0].As<Napi::External<fl::Tensor>>();
    this->_tensor = tensor.Data();
  }
  // TODO: handle `arg instanceof Tensor`
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (obj.InstanceOf(Tensor::constructor->Value())) {
      Tensor* t = Napi::ObjectWrap<Tensor>::Unwrap(obj);
      this->_tensor = t->_tensor;
      // TODO: finish handling this case
      return;
    }
  }
  // TODO: handle `typeof arg === 'string
  if (info[0].IsString()) {
    Napi::String str = info[0].As<Napi::String>();
    std::string filename = str.Utf8Value();
    fl::Tensor* t = load(filename, env);
    this->_tensor = t;
    return;
  }
  // handle if arg is a TypedArray
  if (info[0].IsTypedArray()) {
    Napi::TypedArray underlying = info[0].As<Napi::TypedArray>();
    int64_t length = static_cast<int64_t>(underlying.ElementLength());
    napi_typedarray_type arrayType = underlying.TypedArrayType();
    switch (arrayType) {
      case napi_float32_array: {
        Napi::TypedArrayOf<float> float_array =
            underlying.As<Napi::TypedArrayOf<float>>();
        float* ptr = float_array.Data();
        auto* t = new fl::Tensor(
            fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
        g_bytes_used += t->bytes();
        this->_tensor = t;
        return;
      }
      case napi_float64_array: {
        Napi::TypedArrayOf<double> double_array =
            underlying.As<Napi::TypedArrayOf<double>>();
        double* ptr = double_array.Data();
        auto* t = new fl::Tensor(
            fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
        g_bytes_used += t->bytes();
        this->_tensor = t;
        return;
      }
      case napi_int8_array: {
        Napi::TypedArrayOf<int8_t> int8_array =
            underlying.As<Napi::TypedArrayOf<int8_t>>();
        char* ptr = reinterpret_cast<char*>(int8_array.Data());
        auto* t = new fl::Tensor(
            fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
        g_bytes_used += t->bytes();
        this->_tensor = t;
        return;
      }
      case napi_uint8_array: {
        Napi::TypedArrayOf<uint8_t> uint8_array =
            underlying.As<Napi::TypedArrayOf<uint8_t>>();
        uint8_t* ptr = uint8_array.Data();
        auto* t = new fl::Tensor(
            fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
        g_bytes_used += t->bytes();
        this->_tensor = t;
        return;
      }
      case napi_int16_array: {
        Napi::TypedArrayOf<int16_t> int16_array =
            underlying.As<Napi::TypedArrayOf<int16_t>>();
        int16_t* ptr = int16_array.Data();
        auto* t = new fl::Tensor(
            fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
        g_bytes_used += t->bytes();
        this->_tensor = t;
        return;
      }
      case napi_uint16_array: {
        Napi::TypedArrayOf<uint16_t> uint16_array =
            underlying.As<Napi::TypedArrayOf<uint16_t>>();
        uint16_t* ptr = uint16_array.Data();
        auto* t = new fl::Tensor(
            fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
        g_bytes_used += t->bytes();
        this->_tensor = t;
        return;
      }
      case napi_int32_array: {
        Napi::TypedArrayOf<int32_t> int32_array =
            underlying.As<Napi::TypedArrayOf<int32_t>>();
        int32_t* ptr = int32_array.Data();
        auto* t = new fl::Tensor(
            fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
        g_bytes_used += t->bytes();
        this->_tensor = t;
        return;
      }
      case napi_uint32_array: {
        Napi::TypedArrayOf<uint32_t> uint32_array =
            underlying.As<Napi::TypedArrayOf<uint32_t>>();
        uint32_t* ptr = uint32_array.Data();
        auto* t = new fl::Tensor(
            fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
        g_bytes_used += t->bytes();
        this->_tensor = t;
        return;
      }
      case napi_bigint64_array: {
        Napi::TypedArrayOf<int64_t> bigint64_array =
            underlying.As<Napi::TypedArrayOf<int64_t>>();
        int64_t* ptr = bigint64_array.Data();
        auto* t = new fl::Tensor(
            fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
        g_bytes_used += t->bytes();
        this->_tensor = t;
        return;
      }
      case napi_biguint64_array: {
        Napi::TypedArrayOf<uint64_t> biguint64_array =
            underlying.As<Napi::TypedArrayOf<uint64_t>>();
        uint64_t* ptr = biguint64_array.Data();
        auto* t = new fl::Tensor(
            fl::Tensor::fromBuffer({length}, ptr, fl::MemoryLocation::Host));
        g_bytes_used += t->bytes();
        this->_tensor = t;
        return;
      }
      default: {
        Napi::TypeError::New(env, "Unhandled TypedArray type")
            .ThrowAsJavaScriptException();
        return;
      }
    }
  }
  // TODO: handle `typeof arg === 'number'`
  if (info[0].IsNumber()) {
    const size_t length = 1;
    Napi::TypedArrayOf<int64_t> arr =
        Napi::TypedArrayOf<int64_t>::New(env, length, napi_bigint64_array);
    arr[0] = info[0].As<Napi::Number>().Int64Value();
    auto* ptr = arr.Data();
    auto shape = arrayArg<long long>(ptr, 1, g_row_major, false);
    auto* t = new fl::Tensor(fl::Shape(shape));
    g_bytes_used += t->bytes();
    this->_tensor = t;
    return;
  }
}
// exported "Tensor" class methods
Napi::Value Tensor::clip(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`clip` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`clip` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object low_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`clip` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object high_obj = info[1].As<Napi::Object>();
  if (low_obj.InstanceOf(Tensor::constructor->Value()) &&
      high_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* low = Napi::ObjectWrap<Tensor>::Unwrap(low_obj);
    Tensor* high = Napi::ObjectWrap<Tensor>::Unwrap(high_obj);
    fl::Tensor _res;
    _res = fl::clip(*(this->_tensor), *(low->_tensor), *(high->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::cumsum(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`cumsum` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`cumsum` expects args[0] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  unsigned axis =
      static_cast<unsigned>(info[0].As<Napi::Number>().Uint32Value());
  fl::Tensor _res;
  _res = fl::cumsum(*(this->_tensor), axis);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::countNonzero(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`countNonzero` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(
        info.Env(), "`countNonzero` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(
          info.Env(), ("`countNonzero` expects args[0][" + std::to_string(i) +
                       "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto axes = jsArrayArg<int>(info[0].As<Napi::Array>(), g_row_major,
                              this->_tensor->ndim(), env);
  if (!info[1].IsBoolean()) {
    Napi::TypeError::New(
        info.Env(), "`countNonzero` expects args[1] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[1].As<Napi::Boolean>().Value();
  fl::Tensor _res;
  _res = fl::countNonzero(*(this->_tensor), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(this->_tensor)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::absolute(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::absolute(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::log(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::log(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::isinf(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::isinf(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::tril(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  if (g_row_major) {
    _res = fl::triu(*(this->_tensor));
  } else {
    _res = fl::tril(*(this->_tensor));
  }
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::reshape(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`reshape` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`reshape` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto shape =
      jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major, false, env);
  fl::Tensor _res;
  _res = fl::reshape(*(this->_tensor), fl::Shape(shape));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::logicalNot(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::logicalNot(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::sin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::sin(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::cos(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::cos(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::tanh(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::tanh(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::where(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`where` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`where` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object x_obj = info[0].As<Napi::Object>();
  if (!info[1].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`where` expects args[1] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object y_obj = info[1].As<Napi::Object>();
  if (x_obj.InstanceOf(Tensor::constructor->Value()) &&
      y_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* x = Napi::ObjectWrap<Tensor>::Unwrap(x_obj);
    Tensor* y = Napi::ObjectWrap<Tensor>::Unwrap(y_obj);
    fl::Tensor _res;
    _res = fl::where(*(this->_tensor), *(x->_tensor), *(y->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::sum(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`sum` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`sum` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`sum` expects args[0][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto axes = jsArrayArg<int>(info[0].As<Napi::Array>(), g_row_major,
                              this->_tensor->ndim(), env);
  if (!info[1].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`sum` expects args[1] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[1].As<Napi::Boolean>().Value();
  fl::Tensor _res;
  _res = fl::sum(*(this->_tensor), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(this->_tensor)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::var(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`var` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`var` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`var` expects args[0][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto axes = jsArrayArg<int>(info[0].As<Napi::Array>(), g_row_major,
                              this->_tensor->ndim(), env);
  if (!info[1].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`var` expects args[1] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool bias = info[1].As<Napi::Boolean>().Value();
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`var` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  fl::Tensor _res;
  _res = fl::var(*(this->_tensor), axes, bias, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(this->_tensor)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::exp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::exp(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::rint(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::rint(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::sigmoid(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::sigmoid(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::sign(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::sign(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::amin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`amin` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`amin` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`amin` expects args[0][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto axes = jsArrayArg<int>(info[0].As<Napi::Array>(), g_row_major,
                              this->_tensor->ndim(), env);
  if (!info[1].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`amin` expects args[1] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[1].As<Napi::Boolean>().Value();
  fl::Tensor _res;
  _res = fl::amin(*(this->_tensor), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(this->_tensor)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::argmin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`argmin` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`argmin` expects args[0] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto axis = axisArg(info[0].As<Napi::Number>().Uint32Value(), g_row_major,
                      this->_tensor->ndim());
  if (!info[1].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`argmin` expects args[1] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[1].As<Napi::Boolean>().Value();
  fl::Tensor _res;
  _res = fl::argmin(*(this->_tensor), axis, keepDims);
  auto axes_set = std::unordered_set<int>{static_cast<int>(axis)};
  auto base_shape = (*(this->_tensor)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::norm(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 3) {
    Napi::TypeError::New(info.Env(), "`norm` expects exactly 3 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`norm` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`norm` expects args[0][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto axes = jsArrayArg<int>(info[0].As<Napi::Array>(), g_row_major,
                              this->_tensor->ndim(), env);
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`norm` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  double p = info[1].As<Napi::Number>().DoubleValue();
  if (!info[2].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`norm` expects args[2] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[2].As<Napi::Boolean>().Value();
  fl::Tensor _res;
  _res = fl::norm(*(this->_tensor), axes, p, keepDims);
  if (p == std::numeric_limits<double>::infinity()) {
    _res = fl::abs(*(this->_tensor));
    _res = fl::amax(*(this->_tensor), axes, keepDims);
  }
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(this->_tensor)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::ceil(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::ceil(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::any(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`any` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`any` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`any` expects args[0][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto axes = jsArrayArg<int>(info[0].As<Napi::Array>(), g_row_major,
                              this->_tensor->ndim(), env);
  if (!info[1].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`any` expects args[1] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[1].As<Napi::Boolean>().Value();
  fl::Tensor _res;
  _res = fl::any(*(this->_tensor), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(this->_tensor)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::flip(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`flip` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`flip` expects args[0] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  unsigned dim =
      static_cast<unsigned>(info[0].As<Napi::Number>().Uint32Value());
  fl::Tensor _res;
  _res = fl::flip(*(this->_tensor), dim);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::isnan(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::isnan(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::transpose(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`transpose` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`transpose` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto axes = jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major,
                                    this->_tensor->ndim(), env);
  fl::Tensor _res;
  _res = fl::transpose(*(this->_tensor), fl::Shape(axes));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::floor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::floor(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::triu(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  if (g_row_major) {
    _res = fl::tril(*(this->_tensor));
  } else {
    _res = fl::triu(*(this->_tensor));
  }
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::maximum(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`maximum` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`maximum` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::maximum(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::power(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`power` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`power` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::power(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::matmul(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`matmul` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`matmul` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    if (g_row_major) {
      _res = fl::matmul(*(rhs->_tensor), *(this->_tensor));
    } else {
      _res = fl::matmul(*(this->_tensor), *(rhs->_tensor));
    }
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::all(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`all` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`all` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`all` expects args[0][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto axes = jsArrayArg<int>(info[0].As<Napi::Array>(), g_row_major,
                              this->_tensor->ndim(), env);
  if (!info[1].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`all` expects args[1] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[1].As<Napi::Boolean>().Value();
  fl::Tensor _res;
  _res = fl::all(*(this->_tensor), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(this->_tensor)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::log1p(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::log1p(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::negative(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::negative(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::sort(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`sort` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`sort` expects args[0] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto axis = info[0].As<Napi::Number>().Uint32Value();
  fl::Tensor _res;
  _res = fl::sort(*(this->_tensor), axis);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::amax(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`amax` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`amax` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`amax` expects args[0][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto axes = jsArrayArg<int>(info[0].As<Napi::Array>(), g_row_major,
                              this->_tensor->ndim(), env);
  if (!info[1].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`amax` expects args[1] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[1].As<Napi::Boolean>().Value();
  fl::Tensor _res;
  _res = fl::amax(*(this->_tensor), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(this->_tensor)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::mean(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`mean` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`mean` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`mean` expects args[0][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto axes = jsArrayArg<int>(info[0].As<Napi::Array>(), g_row_major,
                              this->_tensor->ndim(), env);
  if (!info[1].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`mean` expects args[1] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[1].As<Napi::Boolean>().Value();
  fl::Tensor _res;
  _res = fl::mean(*(this->_tensor), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(this->_tensor)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::median(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`median` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`median` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`median` expects args[0][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto axes = jsArrayArg<int>(info[0].As<Napi::Array>(), g_row_major,
                              this->_tensor->ndim(), env);
  if (!info[1].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`median` expects args[1] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[1].As<Napi::Boolean>().Value();
  fl::Tensor _res;
  _res = fl::median(*(this->_tensor), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(this->_tensor)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::nonzero(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::nonzero(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::erf(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::erf(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::roll(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`roll` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`roll` expects args[0] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int shift = static_cast<int>(info[0].As<Napi::Number>().Int64Value());
  if (!info[1].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`roll` expects args[1] to be typeof `number`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  unsigned axis =
      static_cast<unsigned>(info[1].As<Napi::Number>().Uint32Value());
  fl::Tensor _res;
  _res = fl::roll(*(this->_tensor), shift, axis);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::std(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 2) {
    Napi::TypeError::New(info.Env(), "`std` expects exactly 2 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`std` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  int len_axes = info[0].As<Napi::Array>().Length();
  for (auto i = 0; i < len_axes; ++i) {
    if (!info[0].As<Napi::Array>().Get(i).IsNumber()) {
      Napi::TypeError::New(info.Env(),
                           ("`std` expects args[0][" + std::to_string(i) +
                            "] to be typeof `number`"))
          .ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  auto axes = jsArrayArg<int>(info[0].As<Napi::Array>(), g_row_major,
                              this->_tensor->ndim(), env);
  if (!info[1].IsBoolean()) {
    Napi::TypeError::New(info.Env(),
                         "`std` expects args[1] to be typeof `boolean`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  bool keepDims = info[1].As<Napi::Boolean>().Value();
  fl::Tensor _res;
  _res = fl::median(*(this->_tensor), axes, keepDims);
  auto axes_set = std::unordered_set<int>(axes.begin(), axes.end());
  auto base_shape = (*(this->_tensor)).shape().get();
  std::vector<fl::Dim> new_shape;
  for (size_t idx = 0; idx < base_shape.size(); ++idx) {
    if (axes_set.count(idx) || (axes_set.size() == 0)) {
      if (keepDims) {
        new_shape.emplace_back(1);
      }
      continue;
    }
    new_shape.emplace_back(base_shape[idx]);
  }
  const auto& shape = fl::Shape(new_shape);
  _res = fl::reshape(_res, shape);
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::tile(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`tile` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`tile` expects args[0] to be typeof `number[]`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto shape =
      jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major, false, env);
  fl::Tensor _res;
  _res = fl::tile(*(this->_tensor), fl::Shape(shape));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::sqrt(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  fl::Tensor _res;
  _res = fl::sqrt(*(this->_tensor));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
  return wrapped_out;
}

Napi::Value Tensor::lessThan(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`lessThan` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`lessThan` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::lessThan(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::greaterThan(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`greaterThan` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`greaterThan` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::greaterThan(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::mod(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`mod` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`mod` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::mod(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::bitwiseOr(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`bitwiseOr` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`bitwiseOr` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::bitwiseOr(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::bitwiseXor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`bitwiseXor` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`bitwiseXor` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::bitwiseXor(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::logicalOr(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`logicalOr` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`logicalOr` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::logicalOr(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::add(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`add` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`add` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::add(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::neq(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`neq` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`neq` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::neq(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::lessThanEqual(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`lessThanEqual` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`lessThanEqual` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::lessThanEqual(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::eq(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`eq` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`eq` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::eq(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::bitwiseAnd(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`bitwiseAnd` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`bitwiseAnd` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::bitwiseAnd(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::rShift(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`rShift` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`rShift` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::rShift(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::mul(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`mul` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`mul` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::mul(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::div(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`div` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`div` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::div(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::logicalAnd(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`logicalAnd` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(), "`logicalAnd` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::logicalAnd(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::greaterThanEqual(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(),
                         "`greaterThanEqual` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(
        info.Env(),
        "`greaterThanEqual` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::greaterThanEqual(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::lShift(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`lShift` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`lShift` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::lShift(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::sub(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`sub` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsObject()) {
    Napi::TypeError::New(info.Env(),
                         "`sub` expects args[0] to be instanceof `Tensor`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Object rhs_obj = info[0].As<Napi::Object>();
  if (rhs_obj.InstanceOf(Tensor::constructor->Value())) {
    Tensor* rhs = Napi::ObjectWrap<Tensor>::Unwrap(rhs_obj);
    fl::Tensor _res;
    _res = fl::sub(*(this->_tensor), *(rhs->_tensor));
    g_bytes_used += _res.bytes();
    auto* out = new fl::Tensor(_res);
    auto wrapped = Napi::External<fl::Tensor>::New(env, out);
    Napi::Value wrapped_out = Tensor::constructor->New({wrapped});
    return wrapped_out;
  }
  return env.Null();
}

Napi::Value Tensor::copy(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  auto _res = this->_tensor->copy();
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto _wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({_wrapped});
  return wrapped_out;
}

Napi::Value Tensor::shape(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  auto _res = this->_tensor->shape();
  const size_t length = static_cast<const size_t>(this->_tensor->ndim());
  Napi::TypedArrayOf<int64_t> _out =
      Napi::TypedArrayOf<int64_t>::New(env, length, napi_bigint64_array);
  const int out_len = static_cast<int>(length);
  for (auto i = 0; i < out_len; ++i) {
    const auto idx = g_row_major ? out_len - i - 1 : i;
    _out[i] = static_cast<long long>(_res[idx]);
  }
  return _out;
}

Napi::Value Tensor::elements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  auto _res = this->_tensor->elements();
  return Napi::Number::New(env, _res);
}

Napi::Value Tensor::ndim(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  auto _res = this->_tensor->ndim();
  return Napi::Number::New(env, _res);
}

Napi::Value Tensor::isEmpty(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  auto _res = this->_tensor->isEmpty();
  return Napi::Boolean::New(env, _res);
}

Napi::Value Tensor::bytes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  auto _res = this->_tensor->bytes();
  return Napi::Number::New(env, _res);
}

Napi::Value Tensor::type(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  auto _res = this->_tensor->type();
  Napi::Number _out = Napi::Number::New(env, static_cast<int>(_res));
  return _out;
}

Napi::Value Tensor::isSparse(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  auto _res = this->_tensor->isSparse();
  return Napi::Boolean::New(env, _res);
}

Napi::Value Tensor::strides(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  auto _res = this->_tensor->strides();
  const size_t length = static_cast<const size_t>(this->_tensor->ndim());
  Napi::TypedArrayOf<int64_t> _out =
      Napi::TypedArrayOf<int64_t>::New(env, length, napi_bigint64_array);
  const int out_len = static_cast<int>(length);
  for (auto i = 0; i < out_len; ++i) {
    const auto idx = g_row_major ? out_len - i - 1 : i;
    _out[i] = static_cast<long long>(_res[idx]);
  }
  return _out;
}

Napi::Value Tensor::astype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1) {
    Napi::TypeError::New(info.Env(), "`astype` expects exactly 1 args")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  if (!info[0].IsNumber()) {
    Napi::TypeError::New(info.Env(),
                         "`astype` expects args[0] to be typeof `dtype`")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  auto type = static_cast<fl::dtype>(info[0].As<Napi::Number>().Int32Value());
  auto _res = this->_tensor->astype(fl::dtype(type));
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto _wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({_wrapped});
  return wrapped_out;
}

Napi::Value Tensor::flatten(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  auto _res = this->_tensor->flatten();
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto _wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({_wrapped});
  return wrapped_out;
}

Napi::Value Tensor::asContiguousTensor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  auto _res = this->_tensor->asContiguousTensor();
  g_bytes_used += _res.bytes();
  auto* out = new fl::Tensor(_res);
  auto _wrapped = Napi::External<fl::Tensor>::New(env, out);
  Napi::Value wrapped_out = Tensor::constructor->New({_wrapped});
  return wrapped_out;
}

Napi::Value Tensor::isContiguous(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  auto _res = this->_tensor->isContiguous();
  return Napi::Boolean::New(env, _res);
}

Napi::Value Tensor::toFloat32Array(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  size_t elemLen = static_cast<size_t>(this->_tensor->elements());
  size_t byteLen = elemLen * sizeof(float);
  void* ptr = this->_tensor->astype(fl::dtype::f32).host<float>();
  Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
  Napi::TypedArrayOf<float> out =
      Napi::TypedArrayOf<float>::New(env, elemLen, buff, 0, napi_float32_array);
  return out;
}

Napi::Value Tensor::toFloat64Array(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  size_t elemLen = static_cast<size_t>(this->_tensor->elements());
  size_t byteLen = elemLen * sizeof(double);
  void* ptr = this->_tensor->astype(fl::dtype::f64).host<double>();
  Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
  Napi::TypedArrayOf<double> out = Napi::TypedArrayOf<double>::New(
      env, elemLen, buff, 0, napi_float64_array);
  return out;
}

Napi::Value Tensor::toBoolInt8Array(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  size_t elemLen = static_cast<size_t>(this->_tensor->elements());
  size_t byteLen = elemLen * sizeof(int8_t);
  void* ptr = this->_tensor->astype(fl::dtype::b8).host<int>();
  Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
  Napi::TypedArrayOf<int8_t> out =
      Napi::TypedArrayOf<int8_t>::New(env, elemLen, buff, 0, napi_int8_array);
  return out;
}

Napi::Value Tensor::toInt16Array(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  size_t elemLen = static_cast<size_t>(this->_tensor->elements());
  size_t byteLen = elemLen * sizeof(int16_t);
  void* ptr = this->_tensor->astype(fl::dtype::s16).host<int>();
  Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
  Napi::TypedArrayOf<int16_t> out =
      Napi::TypedArrayOf<int16_t>::New(env, elemLen, buff, 0, napi_int16_array);
  return out;
}

Napi::Value Tensor::toInt32Array(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  size_t elemLen = static_cast<size_t>(this->_tensor->elements());
  size_t byteLen = elemLen * sizeof(int32_t);
  void* ptr = this->_tensor->astype(fl::dtype::s32).host<int>();
  Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
  Napi::TypedArrayOf<int32_t> out =
      Napi::TypedArrayOf<int32_t>::New(env, elemLen, buff, 0, napi_int32_array);
  return out;
}

Napi::Value Tensor::toInt64Array(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  size_t elemLen = static_cast<size_t>(this->_tensor->elements());
  size_t byteLen = elemLen * sizeof(int64_t);
  void* ptr = this->_tensor->astype(fl::dtype::s64).host<int>();
  Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
  Napi::TypedArrayOf<int64_t> out = Napi::TypedArrayOf<int64_t>::New(
      env, elemLen, buff, 0, napi_bigint64_array);
  return out;
}

Napi::Value Tensor::toUint8Array(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  size_t elemLen = static_cast<size_t>(this->_tensor->elements());
  size_t byteLen = elemLen * sizeof(uint8_t);
  void* ptr = this->_tensor->astype(fl::dtype::u8).host<unsigned>();
  Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
  Napi::TypedArrayOf<uint8_t> out =
      Napi::TypedArrayOf<uint8_t>::New(env, elemLen, buff, 0, napi_uint8_array);
  return out;
}

Napi::Value Tensor::toUint16Array(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  size_t elemLen = static_cast<size_t>(this->_tensor->elements());
  size_t byteLen = elemLen * sizeof(uint16_t);
  void* ptr = this->_tensor->astype(fl::dtype::u16).host<unsigned>();
  Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
  Napi::TypedArrayOf<uint16_t> out = Napi::TypedArrayOf<uint16_t>::New(
      env, elemLen, buff, 0, napi_uint16_array);
  return out;
}

Napi::Value Tensor::toUint32Array(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  size_t elemLen = static_cast<size_t>(this->_tensor->elements());
  size_t byteLen = elemLen * sizeof(uint32_t);
  void* ptr = this->_tensor->astype(fl::dtype::u32).host<unsigned>();
  Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
  Napi::TypedArrayOf<uint32_t> out = Napi::TypedArrayOf<uint32_t>::New(
      env, elemLen, buff, 0, napi_uint32_array);
  return out;
}

Napi::Value Tensor::toUint64Array(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  size_t elemLen = static_cast<size_t>(this->_tensor->elements());
  size_t byteLen = elemLen * sizeof(uint64_t);
  void* ptr = this->_tensor->astype(fl::dtype::u64).host<unsigned>();
  Napi::ArrayBuffer buff = Napi::ArrayBuffer::New(env, ptr, byteLen);
  Napi::TypedArrayOf<uint64_t> out = Napi::TypedArrayOf<uint64_t>::New(
      env, elemLen, buff, 0, napi_biguint64_array);
  return out;
}

Napi::Value Tensor::toFloat32Scalar(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), this->_tensor->asScalar<float>());
}

Napi::Value Tensor::toFloat64Scalar(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), this->_tensor->asScalar<double>());
}

Napi::Value Tensor::toBoolInt8Scalar(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), this->_tensor->asScalar<char>());
}

Napi::Value Tensor::toInt16Scalar(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), this->_tensor->asScalar<int16_t>());
}

Napi::Value Tensor::toInt32Scalar(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), this->_tensor->asScalar<int32_t>());
}

Napi::Value Tensor::toInt64Scalar(const Napi::CallbackInfo& info) {
  return Napi::BigInt::New(
      info.Env(), static_cast<int64_t>(this->_tensor->asScalar<int64_t>()));
}

Napi::Value Tensor::toUint8Scalar(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), this->_tensor->asScalar<uint8_t>());
}

Napi::Value Tensor::toUint16Scalar(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), this->_tensor->asScalar<uint16_t>());
}

Napi::Value Tensor::toUint32Scalar(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), this->_tensor->asScalar<uint32_t>());
}

Napi::Value Tensor::toUint64Scalar(const Napi::CallbackInfo& info) {
  return Napi::BigInt::New(
      info.Env(), static_cast<int64_t>(this->_tensor->asScalar<uint64_t>()));
}

void Tensor::eval(const Napi::CallbackInfo& info) {
  fl::eval(*(this->_tensor));
}

void Tensor::dispose(const Napi::CallbackInfo& info) {
  auto& tensor = *reinterpret_cast<fl::Tensor*>(this->_tensor);
  g_bytes_used -= tensor.bytes();
  fl::detail::releaseAdapterUnsafe(tensor);
}

Napi::FunctionReference* Tensor::constructor;
Napi::Function Tensor::GetClass(Napi::Env env) {
  Napi::Function func = DefineClass(
      env, "Tensor",
      {
          Tensor::InstanceMethod("norm", &Tensor::norm),
          Tensor::InstanceMethod("ceil", &Tensor::ceil),
          Tensor::InstanceMethod("rint", &Tensor::rint),
          Tensor::InstanceMethod("sigmoid", &Tensor::sigmoid),
          Tensor::InstanceMethod("sign", &Tensor::sign),
          Tensor::InstanceMethod("amin", &Tensor::amin),
          Tensor::InstanceMethod("argmin", &Tensor::argmin),
          Tensor::InstanceMethod("any", &Tensor::any),
          Tensor::InstanceMethod("transpose", &Tensor::transpose),
          Tensor::InstanceMethod("floor", &Tensor::floor),
          Tensor::InstanceMethod("flip", &Tensor::flip),
          Tensor::InstanceMethod("isnan", &Tensor::isnan),
          Tensor::InstanceMethod("log1p", &Tensor::log1p),
          Tensor::InstanceMethod("triu", &Tensor::triu),
          Tensor::InstanceMethod("maximum", &Tensor::maximum),
          Tensor::InstanceMethod("power", &Tensor::power),
          Tensor::InstanceMethod("matmul", &Tensor::matmul),
          Tensor::InstanceMethod("all", &Tensor::all),
          Tensor::InstanceMethod("nonzero", &Tensor::nonzero),
          Tensor::InstanceMethod("negative", &Tensor::negative),
          Tensor::InstanceMethod("sort", &Tensor::sort),
          Tensor::InstanceMethod("amax", &Tensor::amax),
          Tensor::InstanceMethod("mean", &Tensor::mean),
          Tensor::InstanceMethod("median", &Tensor::median),
          Tensor::InstanceMethod("tile", &Tensor::tile),
          Tensor::InstanceMethod("sqrt", &Tensor::sqrt),
          Tensor::InstanceMethod("erf", &Tensor::erf),
          Tensor::InstanceMethod("roll", &Tensor::roll),
          Tensor::InstanceMethod("std", &Tensor::std),
          Tensor::InstanceMethod("absolute", &Tensor::absolute),
          Tensor::InstanceMethod("clip", &Tensor::clip),
          Tensor::InstanceMethod("cumsum", &Tensor::cumsum),
          Tensor::InstanceMethod("countNonzero", &Tensor::countNonzero),
          Tensor::InstanceMethod("reshape", &Tensor::reshape),
          Tensor::InstanceMethod("logicalNot", &Tensor::logicalNot),
          Tensor::InstanceMethod("log", &Tensor::log),
          Tensor::InstanceMethod("isinf", &Tensor::isinf),
          Tensor::InstanceMethod("tril", &Tensor::tril),
          Tensor::InstanceMethod("var", &Tensor::var),
          Tensor::InstanceMethod("exp", &Tensor::exp),
          Tensor::InstanceMethod("sin", &Tensor::sin),
          Tensor::InstanceMethod("cos", &Tensor::cos),
          Tensor::InstanceMethod("tanh", &Tensor::tanh),
          Tensor::InstanceMethod("where", &Tensor::where),
          Tensor::InstanceMethod("sum", &Tensor::sum),
          Tensor::InstanceMethod("eq", &Tensor::eq),
          Tensor::InstanceMethod("bitwiseAnd", &Tensor::bitwiseAnd),
          Tensor::InstanceMethod("rShift", &Tensor::rShift),
          Tensor::InstanceMethod("mul", &Tensor::mul),
          Tensor::InstanceMethod("div", &Tensor::div),
          Tensor::InstanceMethod("logicalAnd", &Tensor::logicalAnd),
          Tensor::InstanceMethod("greaterThanEqual", &Tensor::greaterThanEqual),
          Tensor::InstanceMethod("lShift", &Tensor::lShift),
          Tensor::InstanceMethod("sub", &Tensor::sub),
          Tensor::InstanceMethod("lessThan", &Tensor::lessThan),
          Tensor::InstanceMethod("greaterThan", &Tensor::greaterThan),
          Tensor::InstanceMethod("mod", &Tensor::mod),
          Tensor::InstanceMethod("bitwiseOr", &Tensor::bitwiseOr),
          Tensor::InstanceMethod("bitwiseXor", &Tensor::bitwiseXor),
          Tensor::InstanceMethod("logicalOr", &Tensor::logicalOr),
          Tensor::InstanceMethod("add", &Tensor::add),
          Tensor::InstanceMethod("neq", &Tensor::neq),
          Tensor::InstanceMethod("lessThanEqual", &Tensor::lessThanEqual),
          Tensor::InstanceMethod("copy", &Tensor::copy),
          Tensor::InstanceMethod("shape", &Tensor::shape),
          Tensor::InstanceMethod("elements", &Tensor::elements),
          Tensor::InstanceMethod("ndim", &Tensor::ndim),
          Tensor::InstanceMethod("isEmpty", &Tensor::isEmpty),
          Tensor::InstanceMethod("bytes", &Tensor::bytes),
          Tensor::InstanceMethod("type", &Tensor::type),
          Tensor::InstanceMethod("isSparse", &Tensor::isSparse),
          Tensor::InstanceMethod("strides", &Tensor::strides),
          Tensor::InstanceMethod("astype", &Tensor::astype),
          Tensor::InstanceMethod("flatten", &Tensor::flatten),
          Tensor::InstanceMethod("asContiguousTensor",
                                 &Tensor::asContiguousTensor),
          Tensor::InstanceMethod("isContiguous", &Tensor::isContiguous),
          Tensor::InstanceMethod("toFloat32Array", &Tensor::toFloat32Array),
          Tensor::InstanceMethod("toFloat64Array", &Tensor::toFloat64Array),
          Tensor::InstanceMethod("toBoolInt8Array", &Tensor::toBoolInt8Array),
          Tensor::InstanceMethod("toInt16Array", &Tensor::toInt16Array),
          Tensor::InstanceMethod("toInt32Array", &Tensor::toInt32Array),
          Tensor::InstanceMethod("toInt64Array", &Tensor::toInt64Array),
          Tensor::InstanceMethod("toUint8Array", &Tensor::toUint8Array),
          Tensor::InstanceMethod("toUint16Array", &Tensor::toUint16Array),
          Tensor::InstanceMethod("toUint32Array", &Tensor::toUint32Array),
          Tensor::InstanceMethod("toUint64Array", &Tensor::toUint64Array),
          Tensor::InstanceMethod("toFloat32Scalar", &Tensor::toFloat32Scalar),
          Tensor::InstanceMethod("toFloat64Scalar", &Tensor::toFloat64Scalar),
          Tensor::InstanceMethod("toBoolInt8Scalar", &Tensor::toBoolInt8Scalar),
          Tensor::InstanceMethod("toInt16Scalar", &Tensor::toInt16Scalar),
          Tensor::InstanceMethod("toInt32Scalar", &Tensor::toInt32Scalar),
          Tensor::InstanceMethod("toInt64Scalar", &Tensor::toInt64Scalar),
          Tensor::InstanceMethod("toUint8Scalar", &Tensor::toUint8Scalar),
          Tensor::InstanceMethod("toUint16Scalar", &Tensor::toUint16Scalar),
          Tensor::InstanceMethod("toUint32Scalar", &Tensor::toUint32Scalar),
          Tensor::InstanceMethod("toUint64Scalar", &Tensor::toUint64Scalar),
          Tensor::InstanceMethod("eval", &Tensor::eval),
          Tensor::InstanceMethod("dispose", &Tensor::dispose),
      });
  constructor = new Napi::FunctionReference();
  *constructor = Napi::Persistent(func);
  return func;
}

static void _init(const Napi::CallbackInfo& info) {
  fl::init();
}

static Napi::Value _bytesUsed(const Napi::CallbackInfo& info) {
  return Napi::BigInt::New(info.Env(), static_cast<int64_t>(g_bytes_used));
}

static void _setRowMajor(const Napi::CallbackInfo& info) {
  g_row_major = true;
}

static void _setColMajor(const Napi::CallbackInfo& info) {
  g_row_major = true;
}

static Napi::Value _isRowMajor(const Napi::CallbackInfo& info) {
  return Napi::Boolean::New(info.Env(), g_row_major);
}

static Napi::Value _isColMajor(const Napi::CallbackInfo& info) {
  return Napi::Boolean::New(info.Env(), !g_row_major);
}

static Napi::Value _dtypeFloat32(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::f32));
}

static Napi::Value _dtypeFloat64(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::f64));
}

static Napi::Value _dtypeBoolInt8(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::b8));
}

static Napi::Value _dtypeInt16(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::s16));
}

static Napi::Value _dtypeInt32(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::s32));
}

static Napi::Value _dtypeInt64(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::s64));
}

static Napi::Value _dtypeUint8(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::u8));
}

static Napi::Value _dtypeUint16(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::u16));
}

static Napi::Value _dtypeUint32(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::u32));
}

static Napi::Value _dtypeUint64(const Napi::CallbackInfo& info) {
  return Napi::Number::New(info.Env(), static_cast<double>(fl::dtype::u64));
}

static Napi::Value _rand(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1 || !info[0].IsArray()) {
    Napi::TypeError::New(info.Env(),
                         "`rand` expects exactly 1 arg; "
                         "(expected type `number[]`)...")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  std::vector<long long> shape =
      jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major, false, env);
  fl::Tensor t;
  t = fl::rand(fl::Shape(shape));
  g_bytes_used += t.bytes();
  auto* tensor = new fl::Tensor(t);
  auto wrapped = Napi::External<fl::Tensor>::New(env, tensor);
  Napi::Value wrappedTensor = Tensor::constructor->New({wrapped});
  return wrappedTensor;
}

static Napi::Value _randn(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info.Length() != 1 || !info[0].IsArray()) {
    Napi::TypeError::New(
        env, "`randn` expects exactly 1 arg; (expected type `number[]`)...")
        .ThrowAsJavaScriptException();
    return env.Null();
  }
  std::vector<long long> shape =
      jsArrayArg<long long>(info[0].As<Napi::Array>(), g_row_major, false, env);
  fl::Tensor t;
  t = fl::randn(fl::Shape(shape));
  g_bytes_used += t.bytes();
  auto* tensor = new fl::Tensor(t);
  auto wrapped = Napi::External<fl::Tensor>::New(env, tensor);
  Napi::Value wrappedTensor = Tensor::constructor->New({wrapped});
  return wrappedTensor;
}

// NAPI exports
Napi::Object Init(Napi::Env env, Napi::Object exports) {
  exports.Set(Napi::String::New(env, "_Tensor"), Tensor::GetClass(env));
  exports.Set(Napi::String::New(env, "_sigmoid"),
              Napi::Function::New(env, _sigmoid));
  exports.Set(Napi::String::New(env, "_sign"), Napi::Function::New(env, _sign));
  exports.Set(Napi::String::New(env, "_amin"), Napi::Function::New(env, _amin));
  exports.Set(Napi::String::New(env, "_argmin"),
              Napi::Function::New(env, _argmin));
  exports.Set(Napi::String::New(env, "_norm"), Napi::Function::New(env, _norm));
  exports.Set(Napi::String::New(env, "_concatenate"),
              Napi::Function::New(env, _concatenate));
  exports.Set(Napi::String::New(env, "_ceil"), Napi::Function::New(env, _ceil));
  exports.Set(Napi::String::New(env, "_rint"), Napi::Function::New(env, _rint));
  exports.Set(Napi::String::New(env, "_any"), Napi::Function::New(env, _any));
  exports.Set(Napi::String::New(env, "_isnan"),
              Napi::Function::New(env, _isnan));
  exports.Set(Napi::String::New(env, "_transpose"),
              Napi::Function::New(env, _transpose));
  exports.Set(Napi::String::New(env, "_floor"),
              Napi::Function::New(env, _floor));
  exports.Set(Napi::String::New(env, "_flip"), Napi::Function::New(env, _flip));
  exports.Set(Napi::String::New(env, "_maximum"),
              Napi::Function::New(env, _maximum));
  exports.Set(Napi::String::New(env, "_power"),
              Napi::Function::New(env, _power));
  exports.Set(Napi::String::New(env, "_matmul"),
              Napi::Function::New(env, _matmul));
  exports.Set(Napi::String::New(env, "_all"), Napi::Function::New(env, _all));
  exports.Set(Napi::String::New(env, "_arange"),
              Napi::Function::New(env, _arange));
  exports.Set(Napi::String::New(env, "_log1p"),
              Napi::Function::New(env, _log1p));
  exports.Set(Napi::String::New(env, "_triu"), Napi::Function::New(env, _triu));
  exports.Set(Napi::String::New(env, "_sort"), Napi::Function::New(env, _sort));
  exports.Set(Napi::String::New(env, "_amax"), Napi::Function::New(env, _amax));
  exports.Set(Napi::String::New(env, "_mean"), Napi::Function::New(env, _mean));
  exports.Set(Napi::String::New(env, "_median"),
              Napi::Function::New(env, _median));
  exports.Set(Napi::String::New(env, "_iota"), Napi::Function::New(env, _iota));
  exports.Set(Napi::String::New(env, "_nonzero"),
              Napi::Function::New(env, _nonzero));
  exports.Set(Napi::String::New(env, "_negative"),
              Napi::Function::New(env, _negative));
  exports.Set(Napi::String::New(env, "_roll"), Napi::Function::New(env, _roll));
  exports.Set(Napi::String::New(env, "_argmax"),
              Napi::Function::New(env, _argmax));
  exports.Set(Napi::String::New(env, "_std"), Napi::Function::New(env, _std));
  exports.Set(Napi::String::New(env, "_tile"), Napi::Function::New(env, _tile));
  exports.Set(Napi::String::New(env, "_sqrt"), Napi::Function::New(env, _sqrt));
  exports.Set(Napi::String::New(env, "_erf"), Napi::Function::New(env, _erf));
  exports.Set(Napi::String::New(env, "_minimum"),
              Napi::Function::New(env, _minimum));
  exports.Set(Napi::String::New(env, "_cumsum"),
              Napi::Function::New(env, _cumsum));
  exports.Set(Napi::String::New(env, "_countNonzero"),
              Napi::Function::New(env, _countNonzero));
  exports.Set(Napi::String::New(env, "_full"), Napi::Function::New(env, _full));
  exports.Set(Napi::String::New(env, "_absolute"),
              Napi::Function::New(env, _absolute));
  exports.Set(Napi::String::New(env, "_clip"), Napi::Function::New(env, _clip));
  exports.Set(Napi::String::New(env, "_isinf"),
              Napi::Function::New(env, _isinf));
  exports.Set(Napi::String::New(env, "_tril"), Napi::Function::New(env, _tril));
  exports.Set(Napi::String::New(env, "_reshape"),
              Napi::Function::New(env, _reshape));
  exports.Set(Napi::String::New(env, "_logicalNot"),
              Napi::Function::New(env, _logicalNot));
  exports.Set(Napi::String::New(env, "_log"), Napi::Function::New(env, _log));
  exports.Set(Napi::String::New(env, "_cos"), Napi::Function::New(env, _cos));
  exports.Set(Napi::String::New(env, "_tanh"), Napi::Function::New(env, _tanh));
  exports.Set(Napi::String::New(env, "_where"),
              Napi::Function::New(env, _where));
  exports.Set(Napi::String::New(env, "_sum"), Napi::Function::New(env, _sum));
  exports.Set(Napi::String::New(env, "_var"), Napi::Function::New(env, _var));
  exports.Set(Napi::String::New(env, "_identity"),
              Napi::Function::New(env, _identity));
  exports.Set(Napi::String::New(env, "_exp"), Napi::Function::New(env, _exp));
  exports.Set(Napi::String::New(env, "_sin"), Napi::Function::New(env, _sin));
  exports.Set(Napi::String::New(env, "_lessThan"),
              Napi::Function::New(env, _lessThan));
  exports.Set(Napi::String::New(env, "_greaterThan"),
              Napi::Function::New(env, _greaterThan));
  exports.Set(Napi::String::New(env, "_mod"), Napi::Function::New(env, _mod));
  exports.Set(Napi::String::New(env, "_bitwiseOr"),
              Napi::Function::New(env, _bitwiseOr));
  exports.Set(Napi::String::New(env, "_logicalOr"),
              Napi::Function::New(env, _logicalOr));
  exports.Set(Napi::String::New(env, "_add"), Napi::Function::New(env, _add));
  exports.Set(Napi::String::New(env, "_neq"), Napi::Function::New(env, _neq));
  exports.Set(Napi::String::New(env, "_lessThanEqual"),
              Napi::Function::New(env, _lessThanEqual));
  exports.Set(Napi::String::New(env, "_bitwiseXor"),
              Napi::Function::New(env, _bitwiseXor));
  exports.Set(Napi::String::New(env, "_rShift"),
              Napi::Function::New(env, _rShift));
  exports.Set(Napi::String::New(env, "_mul"), Napi::Function::New(env, _mul));
  exports.Set(Napi::String::New(env, "_div"), Napi::Function::New(env, _div));
  exports.Set(Napi::String::New(env, "_logicalAnd"),
              Napi::Function::New(env, _logicalAnd));
  exports.Set(Napi::String::New(env, "_eq"), Napi::Function::New(env, _eq));
  exports.Set(Napi::String::New(env, "_bitwiseAnd"),
              Napi::Function::New(env, _bitwiseAnd));
  exports.Set(Napi::String::New(env, "_greaterThanEqual"),
              Napi::Function::New(env, _greaterThanEqual));
  exports.Set(Napi::String::New(env, "_lShift"),
              Napi::Function::New(env, _lShift));
  exports.Set(Napi::String::New(env, "_sub"), Napi::Function::New(env, _sub));
  exports.Set(Napi::String::New(env, "_init"), Napi::Function::New(env, _init));
  exports.Set(Napi::String::New(env, "_bytesUsed"),
              Napi::Function::New(env, _bytesUsed));
  exports.Set(Napi::String::New(env, "_setRowMajor"),
              Napi::Function::New(env, _setRowMajor));
  exports.Set(Napi::String::New(env, "_setColMajor"),
              Napi::Function::New(env, _setColMajor));
  exports.Set(Napi::String::New(env, "_isRowMajor"),
              Napi::Function::New(env, _isRowMajor));
  exports.Set(Napi::String::New(env, "_isColMajor"),
              Napi::Function::New(env, _isColMajor));
  exports.Set(Napi::String::New(env, "_dtypeFloat32"),
              Napi::Function::New(env, _dtypeFloat32));
  exports.Set(Napi::String::New(env, "_dtypeFloat64"),
              Napi::Function::New(env, _dtypeFloat64));
  exports.Set(Napi::String::New(env, "_dtypeBoolInt8"),
              Napi::Function::New(env, _dtypeBoolInt8));
  exports.Set(Napi::String::New(env, "_dtypeInt16"),
              Napi::Function::New(env, _dtypeInt16));
  exports.Set(Napi::String::New(env, "_dtypeInt32"),
              Napi::Function::New(env, _dtypeInt32));
  exports.Set(Napi::String::New(env, "_dtypeInt64"),
              Napi::Function::New(env, _dtypeInt64));
  exports.Set(Napi::String::New(env, "_dtypeUint8"),
              Napi::Function::New(env, _dtypeUint8));
  exports.Set(Napi::String::New(env, "_dtypeUint16"),
              Napi::Function::New(env, _dtypeUint16));
  exports.Set(Napi::String::New(env, "_dtypeUint32"),
              Napi::Function::New(env, _dtypeUint32));
  exports.Set(Napi::String::New(env, "_dtypeUint64"),
              Napi::Function::New(env, _dtypeUint64));
  exports.Set(Napi::String::New(env, "_rand"), Napi::Function::New(env, _rand));
  exports.Set(Napi::String::New(env, "_randn"),
              Napi::Function::New(env, _randn));
  return exports;
}

NODE_API_MODULE(addon, Init)
